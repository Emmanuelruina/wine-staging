From ee7b37e4b9c357e15f9f92fd7252e1a8c95a8e88 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 5 Mar 2024 13:33:16 +1100
Subject: [PATCH] Updated vkd3d to 9177df883ecf1bc66b39e28d8f6bb616572a75fe.

---
 libs/vkd3d/include/private/vkd3d_common.h |   1 +
 libs/vkd3d/include/vkd3d.h                |   2 +-
 libs/vkd3d/include/vkd3d_shader.h         |   6 ++
 libs/vkd3d/libs/vkd3d-shader/dxil.c       | 116 ++++++++++++++++++++--
 libs/vkd3d/libs/vkd3d-shader/hlsl.c       |   2 +-
 libs/vkd3d/libs/vkd3d-shader/tpf.c        |  41 ++++++++
 libs/vkd3d/libs/vkd3d/device.c            |   8 --
 libs/vkd3d/libs/vkd3d/resource.c          |   4 +-
 libs/vkd3d/libs/vkd3d/vkd3d_private.h     |   8 ++
 9 files changed, 166 insertions(+), 22 deletions(-)

diff --git a/libs/vkd3d/include/private/vkd3d_common.h b/libs/vkd3d/include/private/vkd3d_common.h
index b5a8240d28e..9606e93e8cf 100644
--- a/libs/vkd3d/include/private/vkd3d_common.h
+++ b/libs/vkd3d/include/private/vkd3d_common.h
@@ -64,6 +64,7 @@
 #define TAG_RDEF VKD3D_MAKE_TAG('R', 'D', 'E', 'F')
 #define TAG_RTS0 VKD3D_MAKE_TAG('R', 'T', 'S', '0')
 #define TAG_SDBG VKD3D_MAKE_TAG('S', 'D', 'B', 'G')
+#define TAG_SFI0 VKD3D_MAKE_TAG('S', 'F', 'I', '0')
 #define TAG_SHDR VKD3D_MAKE_TAG('S', 'H', 'D', 'R')
 #define TAG_SHEX VKD3D_MAKE_TAG('S', 'H', 'E', 'X')
 #define TAG_STAT VKD3D_MAKE_TAG('S', 'T', 'A', 'T')
diff --git a/libs/vkd3d/include/vkd3d.h b/libs/vkd3d/include/vkd3d.h
index df361f90177..8a8389f02a4 100644
--- a/libs/vkd3d/include/vkd3d.h
+++ b/libs/vkd3d/include/vkd3d.h
@@ -182,7 +182,7 @@ struct vkd3d_image_resource_create_info
     const void *next;
 
     VkImage vk_image;
-    D3D12_RESOURCE_DESC1 desc;
+    D3D12_RESOURCE_DESC desc;
     unsigned int flags;
     D3D12_RESOURCE_STATES present_state;
 };
diff --git a/libs/vkd3d/include/vkd3d_shader.h b/libs/vkd3d/include/vkd3d_shader.h
index 2f4478a7983..6fa98f3d8fe 100644
--- a/libs/vkd3d/include/vkd3d_shader.h
+++ b/libs/vkd3d/include/vkd3d_shader.h
@@ -199,7 +199,13 @@ enum vkd3d_shader_compile_option_fragment_coordinate_origin
 /** Advertises feature availability. \since 1.11 */
 enum vkd3d_shader_compile_option_feature_flags
 {
+    /** The SPIR-V target environment supports 64-bit integer types. This
+     * corresponds to the "shaderInt64" feature in the Vulkan API, and the
+     * "GL_ARB_gpu_shader_int64" extension in the OpenGL API. */
     VKD3D_SHADER_COMPILE_OPTION_FEATURE_INT64         = 0x00000001,
+    /** The SPIR-V target environment supports 64-bit floating-point types.
+     * This corresponds to the "shaderFloat64" feature in the Vulkan API, and
+     * the "GL_ARB_gpu_shader_fp64" extension in the OpenGL API. */
     VKD3D_SHADER_COMPILE_OPTION_FEATURE_FLOAT64       = 0x00000002,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_FEATURE_FLAGS),
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index ac688e85e52..26a8a5c1cc3 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -388,6 +388,7 @@ enum dx_intrinsic_opcode
     DX_TEXTURE_STORE                =  67,
     DX_BUFFER_LOAD                  =  68,
     DX_BUFFER_STORE                 =  69,
+    DX_GET_DIMENSIONS               =  72,
     DX_ATOMIC_BINOP                 =  78,
     DX_ATOMIC_CMP_XCHG              =  79,
     DX_DERIV_COARSEX                =  83,
@@ -1937,6 +1938,16 @@ static const struct sm6_type *sm6_parser_get_type(struct sm6_parser *sm6, uint64
     return &sm6->types[type_id];
 }
 
+static bool resource_kind_is_texture(enum dxil_resource_kind kind)
+{
+    return kind >= RESOURCE_KIND_TEXTURE1D && kind <= RESOURCE_KIND_TEXTURECUBEARRAY;
+}
+
+static bool resource_kind_is_multisampled(enum dxil_resource_kind kind)
+{
+    return kind == RESOURCE_KIND_TEXTURE2DMS || kind == RESOURCE_KIND_TEXTURE2DMSARRAY;
+}
+
 static int global_symbol_compare(const void *a, const void *b)
 {
     return vkd3d_u32_compare(((const struct sm6_symbol *)a)->id, ((const struct sm6_symbol *)b)->id);
@@ -2346,6 +2357,23 @@ static void instruction_dst_param_init_ssa_vector(struct vkd3d_shader_instructio
     dst->u.reg = param->reg;
 }
 
+static bool instruction_dst_param_init_temp_vector(struct vkd3d_shader_instruction *ins, struct sm6_parser *sm6)
+{
+    struct sm6_value *dst = sm6_parser_get_current_value(sm6);
+    struct vkd3d_shader_dst_param *param;
+
+    if (!(param = instruction_dst_params_alloc(ins, 1, sm6)))
+        return false;
+
+    vsir_dst_param_init(param, VKD3DSPR_TEMP, vkd3d_data_type_from_sm6_type(sm6_type_get_scalar_type(dst->type, 0)), 1);
+    param->write_mask = VKD3DSP_WRITEMASK_ALL;
+    param->reg.idx[0].offset = 0;
+    param->reg.dimension = VSIR_DIMENSION_VEC4;
+    dst->u.reg = param->reg;
+
+    return true;
+}
+
 /* Recurse through the block tree while maintaining a current value count. The current
  * count is the sum of the global count plus all declarations within the current function.
  * Store into value_capacity the highest count seen. */
@@ -4037,6 +4065,80 @@ static void sm6_parser_emit_dx_create_handle(struct sm6_parser *sm6, enum dx_int
     ins->handler_idx = VKD3DSIH_NOP;
 }
 
+static void sm6_parser_emit_dx_get_dimensions(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+        const struct sm6_value **operands, struct function_emission_state *state)
+{
+    struct vkd3d_shader_instruction *ins = state->ins;
+    struct vkd3d_shader_src_param *src_params;
+    unsigned int is_texture, component_count;
+    enum dxil_resource_kind resource_kind;
+    struct vkd3d_shader_dst_param *dst;
+    const struct sm6_value *resource;
+
+    resource = operands[0];
+    if (!sm6_value_validate_is_handle(resource, sm6))
+        return;
+    is_texture = resource->u.handle.d->resource_type != VKD3D_SHADER_RESOURCE_BUFFER;
+    resource_kind = resource->u.handle.d->kind;
+
+    instruction_init_with_resource(ins, is_texture ? VKD3DSIH_RESINFO : VKD3DSIH_BUFINFO, resource, sm6);
+
+    if (!(src_params = instruction_src_params_alloc(ins, 1 + is_texture, sm6)))
+        return;
+    src_param_init_vector_from_reg(&src_params[is_texture], &resource->u.handle.reg);
+
+    if (is_texture)
+    {
+        ins->flags = VKD3DSI_RESINFO_UINT;
+        src_param_init_from_value(&src_params[0], operands[1]);
+        component_count = VKD3D_VEC4_SIZE;
+
+        if (resource_kind_is_multisampled(resource_kind))
+        {
+            instruction_dst_param_init_temp_vector(ins++, sm6);
+            state->temp_idx = 1;
+
+            /* DXIL does not have an instrinsic for sample info, and resinfo is expected to return
+             * the sample count in .w for MS textures. The result is always a struct of 4 x uint32. */
+            vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_SAMPLE_INFO);
+            ins->flags = VKD3DSI_SAMPLE_INFO_UINT;
+
+            if (!(src_params = instruction_src_params_alloc(ins, 1, sm6)))
+                return;
+            src_param_init_vector_from_reg(&src_params[0], &resource->u.handle.reg);
+            src_params[0].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
+
+            if (!instruction_dst_param_init_temp_vector(ins, sm6))
+                return;
+            dst = ins->dst;
+            dst->write_mask = VKD3DSP_WRITEMASK_3;
+
+            /* Move the result to an SSA in case another instruction overwrites r0 before
+             * the components are extracted for use. */
+            ++ins;
+            vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_MOV);
+            if (!(src_params = instruction_src_params_alloc(ins, 1, sm6)))
+                return;
+            src_param_init_vector_from_reg(&src_params[0], &dst->reg);
+
+            state->ins = ins;
+            state->code_block->instruction_count += 2;
+        }
+    }
+    else
+    {
+        if (!operands[1]->is_undefined)
+        {
+            WARN("Ignoring unexpected operand.\n");
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                    "Ignoring an unexpected defined LOD value for buffer GetDimensions.");
+        }
+        component_count = 1 + (resource_kind == RESOURCE_KIND_STRUCTUREDBUFFER);
+    }
+
+    instruction_dst_param_init_ssa_vector(ins, component_count, sm6);
+}
+
 static enum vkd3d_shader_opcode sm6_dx_map_tertiary_op(enum dx_intrinsic_opcode op)
 {
     switch (op)
@@ -4626,6 +4728,7 @@ struct sm6_dx_opcode_info
     e -> half/float
     g -> half/float/double
     H -> handle
+    D -> Dimensions
     S -> splitdouble
     v -> void
     o -> overloaded
@@ -4656,6 +4759,7 @@ static const struct sm6_dx_opcode_info sm6_dx_op_table[] =
     [DX_FMAX                          ] = {"g", "RR",   sm6_parser_emit_dx_binary},
     [DX_FMIN                          ] = {"g", "RR",   sm6_parser_emit_dx_binary},
     [DX_FRC                           ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_GET_DIMENSIONS                ] = {"D", "Hi",   sm6_parser_emit_dx_get_dimensions},
     [DX_IBFE                          ] = {"m", "iiR",  sm6_parser_emit_dx_tertiary},
     [DX_HCOS                          ] = {"g", "R",    sm6_parser_emit_dx_unary},
     [DX_HSIN                          ] = {"g", "R",    sm6_parser_emit_dx_unary},
@@ -4733,6 +4837,8 @@ static bool sm6_parser_validate_operand_type(struct sm6_parser *sm6, const struc
             return sm6_type_is_floating_point(type);
         case 'H':
             return (is_return || sm6_value_is_handle(value)) && type == sm6->handle_type;
+        case 'D':
+            return sm6_type_is_struct(type) && !strcmp(type->u.struc->name, "dx.types.Dimensions");
         case 'S':
             return sm6_type_is_struct(type) && !strcmp(type->u.struc->name, "dx.types.splitdouble");
         case 'v':
@@ -6778,16 +6884,6 @@ static bool sm6_parser_resources_load_register_range(struct sm6_parser *sm6,
     return true;
 }
 
-static bool resource_kind_is_texture(enum dxil_resource_kind kind)
-{
-    return kind >= RESOURCE_KIND_TEXTURE1D && kind <= RESOURCE_KIND_TEXTURECUBEARRAY;
-}
-
-static bool resource_kind_is_multisampled(enum dxil_resource_kind kind)
-{
-    return kind == RESOURCE_KIND_TEXTURE2DMS || kind == RESOURCE_KIND_TEXTURE2DMSARRAY;
-}
-
 static enum vkd3d_shader_resource_type shader_resource_type_from_dxil_resource_kind(enum dxil_resource_kind kind)
 {
     if (resource_kind_is_texture(kind))
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 0e75edd46f6..538f083df9c 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -3017,7 +3017,7 @@ static void free_ir_resource_load(struct hlsl_ir_resource_load *load)
 
 static void free_ir_resource_store(struct hlsl_ir_resource_store *store)
 {
-    hlsl_src_remove(&store->resource.rel_offset);
+    hlsl_cleanup_deref(&store->resource);
     hlsl_src_remove(&store->coords);
     hlsl_src_remove(&store->value);
     vkd3d_free(store);
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index c6cf1c9519c..3be4e40ab0c 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -164,6 +164,21 @@ STATIC_ASSERT(SM4_MAX_SRC_COUNT <= SPIRV_MAX_SRC_COUNT);
 /* The shift that corresponds to the D3D_SIF_TEXTURE_COMPONENTS mask. */
 #define VKD3D_SM4_SIF_TEXTURE_COMPONENTS_SHIFT 2
 
+#define VKD3D_SM4_REQUIRES_DOUBLES                              0x00000001
+#define VKD3D_SM4_REQUIRES_EARLY_DEPTH_STENCIL                  0x00000002
+#define VKD3D_SM4_REQUIRES_UAVS_AT_EVERY_STAGE                  0x00000004
+#define VKD3D_SM4_REQUIRES_64_UAVS                              0x00000008
+#define VKD3D_SM4_REQUIRES_MINIMUM_PRECISION                    0x00000010
+#define VKD3D_SM4_REQUIRES_11_1_DOUBLE_EXTENSIONS               0x00000020
+#define VKD3D_SM4_REQUIRES_11_1_SHADER_EXTENSIONS               0x00000040
+#define VKD3D_SM4_REQUIRES_LEVEL_9_COMPARISON_FILTERING         0x00000080
+#define VKD3D_SM4_REQUIRES_TILED_RESOURCES                      0x00000100
+#define VKD3D_SM4_REQUIRES_STENCIL_REF                          0x00000200
+#define VKD3D_SM4_REQUIRES_INNER_COVERAGE                       0x00000400
+#define VKD3D_SM4_REQUIRES_TYPED_UAV_LOAD_ADDITIONAL_FORMATS    0x00000800
+#define VKD3D_SM4_REQUIRES_ROVS                                 0x00001000
+#define VKD3D_SM4_REQUIRES_VIEWPORT_AND_RT_ARRAY_INDEX_FROM_ANY_SHADER_FEEDING_RASTERIZER 0x00002000
+
 enum vkd3d_sm4_opcode
 {
     VKD3D_SM4_OP_ADD                              = 0x00,
@@ -5896,6 +5911,31 @@ static void write_sm4_shdr(struct hlsl_ctx *ctx,
     sm4_free_extern_resources(extern_resources, extern_resources_count);
 }
 
+static void write_sm4_sfi0(struct hlsl_ctx *ctx, struct dxbc_writer *dxbc)
+{
+    struct extern_resource *extern_resources;
+    unsigned int extern_resources_count;
+    uint64_t *flags;
+
+    flags = vkd3d_calloc(1, sizeof(*flags));
+
+    extern_resources = sm4_get_extern_resources(ctx, &extern_resources_count);
+    for (unsigned int i = 0; i < extern_resources_count; ++i)
+    {
+        if (extern_resources[i].data_type->e.resource.rasteriser_ordered)
+            *flags |= VKD3D_SM4_REQUIRES_ROVS;
+    }
+    sm4_free_extern_resources(extern_resources, extern_resources_count);
+
+    /* FIXME: We also emit code that should require UAVS_AT_EVERY_STAGE,
+     * STENCIL_REF, and TYPED_UAV_LOAD_ADDITIONAL_FORMATS. */
+
+    if (flags)
+        dxbc_writer_add_section(dxbc, TAG_SFI0, flags, sizeof(*flags));
+    else
+        vkd3d_free(flags);
+}
+
 int hlsl_sm4_write(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func, struct vkd3d_shader_code *out)
 {
     struct dxbc_writer dxbc;
@@ -5908,6 +5948,7 @@ int hlsl_sm4_write(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_fun
     write_sm4_signature(ctx, &dxbc, true);
     write_sm4_rdef(ctx, &dxbc);
     write_sm4_shdr(ctx, entry_func, &dxbc);
+    write_sm4_sfi0(ctx, &dxbc);
 
     if (!(ret = ctx->result))
         ret = dxbc_writer_write(&dxbc, out);
diff --git a/libs/vkd3d/libs/vkd3d/device.c b/libs/vkd3d/libs/vkd3d/device.c
index 0f45b68fc38..17c7ccb3e31 100644
--- a/libs/vkd3d/libs/vkd3d/device.c
+++ b/libs/vkd3d/libs/vkd3d/device.c
@@ -3733,14 +3733,6 @@ static void STDMETHODCALLTYPE d3d12_device_CopyDescriptorsSimple(ID3D12Device7 *
             1, &src_descriptor_range_offset, &descriptor_count, descriptor_heap_type);
 }
 
-static void d3d12_resource_desc1_from_desc(D3D12_RESOURCE_DESC1 *desc1, const D3D12_RESOURCE_DESC *desc)
-{
-    memcpy(desc1, desc, sizeof(*desc));
-    desc1->SamplerFeedbackMipRegion.Width = 0;
-    desc1->SamplerFeedbackMipRegion.Height = 0;
-    desc1->SamplerFeedbackMipRegion.Depth = 0;
-}
-
 static void d3d12_resource_allocation_info1_from_vkd3d(D3D12_RESOURCE_ALLOCATION_INFO1 *result,
         const struct vkd3d_resource_allocation_info *info)
 {
diff --git a/libs/vkd3d/libs/vkd3d/resource.c b/libs/vkd3d/libs/vkd3d/resource.c
index fc05fce14f3..89764d0901d 100644
--- a/libs/vkd3d/libs/vkd3d/resource.c
+++ b/libs/vkd3d/libs/vkd3d/resource.c
@@ -2277,8 +2277,8 @@ HRESULT vkd3d_create_image_resource(ID3D12Device *device,
     object->ID3D12Resource2_iface.lpVtbl = &d3d12_resource_vtbl;
     object->refcount = 1;
     object->internal_refcount = 1;
-    object->desc = create_info->desc;
-    object->format = vkd3d_format_from_d3d12_resource_desc(d3d12_device, &create_info->desc, 0);
+    d3d12_resource_desc1_from_desc(&object->desc, &create_info->desc);
+    object->format = vkd3d_format_from_d3d12_resource_desc(d3d12_device, &object->desc, 0);
     object->u.vk_image = create_info->vk_image;
     object->flags = VKD3D_RESOURCE_EXTERNAL;
     object->flags |= create_info->flags & VKD3D_RESOURCE_PUBLIC_FLAGS;
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
index ed331ccbcc5..b092bb26ded 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
@@ -769,6 +769,14 @@ HRESULT d3d12_reserved_resource_create(struct d3d12_device *device,
         const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource);
 struct d3d12_resource *unsafe_impl_from_ID3D12Resource(ID3D12Resource *iface);
 
+static inline void d3d12_resource_desc1_from_desc(D3D12_RESOURCE_DESC1 *desc1, const D3D12_RESOURCE_DESC *desc)
+{
+    memcpy(desc1, desc, sizeof(*desc));
+    desc1->SamplerFeedbackMipRegion.Width = 0;
+    desc1->SamplerFeedbackMipRegion.Height = 0;
+    desc1->SamplerFeedbackMipRegion.Depth = 0;
+}
+
 HRESULT vkd3d_allocate_buffer_memory(struct d3d12_device *device, VkBuffer vk_buffer,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
         VkDeviceMemory *vk_memory, uint32_t *vk_memory_type, VkDeviceSize *vk_memory_size);
-- 
2.43.0

