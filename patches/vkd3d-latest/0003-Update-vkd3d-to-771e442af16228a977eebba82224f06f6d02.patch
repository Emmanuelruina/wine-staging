From 18393e5d5e96df14252e917403165614e0e77471 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 23 Jun 2023 14:15:46 +1000
Subject: [PATCH] Update vkd3d to 771e442af16228a977eebba82224f06f6d0202fe
 (1.8)

---
 libs/vkd3d/include/vkd3d.h                  |  1 +
 libs/vkd3d/include/vkd3d_shader.h           |  1 +
 libs/vkd3d/libs/vkd3d-shader/d3dbc.c        | 36 +++++++++++++--------
 libs/vkd3d/libs/vkd3d-shader/hlsl.c         |  2 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.h         |  6 ++--
 libs/vkd3d/libs/vkd3d-shader/hlsl.y         | 17 ++++++----
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c | 33 ++++++++++++-------
 libs/vkd3d/libs/vkd3d-shader/ir.c           |  3 +-
 libs/vkd3d/libs/vkd3d-shader/spirv.c        | 16 ++++++---
 libs/vkd3d/libs/vkd3d/state.c               |  4 +--
 10 files changed, 77 insertions(+), 42 deletions(-)

diff --git a/libs/vkd3d/include/vkd3d.h b/libs/vkd3d/include/vkd3d.h
index ff2b15c51dc..72ed3ced671 100644
--- a/libs/vkd3d/include/vkd3d.h
+++ b/libs/vkd3d/include/vkd3d.h
@@ -76,6 +76,7 @@ enum vkd3d_api_version
     VKD3D_API_VERSION_1_5,
     VKD3D_API_VERSION_1_6,
     VKD3D_API_VERSION_1_7,
+    VKD3D_API_VERSION_1_8,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_API_VERSION),
 };
diff --git a/libs/vkd3d/include/vkd3d_shader.h b/libs/vkd3d/include/vkd3d_shader.h
index 859b8c79792..274241546ea 100644
--- a/libs/vkd3d/include/vkd3d_shader.h
+++ b/libs/vkd3d/include/vkd3d_shader.h
@@ -49,6 +49,7 @@ enum vkd3d_shader_api_version
     VKD3D_SHADER_API_VERSION_1_5,
     VKD3D_SHADER_API_VERSION_1_6,
     VKD3D_SHADER_API_VERSION_1_7,
+    VKD3D_SHADER_API_VERSION_1_8,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_API_VERSION),
 };
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
index c35f8ca0ff8..712613ac13b 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -1281,10 +1281,13 @@ static void write_sm1_uniforms(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffe
 
     LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
     {
-        enum hlsl_regset regset = hlsl_type_get_regset(var->data_type);
+        unsigned int r;
 
-        if (!var->semantic.name && var->regs[regset].allocated)
+        for (r = 0; r <= HLSL_REGSET_LAST; ++r)
         {
+            if (var->semantic.name || !var->regs[r].allocated)
+                continue;
+
             ++uniform_count;
 
             if (var->is_param && var->is_uniform)
@@ -1321,20 +1324,23 @@ static void write_sm1_uniforms(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffe
 
     LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
     {
-        enum hlsl_regset regset = hlsl_type_get_regset(var->data_type);
+        unsigned int r;
 
-        if (!var->semantic.name && var->regs[regset].allocated)
+        for (r = 0; r <= HLSL_REGSET_LAST; ++r)
         {
+            if (var->semantic.name || !var->regs[r].allocated)
+                continue;
+
             put_u32(buffer, 0); /* name */
-            if (regset == HLSL_REGSET_NUMERIC)
+            if (r == HLSL_REGSET_NUMERIC)
             {
-                put_u32(buffer, vkd3d_make_u32(D3DXRS_FLOAT4, var->regs[regset].id));
-                put_u32(buffer, var->data_type->reg_size[regset] / 4);
+                put_u32(buffer, vkd3d_make_u32(D3DXRS_FLOAT4, var->regs[r].id));
+                put_u32(buffer, var->data_type->reg_size[r] / 4);
             }
             else
             {
-                put_u32(buffer, vkd3d_make_u32(D3DXRS_SAMPLER, var->regs[regset].id));
-                put_u32(buffer, var->regs[regset].bind_count);
+                put_u32(buffer, vkd3d_make_u32(D3DXRS_SAMPLER, var->regs[r].id));
+                put_u32(buffer, var->regs[r].bind_count);
             }
             put_u32(buffer, 0); /* type */
             put_u32(buffer, 0); /* FIXME: default value */
@@ -1345,12 +1351,16 @@ static void write_sm1_uniforms(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffe
 
     LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
     {
-        enum hlsl_regset regset = hlsl_type_get_regset(var->data_type);
+        unsigned int r;
 
-        if (!var->semantic.name && var->regs[regset].allocated)
+        for (r = 0; r <= HLSL_REGSET_LAST; ++r)
         {
-            size_t var_offset = vars_start + (uniform_count * 5 * sizeof(uint32_t));
-            size_t name_offset;
+            size_t var_offset, name_offset;
+
+            if (var->semantic.name || !var->regs[r].allocated)
+                continue;
+
+            var_offset = vars_start + (uniform_count * 5 * sizeof(uint32_t));
 
             name_offset = put_string(buffer, var->name);
             set_u32(buffer, var_offset, name_offset - ctab_start);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index f439c9f3383..ba5bcfbfaf0 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -3236,7 +3236,7 @@ static bool hlsl_ctx_init(struct hlsl_ctx *ctx, const char *source_name,
 
     rb_init(&ctx->functions, compare_function_rb);
 
-    list_init(&ctx->static_initializers);
+    hlsl_block_init(&ctx->static_initializers);
     list_init(&ctx->extern_vars);
 
     list_init(&ctx->buffers);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index a7ff1f23858..bce48e94b24 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -796,9 +796,8 @@ struct hlsl_ctx
         struct hlsl_type *Void;
     } builtin_types;
 
-    /* List of the instruction nodes for initializing static variables; linked by the
-     *   hlsl_ir_node.entry fields. */
-    struct list static_initializers;
+    /* List of the instruction nodes for initializing static variables. */
+    struct hlsl_block static_initializers;
 
     /* Dynamic array of constant values that appear in the shader, associated to the 'c' registers.
      * Only used for SM1 profiles. */
@@ -1214,6 +1213,7 @@ bool hlsl_offset_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref *deref
 unsigned int hlsl_offset_from_deref_safe(struct hlsl_ctx *ctx, const struct hlsl_deref *deref);
 struct hlsl_reg hlsl_reg_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref *deref);
 
+bool hlsl_copy_propagation_execute(struct hlsl_ctx *ctx, struct hlsl_block *block);
 bool hlsl_fold_constant_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context);
 bool hlsl_fold_constant_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context);
 bool hlsl_transform_ir(struct hlsl_ctx *ctx, bool (*func)(struct hlsl_ctx *ctx, struct hlsl_ir_node *, void *),
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index 209428f761a..0e07fe578e1 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -1098,12 +1098,17 @@ static unsigned int evaluate_static_expression_as_uint(struct hlsl_ctx *ctx, str
     struct hlsl_ir_constant *constant;
     struct hlsl_ir_node *node;
     unsigned int ret = 0;
+    bool progress;
 
     if (!add_implicit_conversion(ctx, &block->instrs, node_from_list(&block->instrs),
             hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT), loc))
         return 0;
 
-    while (hlsl_transform_ir(ctx, hlsl_fold_constant_exprs, block, NULL));
+    do
+    {
+        progress = hlsl_transform_ir(ctx, hlsl_fold_constant_exprs, block, NULL);
+        progress |= hlsl_copy_propagation_execute(ctx, block);
+    } while (progress);
 
     node = node_from_list(&block->instrs);
     if (node->type == HLSL_IR_CONSTANT)
@@ -2159,7 +2164,7 @@ static struct list *declare_vars(struct hlsl_ctx *ctx, struct hlsl_type *basic_t
             }
 
             if (modifiers & HLSL_STORAGE_STATIC)
-                list_move_tail(&ctx->static_initializers, v->initializer.instrs);
+                list_move_tail(&ctx->static_initializers.instrs, v->initializer.instrs);
             else
                 list_move_tail(statements_list, v->initializer.instrs);
             vkd3d_free(v->initializer.args);
@@ -2182,9 +2187,9 @@ static struct list *declare_vars(struct hlsl_ctx *ctx, struct hlsl_type *basic_t
                 vkd3d_free(v);
                 continue;
             }
-            list_add_tail(&ctx->static_initializers, &zero->entry);
+            hlsl_block_add_instr(&ctx->static_initializers, zero);
 
-            if (!(cast = add_cast(ctx, &ctx->static_initializers, zero, var->data_type, &var->loc)))
+            if (!(cast = add_cast(ctx, &ctx->static_initializers.instrs, zero, var->data_type, &var->loc)))
             {
                 vkd3d_free(v);
                 continue;
@@ -2195,7 +2200,7 @@ static struct list *declare_vars(struct hlsl_ctx *ctx, struct hlsl_type *basic_t
                 vkd3d_free(v);
                 continue;
             }
-            list_add_tail(&ctx->static_initializers, &store->entry);
+            hlsl_block_add_instr(&ctx->static_initializers, store);
         }
         vkd3d_free(v);
     }
@@ -5494,7 +5499,7 @@ arrays:
             uint32_t *new_array;
             unsigned int size;
 
-            hlsl_block_init(&block);
+            hlsl_clone_block(ctx, &block, &ctx->static_initializers);
             list_move_tail(&block.instrs, $2);
 
             size = evaluate_static_expression_as_uint(ctx, &block, &@2);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index 4317604bdfa..765b1907426 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -1649,7 +1649,7 @@ static bool copy_propagation_transform_block(struct hlsl_ctx *ctx, struct hlsl_b
     return progress;
 }
 
-static bool copy_propagation_execute(struct hlsl_ctx *ctx, struct hlsl_block *block)
+bool hlsl_copy_propagation_execute(struct hlsl_ctx *ctx, struct hlsl_block *block)
 {
     struct copy_propagation_state state;
     bool progress;
@@ -2698,7 +2698,7 @@ static void allocate_register_reservations(struct hlsl_ctx *ctx)
             continue;
         regset = hlsl_type_get_regset(var->data_type);
 
-        if (var->reg_reservation.reg_type)
+        if (var->reg_reservation.reg_type && var->regs[regset].bind_count)
         {
             if (var->reg_reservation.reg_type != get_regset_name(regset))
             {
@@ -2714,7 +2714,6 @@ static void allocate_register_reservations(struct hlsl_ctx *ctx)
             {
                 var->regs[regset].allocated = true;
                 var->regs[regset].id = var->reg_reservation.reg_index;
-                var->regs[regset].bind_count = var->data_type->reg_size[regset];
                 TRACE("Allocated reserved %s to %c%u-%c%u.\n", var->name, var->reg_reservation.reg_type,
                         var->reg_reservation.reg_index, var->reg_reservation.reg_type,
                         var->reg_reservation.reg_index + var->regs[regset].bind_count);
@@ -3626,11 +3625,23 @@ static const struct hlsl_ir_var *get_allocated_object(struct hlsl_ctx *ctx, enum
 
     LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, const struct hlsl_ir_var, extern_entry)
     {
-        if (!var->regs[regset].allocated)
+        if (var->reg_reservation.reg_type == get_regset_name(regset)
+                && var->data_type->reg_size[regset])
+        {
+            /* Vars with a reservation prevent non-reserved vars from being
+             * bound there even if the reserved vars aren't used. */
+            start = var->reg_reservation.reg_index;
+            count = var->data_type->reg_size[regset];
+        }
+        else if (var->regs[regset].allocated)
+        {
+            start = var->regs[regset].id;
+            count = var->regs[regset].bind_count;
+        }
+        else
+        {
             continue;
-
-        start = var->regs[regset].id;
-        count = var->regs[regset].bind_count;
+        }
 
         if (start <= index && index < start + count)
             return var;
@@ -3977,7 +3988,7 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
     unsigned int i;
     bool progress;
 
-    list_move_head(&body->instrs, &ctx->static_initializers);
+    list_move_head(&body->instrs, &ctx->static_initializers.instrs);
 
     memset(&recursive_call_ctx, 0, sizeof(recursive_call_ctx));
     hlsl_transform_ir(ctx, find_recursive_calls, body, &recursive_call_ctx);
@@ -4073,7 +4084,7 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
     {
         progress = hlsl_transform_ir(ctx, hlsl_fold_constant_exprs, body, NULL);
         progress |= hlsl_transform_ir(ctx, hlsl_fold_constant_swizzles, body, NULL);
-        progress |= copy_propagation_execute(ctx, body);
+        progress |= hlsl_copy_propagation_execute(ctx, body);
         progress |= hlsl_transform_ir(ctx, fold_swizzle_chains, body, NULL);
         progress |= hlsl_transform_ir(ctx, remove_trivial_swizzles, body, NULL);
     }
@@ -4112,10 +4123,10 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
     if (TRACE_ON())
         rb_for_each_entry(&ctx->functions, dump_function, ctx);
 
-    allocate_register_reservations(ctx);
-
     calculate_resource_register_counts(ctx);
 
+    allocate_register_reservations(ctx);
+
     allocate_temp_registers(ctx, entry_func);
     if (profile->major_version < 4)
     {
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index d542fbb0d52..9eefb82c226 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -715,8 +715,7 @@ static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map
         }
     }
     element_count = new_count;
-    /* Signature 's' is a copy of the original signature struct, so we can replace
-     * the 'elements' pointer without freeing it. */
+    vkd3d_free(s->elements);
     s->elements = elements;
     s->element_count = element_count;
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index cc0b63e8284..3542b5fac51 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -201,7 +201,7 @@ enum vkd3d_shader_input_sysval_semantic vkd3d_siv_from_sysval_indexed(enum vkd3d
 
 #define VKD3D_SPIRV_VERSION 0x00010000
 #define VKD3D_SPIRV_GENERATOR_ID 18
-#define VKD3D_SPIRV_GENERATOR_VERSION 7
+#define VKD3D_SPIRV_GENERATOR_VERSION 8
 #define VKD3D_SPIRV_GENERATOR_MAGIC vkd3d_make_u32(VKD3D_SPIRV_GENERATOR_VERSION, VKD3D_SPIRV_GENERATOR_ID)
 
 struct vkd3d_spirv_stream
@@ -2324,11 +2324,15 @@ static void spirv_compiler_destroy(struct spirv_compiler *compiler)
 
     vkd3d_string_buffer_cache_cleanup(&compiler->string_buffers);
 
+    shader_signature_cleanup(&compiler->input_signature);
+    shader_signature_cleanup(&compiler->output_signature);
+    shader_signature_cleanup(&compiler->patch_constant_signature);
+
     vkd3d_free(compiler);
 }
 
 static struct spirv_compiler *spirv_compiler_create(const struct vkd3d_shader_version *shader_version,
-        const struct vkd3d_shader_desc *shader_desc, const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_desc *shader_desc, const struct vkd3d_shader_compile_info *compile_info,
         const struct vkd3d_shader_scan_descriptor_info *scan_descriptor_info,
         struct vkd3d_shader_message_context *message_context, const struct vkd3d_shader_location *location)
 {
@@ -2428,6 +2432,9 @@ static struct spirv_compiler *spirv_compiler_create(const struct vkd3d_shader_ve
     compiler->input_signature = shader_desc->input_signature;
     compiler->output_signature = shader_desc->output_signature;
     compiler->patch_constant_signature = shader_desc->patch_constant_signature;
+    memset(&shader_desc->input_signature, 0, sizeof(shader_desc->input_signature));
+    memset(&shader_desc->output_signature, 0, sizeof(shader_desc->output_signature));
+    memset(&shader_desc->patch_constant_signature, 0, sizeof(shader_desc->patch_constant_signature));
 
     if ((shader_interface = vkd3d_find_struct(compile_info->next, INTERFACE_INFO)))
     {
@@ -4479,7 +4486,8 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     element_idx = shader_register_get_io_indices(reg, array_sizes);
     signature_element = &shader_signature->elements[element_idx];
 
-    if (compiler->shader_type == VKD3D_SHADER_TYPE_HULL && !sysval && signature_element->sysval_semantic)
+    if ((compiler->shader_type == VKD3D_SHADER_TYPE_HULL || compiler->shader_type == VKD3D_SHADER_TYPE_GEOMETRY)
+            && !sysval && signature_element->sysval_semantic)
         sysval = vkd3d_siv_from_sysval(signature_element->sysval_semantic);
 
     builtin = get_spirv_builtin_for_sysval(compiler, sysval);
@@ -9450,7 +9458,7 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
             && (result = instruction_array_flatten_hull_shader_phases(&instructions)) >= 0)
     {
         result = instruction_array_normalise_hull_shader_control_point_io(&instructions,
-                &parser->shader_desc.input_signature);
+                &compiler->input_signature);
     }
     if (result >= 0)
         result = instruction_array_normalise_io_registers(&instructions, parser->shader_version.type,
diff --git a/libs/vkd3d/libs/vkd3d/state.c b/libs/vkd3d/libs/vkd3d/state.c
index c964ea8fe3a..5e46b467252 100644
--- a/libs/vkd3d/libs/vkd3d/state.c
+++ b/libs/vkd3d/libs/vkd3d/state.c
@@ -1958,7 +1958,7 @@ static HRESULT create_shader_stage(struct d3d12_device *device,
 
     const struct vkd3d_shader_compile_option options[] =
     {
-        {VKD3D_SHADER_COMPILE_OPTION_API_VERSION, VKD3D_SHADER_API_VERSION_1_7},
+        {VKD3D_SHADER_COMPILE_OPTION_API_VERSION, VKD3D_SHADER_API_VERSION_1_8},
         {VKD3D_SHADER_COMPILE_OPTION_TYPED_UAV, typed_uav_compile_option(device)},
         {VKD3D_SHADER_COMPILE_OPTION_WRITE_TESS_GEOM_POINT_SIZE, 0},
     };
@@ -2011,7 +2011,7 @@ static int vkd3d_scan_dxbc(const struct d3d12_device *device, const D3D12_SHADER
 
     const struct vkd3d_shader_compile_option options[] =
     {
-        {VKD3D_SHADER_COMPILE_OPTION_API_VERSION, VKD3D_SHADER_API_VERSION_1_7},
+        {VKD3D_SHADER_COMPILE_OPTION_API_VERSION, VKD3D_SHADER_API_VERSION_1_8},
         {VKD3D_SHADER_COMPILE_OPTION_TYPED_UAV, typed_uav_compile_option(device)},
     };
 
-- 
2.40.1

