From f4b33ddbf641e8a3fd68a9abffd6da41c9f432ea Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 16 Feb 2024 13:32:12 +1100
Subject: [PATCH] Updated vkd3d to 4735ff48d17258fa996a9df954dde2893482aefb.

---
 libs/vkd3d/include/private/vkd3d_test.h     |   1 +
 libs/vkd3d/include/vkd3d.h                  |   2 +-
 libs/vkd3d/libs/vkd3d-shader/d3dbc.c        |  82 +++++++++++++
 libs/vkd3d/libs/vkd3d-shader/hlsl.c         |   4 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.h         |  40 +++---
 libs/vkd3d/libs/vkd3d-shader/hlsl.l         |   7 ++
 libs/vkd3d/libs/vkd3d-shader/hlsl.y         | 127 ++++++++++++++------
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c |  34 ++++++
 libs/vkd3d/libs/vkd3d-shader/tpf.c          |   3 +
 libs/vkd3d/libs/vkd3d/command.c             |  14 +--
 libs/vkd3d/libs/vkd3d/device.c              | 107 +++++++++++++----
 libs/vkd3d/libs/vkd3d/resource.c            | 127 +++++++++++---------
 libs/vkd3d/libs/vkd3d/vkd3d_private.h       |  34 +++---
 13 files changed, 418 insertions(+), 164 deletions(-)

diff --git a/libs/vkd3d/include/private/vkd3d_test.h b/libs/vkd3d/include/private/vkd3d_test.h
index a337ac07269..bd6bafa9049 100644
--- a/libs/vkd3d/include/private/vkd3d_test.h
+++ b/libs/vkd3d/include/private/vkd3d_test.h
@@ -277,6 +277,7 @@ int main(int argc, char **argv)
     char *test_platform = getenv("VKD3D_TEST_PLATFORM");
     const char *bug = getenv("VKD3D_TEST_BUG");
 
+    setvbuf(stdout, NULL, _IONBF, 0);
     memset(&vkd3d_test_state, 0, sizeof(vkd3d_test_state));
     vkd3d_test_state.debug_level = debug_level ? atoi(debug_level) : 0;
     vkd3d_test_state.bug_enabled = bug ? atoi(bug) : true;
diff --git a/libs/vkd3d/include/vkd3d.h b/libs/vkd3d/include/vkd3d.h
index 8a8389f02a4..df361f90177 100644
--- a/libs/vkd3d/include/vkd3d.h
+++ b/libs/vkd3d/include/vkd3d.h
@@ -182,7 +182,7 @@ struct vkd3d_image_resource_create_info
     const void *next;
 
     VkImage vk_image;
-    D3D12_RESOURCE_DESC desc;
+    D3D12_RESOURCE_DESC1 desc;
     unsigned int flags;
     D3D12_RESOURCE_STATES present_state;
 };
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
index 9ad9f735dd1..27f5c810436 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -1958,6 +1958,82 @@ static void write_sm1_unary_op(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffe
     write_sm1_instruction(ctx, buffer, &instr);
 }
 
+static void write_sm1_cast(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *buffer,
+        const struct hlsl_ir_node *instr)
+{
+    struct hlsl_ir_expr *expr = hlsl_ir_expr(instr);
+    const struct hlsl_ir_node *arg1 = expr->operands[0].node;
+    const struct hlsl_type *dst_type = expr->node.data_type;
+    const struct hlsl_type *src_type = arg1->data_type;
+
+    /* Narrowing casts were already lowered. */
+    assert(src_type->dimx == dst_type->dimx);
+
+    switch (dst_type->base_type)
+    {
+        case HLSL_TYPE_HALF:
+        case HLSL_TYPE_FLOAT:
+            switch (src_type->base_type)
+            {
+                case HLSL_TYPE_INT:
+                case HLSL_TYPE_UINT:
+                    /* Integers are internally represented as floats, so no change is necessary.*/
+                case HLSL_TYPE_HALF:
+                case HLSL_TYPE_FLOAT:
+                    write_sm1_unary_op(ctx, buffer, D3DSIO_MOV, &instr->reg, &arg1->reg, 0, 0);
+                    break;
+
+                case HLSL_TYPE_BOOL:
+                    hlsl_fixme(ctx, &instr->loc, "SM1 cast from bool to float.");
+                    break;
+
+                case HLSL_TYPE_DOUBLE:
+                    hlsl_fixme(ctx, &instr->loc, "SM1 cast from double to float.");
+                    break;
+
+                default:
+                    vkd3d_unreachable();
+            }
+            break;
+
+        case HLSL_TYPE_INT:
+        case HLSL_TYPE_UINT:
+            switch(src_type->base_type)
+            {
+                case HLSL_TYPE_HALF:
+                case HLSL_TYPE_FLOAT:
+                    /* A compilation pass applies a FLOOR operation to casts to int, so no change is necessary. */
+                case HLSL_TYPE_INT:
+                case HLSL_TYPE_UINT:
+                    write_sm1_unary_op(ctx, buffer, D3DSIO_MOV, &instr->reg, &arg1->reg, 0, 0);
+                    break;
+
+                case HLSL_TYPE_BOOL:
+                    hlsl_fixme(ctx, &instr->loc, "SM1 cast from bool to integer.");
+                    break;
+
+                case HLSL_TYPE_DOUBLE:
+                    hlsl_fixme(ctx, &instr->loc, "SM1 cast from double to integer.");
+                    break;
+
+                default:
+                    vkd3d_unreachable();
+            }
+            break;
+
+        case HLSL_TYPE_DOUBLE:
+            hlsl_fixme(ctx, &instr->loc, "SM1 cast to double.");
+            break;
+
+        case HLSL_TYPE_BOOL:
+            /* Casts to bool should have already been lowered. */
+        default:
+            hlsl_fixme(ctx, &expr->node.loc, "SM1 cast from %s to %s.\n",
+                debug_hlsl_type(ctx, src_type), debug_hlsl_type(ctx, dst_type));
+            break;
+    }
+}
+
 static void write_sm1_constant_defs(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *buffer)
 {
     unsigned int i, x;
@@ -2166,6 +2242,12 @@ static void write_sm1_expr(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *b
 
     assert(instr->reg.allocated);
 
+    if (expr->op == HLSL_OP1_CAST)
+    {
+        write_sm1_cast(ctx, buffer, instr);
+        return;
+    }
+
     if (instr->data_type->base_type != HLSL_TYPE_FLOAT)
     {
         /* These need to be lowered. */
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 04c37498d84..3d068ac6d3b 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -758,7 +758,8 @@ struct hlsl_type *hlsl_new_texture_type(struct hlsl_ctx *ctx, enum hlsl_sampler_
     return type;
 }
 
-struct hlsl_type *hlsl_new_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim, struct hlsl_type *format)
+struct hlsl_type *hlsl_new_uav_type(struct hlsl_ctx *ctx,
+        enum hlsl_sampler_dim dim, struct hlsl_type *format, uint32_t modifiers)
 {
     struct hlsl_type *type;
 
@@ -769,6 +770,7 @@ struct hlsl_type *hlsl_new_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim
     type->dimx = format->dimx;
     type->dimy = 1;
     type->sampler_dim = dim;
+    type->modifiers = modifiers;
     type->e.resource_format = format;
     hlsl_type_calculate_reg_size(ctx, type);
     list_add_tail(&ctx->types, &type->entry);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index 984ac7e4883..974a5dd7aee 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -348,27 +348,28 @@ struct hlsl_attribute
     struct hlsl_src args[];
 };
 
-#define HLSL_STORAGE_EXTERN          0x00000001
-#define HLSL_STORAGE_NOINTERPOLATION 0x00000002
-#define HLSL_MODIFIER_PRECISE        0x00000004
-#define HLSL_STORAGE_SHARED          0x00000008
-#define HLSL_STORAGE_GROUPSHARED     0x00000010
-#define HLSL_STORAGE_STATIC          0x00000020
-#define HLSL_STORAGE_UNIFORM         0x00000040
-#define HLSL_MODIFIER_VOLATILE       0x00000080
-#define HLSL_MODIFIER_CONST          0x00000100
-#define HLSL_MODIFIER_ROW_MAJOR      0x00000200
-#define HLSL_MODIFIER_COLUMN_MAJOR   0x00000400
-#define HLSL_STORAGE_IN              0x00000800
-#define HLSL_STORAGE_OUT             0x00001000
-#define HLSL_MODIFIER_INLINE         0x00002000
-#define HLSL_STORAGE_CENTROID        0x00004000
-#define HLSL_STORAGE_NOPERSPECTIVE   0x00008000
-#define HLSL_STORAGE_LINEAR          0x00010000
+#define HLSL_STORAGE_EXTERN              0x00000001
+#define HLSL_STORAGE_NOINTERPOLATION     0x00000002
+#define HLSL_MODIFIER_PRECISE            0x00000004
+#define HLSL_STORAGE_SHARED              0x00000008
+#define HLSL_STORAGE_GROUPSHARED         0x00000010
+#define HLSL_STORAGE_STATIC              0x00000020
+#define HLSL_STORAGE_UNIFORM             0x00000040
+#define HLSL_MODIFIER_VOLATILE           0x00000080
+#define HLSL_MODIFIER_CONST              0x00000100
+#define HLSL_MODIFIER_ROW_MAJOR          0x00000200
+#define HLSL_MODIFIER_COLUMN_MAJOR       0x00000400
+#define HLSL_STORAGE_IN                  0x00000800
+#define HLSL_STORAGE_OUT                 0x00001000
+#define HLSL_MODIFIER_INLINE             0x00002000
+#define HLSL_STORAGE_CENTROID            0x00004000
+#define HLSL_STORAGE_NOPERSPECTIVE       0x00008000
+#define HLSL_STORAGE_LINEAR              0x00010000
+#define HLSL_MODIFIER_RASTERIZER_ORDERED 0x00020000
 
 #define HLSL_TYPE_MODIFIERS_MASK     (HLSL_MODIFIER_PRECISE | HLSL_MODIFIER_VOLATILE | \
                                       HLSL_MODIFIER_CONST | HLSL_MODIFIER_ROW_MAJOR | \
-                                      HLSL_MODIFIER_COLUMN_MAJOR)
+                                      HLSL_MODIFIER_COLUMN_MAJOR | HLSL_MODIFIER_RASTERIZER_ORDERED)
 
 #define HLSL_INTERPOLATION_MODIFIERS_MASK (HLSL_STORAGE_NOINTERPOLATION | HLSL_STORAGE_CENTROID | \
                                            HLSL_STORAGE_NOPERSPECTIVE | HLSL_STORAGE_LINEAR)
@@ -1270,7 +1271,8 @@ struct hlsl_ir_var *hlsl_new_synthetic_var_named(struct hlsl_ctx *ctx, const cha
     struct hlsl_type *type, const struct vkd3d_shader_location *loc, bool dummy_scope);
 struct hlsl_type *hlsl_new_texture_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim, struct hlsl_type *format,
         unsigned int sample_count);
-struct hlsl_type *hlsl_new_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim, struct hlsl_type *format);
+struct hlsl_type *hlsl_new_uav_type(struct hlsl_ctx *ctx,
+        enum hlsl_sampler_dim dim, struct hlsl_type *format, uint32_t modifiers);
 struct hlsl_ir_node *hlsl_new_uint_constant(struct hlsl_ctx *ctx, unsigned int n,
         const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_unary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op, struct hlsl_ir_node *arg,
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.l b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
index 6cef0e02eff..558506db108 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.l
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
@@ -106,6 +106,13 @@ packoffset              {return KW_PACKOFFSET;          }
 pass                    {return KW_PASS;                }
 PixelShader             {return KW_PIXELSHADER;         }
 precise                 {return KW_PRECISE;             }
+RasterizerOrderedBuffer           {return KW_RASTERIZERORDEREDBUFFER;            }
+RasterizerOrderedStructuredBuffer {return KW_RASTERIZERORDEREDSTRUCTUREDBUFFER;  }
+RasterizerOrderedTexture1D        {return KW_RASTERIZERORDEREDTEXTURE1D;         }
+RasterizerOrderedTexture1DArray   {return KW_RASTERIZERORDEREDTEXTURE1DARRAY;    }
+RasterizerOrderedTexture2D        {return KW_RASTERIZERORDEREDTEXTURE2D;         }
+RasterizerOrderedTexture2DArray   {return KW_RASTERIZERORDEREDTEXTURE2DARRAY;    }
+RasterizerOrderedTexture3D        {return KW_RASTERIZERORDEREDTEXTURE3D;         }
 RasterizerState         {return KW_RASTERIZERSTATE;     }
 register                {return KW_REGISTER;            }
 RenderTargetView        {return KW_RENDERTARGETVIEW;    }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index 5f6334a4d19..37a372893df 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -5005,6 +5005,48 @@ static void check_duplicated_switch_cases(struct hlsl_ctx *ctx, const struct hls
     }
 }
 
+static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
+        struct hlsl_type *format, const struct vkd3d_shader_location* loc)
+{
+    struct vkd3d_string_buffer *string = hlsl_type_to_string(ctx, format);
+
+    if (!type_contains_only_numerics(format))
+    {
+        if (string)
+            hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                    "UAV type %s is not numeric.", string->buffer);
+    }
+
+    switch (dim)
+    {
+        case HLSL_SAMPLER_DIM_BUFFER:
+        case HLSL_SAMPLER_DIM_1D:
+        case HLSL_SAMPLER_DIM_1DARRAY:
+        case HLSL_SAMPLER_DIM_2D:
+        case HLSL_SAMPLER_DIM_2DARRAY:
+        case HLSL_SAMPLER_DIM_3D:
+            if (format->class == HLSL_CLASS_ARRAY)
+            {
+                if (string)
+                    hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                            "This type of UAV does not support array type.");
+            }
+            else if (hlsl_type_component_count(format) > 4)
+            {
+                if (string)
+                    hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                            "UAV data type %s size exceeds maximum size.", string->buffer);
+            }
+            break;
+        case HLSL_SAMPLER_DIM_STRUCTURED_BUFFER:
+            break;
+        default:
+            vkd3d_unreachable();
+    }
+
+    hlsl_release_string_buffer(ctx, string);
+}
+
 }
 
 %locations
@@ -5084,6 +5126,13 @@ static void check_duplicated_switch_cases(struct hlsl_ctx *ctx, const struct hls
 %token KW_PASS
 %token KW_PIXELSHADER
 %token KW_PRECISE
+%token KW_RASTERIZERORDEREDBUFFER
+%token KW_RASTERIZERORDEREDSTRUCTUREDBUFFER
+%token KW_RASTERIZERORDEREDTEXTURE1D
+%token KW_RASTERIZERORDEREDTEXTURE1DARRAY
+%token KW_RASTERIZERORDEREDTEXTURE2D
+%token KW_RASTERIZERORDEREDTEXTURE2DARRAY
+%token KW_RASTERIZERORDEREDTEXTURE3D
 %token KW_RASTERIZERSTATE
 %token KW_RENDERTARGETVIEW
 %token KW_RETURN
@@ -5244,7 +5293,7 @@ static void check_duplicated_switch_cases(struct hlsl_ctx *ctx, const struct hls
 %type <reg_reservation> register_opt
 %type <reg_reservation> packoffset_opt
 
-%type <sampler_dim> texture_type texture_ms_type uav_type
+%type <sampler_dim> texture_type texture_ms_type uav_type rov_type
 
 %type <semantic> semantic
 
@@ -6057,6 +6106,36 @@ uav_type:
             $$ = HLSL_SAMPLER_DIM_3D;
         }
 
+rov_type:
+      KW_RASTERIZERORDEREDBUFFER
+        {
+            $$ = HLSL_SAMPLER_DIM_BUFFER;
+        }
+    | KW_RASTERIZERORDEREDSTRUCTUREDBUFFER
+        {
+            $$ = HLSL_SAMPLER_DIM_STRUCTURED_BUFFER;
+        }
+    | KW_RASTERIZERORDEREDTEXTURE1D
+        {
+            $$ = HLSL_SAMPLER_DIM_1D;
+        }
+    | KW_RASTERIZERORDEREDTEXTURE1DARRAY
+        {
+            $$ = HLSL_SAMPLER_DIM_1DARRAY;
+        }
+    | KW_RASTERIZERORDEREDTEXTURE2D
+        {
+            $$ = HLSL_SAMPLER_DIM_2D;
+        }
+    | KW_RASTERIZERORDEREDTEXTURE2DARRAY
+        {
+            $$ = HLSL_SAMPLER_DIM_2DARRAY;
+        }
+    | KW_RASTERIZERORDEREDTEXTURE3D
+        {
+            $$ = HLSL_SAMPLER_DIM_3D;
+        }
+
 type_no_void:
       KW_VECTOR '<' type ',' C_INTEGER '>'
         {
@@ -6185,45 +6264,13 @@ type_no_void:
         }
     | uav_type '<' type '>'
         {
-            struct vkd3d_string_buffer *string = hlsl_type_to_string(ctx, $3);
-
-            if (!type_contains_only_numerics($3))
-            {
-                if (string)
-                    hlsl_error(ctx, &@3, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
-                            "UAV type %s is not numeric.", string->buffer);
-            }
-
-            switch ($1)
-            {
-                case HLSL_SAMPLER_DIM_BUFFER:
-                case HLSL_SAMPLER_DIM_1D:
-                case HLSL_SAMPLER_DIM_1DARRAY:
-                case HLSL_SAMPLER_DIM_2D:
-                case HLSL_SAMPLER_DIM_2DARRAY:
-                case HLSL_SAMPLER_DIM_3D:
-                    if ($3->class == HLSL_CLASS_ARRAY)
-                    {
-                        if (string)
-                            hlsl_error(ctx, &@3, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
-                                    "This type of UAV does not support array type.");
-                    }
-                    else if (hlsl_type_component_count($3) > 4)
-                    {
-                        if (string)
-                            hlsl_error(ctx, &@3, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
-                                    "UAV data type %s size exceeds maximum size.", string->buffer);
-                    }
-                    break;
-                case HLSL_SAMPLER_DIM_STRUCTURED_BUFFER:
-                    break;
-                default:
-                    vkd3d_unreachable();
-            }
-
-            hlsl_release_string_buffer(ctx, string);
-
-            $$ = hlsl_new_uav_type(ctx, $1, $3);
+            validate_uav_type(ctx, $1, $3, &@3);
+            $$ = hlsl_new_uav_type(ctx, $1, $3, 0);
+        }
+    | rov_type '<' type '>'
+        {
+            validate_uav_type(ctx, $1, $3, &@3);
+            $$ = hlsl_new_uav_type(ctx, $1, $3, HLSL_MODIFIER_RASTERIZER_ORDERED);
         }
     | TYPE_IDENTIFIER
         {
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index 6ad60e4c6c2..4121fadf333 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -2647,6 +2647,39 @@ static bool sort_synthetic_separated_samplers_first(struct hlsl_ctx *ctx)
     return false;
 }
 
+/* Append a FLOOR before a CAST to int or uint (which is written as a mere MOV). */
+static bool lower_casts_to_int(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
+{
+    struct hlsl_ir_node *arg, *floor, *cast2;
+    struct hlsl_ir_expr *expr;
+
+    if (instr->type != HLSL_IR_EXPR)
+        return false;
+    expr = hlsl_ir_expr(instr);
+    if (expr->op != HLSL_OP1_CAST)
+        return false;
+
+    arg = expr->operands[0].node;
+    if (instr->data_type->base_type != HLSL_TYPE_INT && instr->data_type->base_type != HLSL_TYPE_UINT)
+        return false;
+    if (arg->data_type->base_type != HLSL_TYPE_FLOAT && arg->data_type->base_type != HLSL_TYPE_HALF)
+        return false;
+
+    /* Check that the argument is not already a FLOOR */
+    if (arg->type == HLSL_IR_EXPR && hlsl_ir_expr(arg)->op == HLSL_OP1_FLOOR)
+        return false;
+
+    if (!(floor = hlsl_new_unary_expr(ctx, HLSL_OP1_FLOOR, arg, &instr->loc)))
+        return false;
+    hlsl_block_add_instr(block, floor);
+
+    if (!(cast2 = hlsl_new_cast(ctx, floor, instr->data_type, &instr->loc)))
+        return false;
+    hlsl_block_add_instr(block, cast2);
+
+    return true;
+}
+
 /* Lower DIV to RCP + MUL. */
 static bool lower_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
@@ -5060,6 +5093,7 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
     lower_ir(ctx, lower_ternary, body);
     if (profile->major_version < 4)
     {
+        lower_ir(ctx, lower_casts_to_int, body);
         lower_ir(ctx, lower_division, body);
         lower_ir(ctx, lower_sqrt, body);
         lower_ir(ctx, lower_dot, body);
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index adfddd32036..f70606e6f22 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -4271,6 +4271,9 @@ static void write_sm4_dcl_textures(const struct tpf_writer *tpf, const struct ex
             instr.extra_bits |= component_type->sample_count << VKD3D_SM4_RESOURCE_SAMPLE_COUNT_SHIFT;
         }
 
+        if (resource->data_type->modifiers & HLSL_MODIFIER_RASTERIZER_ORDERED)
+            instr.opcode |= VKD3DSUF_RASTERISER_ORDERED_VIEW << VKD3D_SM5_UAV_FLAGS_SHIFT;
+
         write_sm4_instruction(tpf, &instr);
     }
 }
diff --git a/libs/vkd3d/libs/vkd3d/command.c b/libs/vkd3d/libs/vkd3d/command.c
index 8a47dc494f7..7115a74a6f2 100644
--- a/libs/vkd3d/libs/vkd3d/command.c
+++ b/libs/vkd3d/libs/vkd3d/command.c
@@ -3508,7 +3508,7 @@ static void vk_image_subresource_layers_from_d3d12(VkImageSubresourceLayers *sub
 }
 
 static void vk_extent_3d_from_d3d12_miplevel(VkExtent3D *extent,
-        const D3D12_RESOURCE_DESC *resource_desc, unsigned int miplevel_idx)
+        const D3D12_RESOURCE_DESC1 *resource_desc, unsigned int miplevel_idx)
 {
     extent->width = d3d12_resource_desc_get_width(resource_desc, miplevel_idx);
     extent->height = d3d12_resource_desc_get_height(resource_desc, miplevel_idx);
@@ -3517,7 +3517,7 @@ static void vk_extent_3d_from_d3d12_miplevel(VkExtent3D *extent,
 
 static void vk_buffer_image_copy_from_d3d12(VkBufferImageCopy *copy,
         const D3D12_PLACED_SUBRESOURCE_FOOTPRINT *footprint, unsigned int sub_resource_idx,
-        const D3D12_RESOURCE_DESC *image_desc, const struct vkd3d_format *format,
+        const D3D12_RESOURCE_DESC1 *image_desc, const struct vkd3d_format *format,
         const D3D12_BOX *src_box, unsigned int dst_x, unsigned int dst_y, unsigned int dst_z)
 {
     copy->bufferOffset = footprint->Offset;
@@ -3558,7 +3558,7 @@ static void vk_buffer_image_copy_from_d3d12(VkBufferImageCopy *copy,
 
 static void vk_image_buffer_copy_from_d3d12(VkBufferImageCopy *copy,
         const D3D12_PLACED_SUBRESOURCE_FOOTPRINT *footprint, unsigned int sub_resource_idx,
-        const D3D12_RESOURCE_DESC *image_desc, const struct vkd3d_format *format,
+        const D3D12_RESOURCE_DESC1 *image_desc, const struct vkd3d_format *format,
         const D3D12_BOX *src_box, unsigned int dst_x, unsigned int dst_y, unsigned int dst_z)
 {
     VkDeviceSize row_count = footprint->Footprint.Height / format->block_height;
@@ -3588,7 +3588,7 @@ static void vk_image_buffer_copy_from_d3d12(VkBufferImageCopy *copy,
 
 static void vk_image_copy_from_d3d12(VkImageCopy *image_copy,
         unsigned int src_sub_resource_idx, unsigned int dst_sub_resource_idx,
-        const D3D12_RESOURCE_DESC *src_desc, const D3D12_RESOURCE_DESC *dst_desc,
+        const D3D12_RESOURCE_DESC1 *src_desc, const D3D12_RESOURCE_DESC1 *dst_desc,
         const struct vkd3d_format *src_format, const struct vkd3d_format *dst_format,
         const D3D12_BOX *src_box, unsigned int dst_x, unsigned int dst_y, unsigned int dst_z)
 {
@@ -3621,7 +3621,7 @@ static HRESULT d3d12_command_list_allocate_transfer_buffer(struct d3d12_command_
     const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
     struct d3d12_device *device = list->device;
     D3D12_HEAP_PROPERTIES heap_properties;
-    D3D12_RESOURCE_DESC buffer_desc;
+    D3D12_RESOURCE_DESC1 buffer_desc;
     HRESULT hr;
 
     memset(&heap_properties, 0, sizeof(heap_properties));
@@ -3671,8 +3671,8 @@ static void d3d12_command_list_copy_incompatible_texture_region(struct d3d12_com
         unsigned int src_sub_resource_idx, const struct vkd3d_format *src_format, unsigned int layer_count)
 {
     const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
-    const D3D12_RESOURCE_DESC *dst_desc = &dst_resource->desc;
-    const D3D12_RESOURCE_DESC *src_desc = &src_resource->desc;
+    const D3D12_RESOURCE_DESC1 *dst_desc = &dst_resource->desc;
+    const D3D12_RESOURCE_DESC1 *src_desc = &src_resource->desc;
     unsigned int dst_miplevel_idx, src_miplevel_idx;
     struct vkd3d_buffer transfer_buffer;
     VkBufferImageCopy buffer_image_copy;
diff --git a/libs/vkd3d/libs/vkd3d/device.c b/libs/vkd3d/libs/vkd3d/device.c
index f5a57ad31b7..01818458e97 100644
--- a/libs/vkd3d/libs/vkd3d/device.c
+++ b/libs/vkd3d/libs/vkd3d/device.c
@@ -1970,7 +1970,7 @@ static HRESULT vkd3d_select_queues(const struct vkd3d_instance *vkd3d_instance,
 static bool d3d12_is_64k_msaa_supported(struct d3d12_device *device)
 {
     struct vkd3d_resource_allocation_info info;
-    D3D12_RESOURCE_DESC resource_desc;
+    D3D12_RESOURCE_DESC1 resource_desc;
 
     memset(&resource_desc, 0, sizeof(resource_desc));
     resource_desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
@@ -3732,6 +3732,14 @@ static void STDMETHODCALLTYPE d3d12_device_CopyDescriptorsSimple(ID3D12Device7 *
             1, &src_descriptor_range_offset, &descriptor_count, descriptor_heap_type);
 }
 
+static void d3d12_resource_desc1_from_desc(D3D12_RESOURCE_DESC1 *desc1, const D3D12_RESOURCE_DESC *desc)
+{
+    memcpy(desc1, desc, sizeof(*desc));
+    desc1->SamplerFeedbackMipRegion.Width = 0;
+    desc1->SamplerFeedbackMipRegion.Height = 0;
+    desc1->SamplerFeedbackMipRegion.Depth = 0;
+}
+
 static void d3d12_resource_allocation_info1_from_vkd3d(D3D12_RESOURCE_ALLOCATION_INFO1 *result,
         const struct vkd3d_resource_allocation_info *info)
 {
@@ -3740,12 +3748,12 @@ static void d3d12_resource_allocation_info1_from_vkd3d(D3D12_RESOURCE_ALLOCATION
     result->SizeInBytes = info->size_in_bytes;
 }
 
-static void d3d12_device_get_resource_allocation_info(struct d3d12_device *device,
-        D3D12_RESOURCE_ALLOCATION_INFO1 *infos1, unsigned int count, const D3D12_RESOURCE_DESC *resource_descs,
+static void d3d12_device_get_resource1_allocation_info(struct d3d12_device *device,
+        D3D12_RESOURCE_ALLOCATION_INFO1 *infos1, unsigned int count, const D3D12_RESOURCE_DESC1 *resource_descs,
         D3D12_RESOURCE_ALLOCATION_INFO *result)
 {
     struct vkd3d_resource_allocation_info info;
-    const D3D12_RESOURCE_DESC *desc;
+    const D3D12_RESOURCE_DESC1 *desc;
     uint64_t requested_alignment;
     unsigned int i;
 
@@ -3818,6 +3826,36 @@ invalid:
     TRACE("Alignment %#"PRIx64".\n", result->Alignment);
 }
 
+static void d3d12_device_get_resource_allocation_info(struct d3d12_device *device,
+        D3D12_RESOURCE_ALLOCATION_INFO1 *infos1, unsigned int count, const D3D12_RESOURCE_DESC *resource_descs,
+        D3D12_RESOURCE_ALLOCATION_INFO *result)
+{
+    /* Avoid spurious compiler warning for uninitialized use. */
+    D3D12_RESOURCE_DESC1 resource_descs1[4] = {0};
+    D3D12_RESOURCE_DESC1 *descs1;
+    unsigned int i;
+
+    if (count <= ARRAY_SIZE(resource_descs1))
+    {
+        descs1 = resource_descs1;
+    }
+    else if (!(descs1 = vkd3d_calloc(count, sizeof(*descs1))))
+    {
+        ERR("Failed to allocate %u resource descriptions.\n", count);
+        result->SizeInBytes = UINT64_MAX;
+        result->Alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
+        return;
+    }
+
+    for (i = 0; i < count; ++i)
+        d3d12_resource_desc1_from_desc(&descs1[i], &resource_descs[i]);
+
+    d3d12_device_get_resource1_allocation_info(device, infos1, count, descs1, result);
+
+    if (descs1 != resource_descs1)
+        vkd3d_free(descs1);
+}
+
 static D3D12_RESOURCE_ALLOCATION_INFO * STDMETHODCALLTYPE d3d12_device_GetResourceAllocationInfo(
         ID3D12Device7 *iface, D3D12_RESOURCE_ALLOCATION_INFO *info, UINT visible_mask,
         UINT count, const D3D12_RESOURCE_DESC *resource_descs)
@@ -3883,6 +3921,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommittedResource(ID3D12Devi
         const D3D12_CLEAR_VALUE *optimized_clear_value, REFIID iid, void **resource)
 {
     struct d3d12_device *device = impl_from_ID3D12Device7(iface);
+    D3D12_RESOURCE_DESC1 resource_desc;
     struct d3d12_resource *object;
     HRESULT hr;
 
@@ -3891,14 +3930,16 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommittedResource(ID3D12Devi
             iface, heap_properties, heap_flags, desc, initial_state,
             optimized_clear_value, debugstr_guid(iid), resource);
 
+    d3d12_resource_desc1_from_desc(&resource_desc, desc);
+
     if (FAILED(hr = d3d12_committed_resource_create(device, heap_properties, heap_flags,
-            desc, initial_state, optimized_clear_value, NULL, &object)))
+            &resource_desc, initial_state, optimized_clear_value, NULL, &object)))
     {
         *resource = NULL;
         return hr;
     }
 
-    return return_interface(&object->ID3D12Resource1_iface, &IID_ID3D12Resource1, iid, resource);
+    return return_interface(&object->ID3D12Resource2_iface, &IID_ID3D12Resource2, iid, resource);
 }
 
 static HRESULT STDMETHODCALLTYPE d3d12_device_CreateHeap(ID3D12Device7 *iface,
@@ -3926,6 +3967,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreatePlacedResource(ID3D12Device7
         const D3D12_CLEAR_VALUE *optimized_clear_value, REFIID iid, void **resource)
 {
     struct d3d12_device *device = impl_from_ID3D12Device7(iface);
+    D3D12_RESOURCE_DESC1 resource_desc;
     struct d3d12_heap *heap_object;
     struct d3d12_resource *object;
     HRESULT hr;
@@ -3936,12 +3978,13 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreatePlacedResource(ID3D12Device7
             optimized_clear_value, debugstr_guid(iid), resource);
 
     heap_object = unsafe_impl_from_ID3D12Heap(heap);
+    d3d12_resource_desc1_from_desc(&resource_desc, desc);
 
     if (FAILED(hr = d3d12_placed_resource_create(device, heap_object, heap_offset,
-            desc, initial_state, optimized_clear_value, &object)))
+            &resource_desc, initial_state, optimized_clear_value, &object)))
         return hr;
 
-    return return_interface(&object->ID3D12Resource1_iface, &IID_ID3D12Resource1, iid, resource);
+    return return_interface(&object->ID3D12Resource2_iface, &IID_ID3D12Resource2, iid, resource);
 }
 
 static HRESULT STDMETHODCALLTYPE d3d12_device_CreateReservedResource(ID3D12Device7 *iface,
@@ -3949,17 +3992,20 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateReservedResource(ID3D12Devic
         const D3D12_CLEAR_VALUE *optimized_clear_value, REFIID iid, void **resource)
 {
     struct d3d12_device *device = impl_from_ID3D12Device7(iface);
+    D3D12_RESOURCE_DESC1 resource_desc;
     struct d3d12_resource *object;
     HRESULT hr;
 
     TRACE("iface %p, desc %p, initial_state %#x, optimized_clear_value %p, iid %s, resource %p.\n",
             iface, desc, initial_state, optimized_clear_value, debugstr_guid(iid), resource);
 
+    d3d12_resource_desc1_from_desc(&resource_desc, desc);
+
     if (FAILED(hr = d3d12_reserved_resource_create(device,
-            desc, initial_state, optimized_clear_value, &object)))
+            &resource_desc, initial_state, optimized_clear_value, &object)))
         return hr;
 
-    return return_interface(&object->ID3D12Resource1_iface, &IID_ID3D12Resource1, iid, resource);
+    return return_interface(&object->ID3D12Resource2_iface, &IID_ID3D12Resource2, iid, resource);
 }
 
 static HRESULT STDMETHODCALLTYPE d3d12_device_CreateSharedHandle(ID3D12Device7 *iface,
@@ -4046,23 +4092,16 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_GetDeviceRemovedReason(ID3D12Devic
     return device->removed_reason;
 }
 
-static void STDMETHODCALLTYPE d3d12_device_GetCopyableFootprints(ID3D12Device7 *iface,
-        const D3D12_RESOURCE_DESC *desc, UINT first_sub_resource, UINT sub_resource_count,
-        UINT64 base_offset, D3D12_PLACED_SUBRESOURCE_FOOTPRINT *layouts,
-        UINT *row_counts, UINT64 *row_sizes, UINT64 *total_bytes)
+static void d3d12_device_get_copyable_footprints(struct d3d12_device *device,
+        const D3D12_RESOURCE_DESC1 *desc, unsigned int first_sub_resource, unsigned int sub_resource_count,
+        uint64_t base_offset, D3D12_PLACED_SUBRESOURCE_FOOTPRINT *layouts, UINT *row_counts,
+        UINT64 *row_sizes, UINT64 *total_bytes)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device7(iface);
-
     unsigned int i, sub_resource_idx, miplevel_idx, row_count, row_size, row_pitch;
     unsigned int width, height, depth, plane_count, sub_resources_per_plane;
     const struct vkd3d_format *format;
     uint64_t offset, size, total;
 
-    TRACE("iface %p, desc %p, first_sub_resource %u, sub_resource_count %u, base_offset %#"PRIx64", "
-            "layouts %p, row_counts %p, row_sizes %p, total_bytes %p.\n",
-            iface, desc, first_sub_resource, sub_resource_count, base_offset,
-            layouts, row_counts, row_sizes, total_bytes);
-
     if (layouts)
         memset(layouts, 0xff, sizeof(*layouts) * sub_resource_count);
     if (row_counts)
@@ -4131,6 +4170,25 @@ static void STDMETHODCALLTYPE d3d12_device_GetCopyableFootprints(ID3D12Device7 *
         *total_bytes = total;
 }
 
+static void STDMETHODCALLTYPE d3d12_device_GetCopyableFootprints(ID3D12Device7 *iface,
+        const D3D12_RESOURCE_DESC *desc, UINT first_sub_resource, UINT sub_resource_count,
+        UINT64 base_offset, D3D12_PLACED_SUBRESOURCE_FOOTPRINT *layouts,
+        UINT *row_counts, UINT64 *row_sizes, UINT64 *total_bytes)
+{
+    struct d3d12_device *device = impl_from_ID3D12Device7(iface);
+    D3D12_RESOURCE_DESC1 resource_desc;
+
+    TRACE("iface %p, desc %p, first_sub_resource %u, sub_resource_count %u, base_offset %#"PRIx64", "
+            "layouts %p, row_counts %p, row_sizes %p, total_bytes %p.\n",
+            iface, desc, first_sub_resource, sub_resource_count, base_offset,
+            layouts, row_counts, row_sizes, total_bytes);
+
+    d3d12_resource_desc1_from_desc(&resource_desc, desc);
+
+    d3d12_device_get_copyable_footprints(device, &resource_desc, first_sub_resource, sub_resource_count,
+            base_offset, layouts, row_counts, row_sizes, total_bytes);
+}
+
 static HRESULT STDMETHODCALLTYPE d3d12_device_CreateQueryHeap(ID3D12Device7 *iface,
         const D3D12_QUERY_HEAP_DESC *desc, REFIID iid, void **heap)
 {
@@ -4297,6 +4355,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommittedResource1(ID3D12Dev
         ID3D12ProtectedResourceSession *protected_session, REFIID iid, void **resource)
 {
     struct d3d12_device *device = impl_from_ID3D12Device7(iface);
+    D3D12_RESOURCE_DESC1 resource_desc;
     struct d3d12_resource *object;
     HRESULT hr;
 
@@ -4305,14 +4364,16 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommittedResource1(ID3D12Dev
             iface, heap_properties, heap_flags, desc, initial_state,
             optimized_clear_value, protected_session, debugstr_guid(iid), resource);
 
+    d3d12_resource_desc1_from_desc(&resource_desc, desc);
+
     if (FAILED(hr = d3d12_committed_resource_create(device, heap_properties, heap_flags,
-            desc, initial_state, optimized_clear_value, protected_session, &object)))
+            &resource_desc, initial_state, optimized_clear_value, protected_session, &object)))
     {
         *resource = NULL;
         return hr;
     }
 
-    return return_interface(&object->ID3D12Resource1_iface, &IID_ID3D12Resource1, iid, resource);
+    return return_interface(&object->ID3D12Resource2_iface, &IID_ID3D12Resource2, iid, resource);
 }
 
 static HRESULT STDMETHODCALLTYPE d3d12_device_CreateHeap1(ID3D12Device7 *iface,
diff --git a/libs/vkd3d/libs/vkd3d/resource.c b/libs/vkd3d/libs/vkd3d/resource.c
index 8f4d18358d2..fc05fce14f3 100644
--- a/libs/vkd3d/libs/vkd3d/resource.c
+++ b/libs/vkd3d/libs/vkd3d/resource.c
@@ -651,7 +651,7 @@ VkSampleCountFlagBits vk_samples_from_dxgi_sample_desc(const DXGI_SAMPLE_DESC *d
 
 HRESULT vkd3d_create_buffer(struct d3d12_device *device,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
-        const D3D12_RESOURCE_DESC *desc, VkBuffer *vk_buffer)
+        const D3D12_RESOURCE_DESC1 *desc, VkBuffer *vk_buffer)
 {
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     const bool sparse_resource = !heap_properties;
@@ -731,7 +731,7 @@ HRESULT vkd3d_create_buffer(struct d3d12_device *device,
     return hresult_from_vk_result(vr);
 }
 
-static unsigned int max_miplevel_count(const D3D12_RESOURCE_DESC *desc)
+static unsigned int max_miplevel_count(const D3D12_RESOURCE_DESC1 *desc)
 {
     unsigned int size = max(desc->Width, desc->Height);
     size = max(size, d3d12_resource_desc_get_depth(desc, 0));
@@ -775,7 +775,7 @@ static bool vkd3d_is_linear_tiling_supported(const struct d3d12_device *device,
 
 static HRESULT vkd3d_create_image(struct d3d12_device *device,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
-        const D3D12_RESOURCE_DESC *desc, struct d3d12_resource *resource, VkImage *vk_image)
+        const D3D12_RESOURCE_DESC1 *desc, struct d3d12_resource *resource, VkImage *vk_image)
 {
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     const struct vkd3d_format_compatibility_list *compat_list;
@@ -940,11 +940,11 @@ static HRESULT vkd3d_create_image(struct d3d12_device *device,
 }
 
 HRESULT vkd3d_get_image_allocation_info(struct d3d12_device *device,
-        const D3D12_RESOURCE_DESC *desc, struct vkd3d_resource_allocation_info *allocation_info)
+        const D3D12_RESOURCE_DESC1 *desc, struct vkd3d_resource_allocation_info *allocation_info)
 {
     static const D3D12_HEAP_PROPERTIES heap_properties = {D3D12_HEAP_TYPE_DEFAULT};
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
-    D3D12_RESOURCE_DESC validated_desc;
+    D3D12_RESOURCE_DESC1 validated_desc;
     VkMemoryRequirements requirements;
     VkImage vk_image;
     bool tiled;
@@ -1069,7 +1069,7 @@ static void d3d12_resource_get_level_box(const struct d3d12_resource *resource,
 }
 
 static void compute_image_subresource_size_in_tiles(const VkExtent3D *tile_extent,
-        const struct D3D12_RESOURCE_DESC *desc, unsigned int miplevel_idx,
+        const struct D3D12_RESOURCE_DESC1 *desc, unsigned int miplevel_idx,
         struct vkd3d_tiled_region_extent *size)
 {
     unsigned int width, height, depth;
@@ -1258,12 +1258,13 @@ static bool d3d12_resource_init_tiles(struct d3d12_resource *resource, struct d3
 }
 
 /* ID3D12Resource */
-static HRESULT STDMETHODCALLTYPE d3d12_resource_QueryInterface(ID3D12Resource1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_QueryInterface(ID3D12Resource2 *iface,
         REFIID riid, void **object)
 {
     TRACE("iface %p, riid %s, object %p.\n", iface, debugstr_guid(riid), object);
 
-    if (IsEqualGUID(riid, &IID_ID3D12Resource1)
+    if (IsEqualGUID(riid, &IID_ID3D12Resource2)
+            || IsEqualGUID(riid, &IID_ID3D12Resource1)
             || IsEqualGUID(riid, &IID_ID3D12Resource)
             || IsEqualGUID(riid, &IID_ID3D12Pageable)
             || IsEqualGUID(riid, &IID_ID3D12DeviceChild)
@@ -1281,9 +1282,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_QueryInterface(ID3D12Resource1 *
     return E_NOINTERFACE;
 }
 
-static ULONG STDMETHODCALLTYPE d3d12_resource_AddRef(ID3D12Resource1 *iface)
+static ULONG STDMETHODCALLTYPE d3d12_resource_AddRef(ID3D12Resource2 *iface)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
     unsigned int refcount = vkd3d_atomic_increment_u32(&resource->refcount);
 
     TRACE("%p increasing refcount to %u.\n", resource, refcount);
@@ -1299,9 +1300,9 @@ static ULONG STDMETHODCALLTYPE d3d12_resource_AddRef(ID3D12Resource1 *iface)
     return refcount;
 }
 
-static ULONG STDMETHODCALLTYPE d3d12_resource_Release(ID3D12Resource1 *iface)
+static ULONG STDMETHODCALLTYPE d3d12_resource_Release(ID3D12Resource2 *iface)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
     unsigned int refcount = vkd3d_atomic_decrement_u32(&resource->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", resource, refcount);
@@ -1318,39 +1319,39 @@ static ULONG STDMETHODCALLTYPE d3d12_resource_Release(ID3D12Resource1 *iface)
     return refcount;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_GetPrivateData(ID3D12Resource1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_GetPrivateData(ID3D12Resource2 *iface,
         REFGUID guid, UINT *data_size, void *data)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
 
     TRACE("iface %p, guid %s, data_size %p, data %p.\n", iface, debugstr_guid(guid), data_size, data);
 
     return vkd3d_get_private_data(&resource->private_store, guid, data_size, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_SetPrivateData(ID3D12Resource1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_SetPrivateData(ID3D12Resource2 *iface,
         REFGUID guid, UINT data_size, const void *data)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
 
     TRACE("iface %p, guid %s, data_size %u, data %p.\n", iface, debugstr_guid(guid), data_size, data);
 
     return vkd3d_set_private_data(&resource->private_store, guid, data_size, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_SetPrivateDataInterface(ID3D12Resource1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_SetPrivateDataInterface(ID3D12Resource2 *iface,
         REFGUID guid, const IUnknown *data)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
 
     TRACE("iface %p, guid %s, data %p.\n", iface, debugstr_guid(guid), data);
 
     return vkd3d_set_private_data_interface(&resource->private_store, guid, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_SetName(ID3D12Resource1 *iface, const WCHAR *name)
+static HRESULT STDMETHODCALLTYPE d3d12_resource_SetName(ID3D12Resource2 *iface, const WCHAR *name)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
     HRESULT hr;
 
     TRACE("iface %p, name %s.\n", iface, debugstr_w(name, resource->device->wchar_size));
@@ -1369,9 +1370,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_SetName(ID3D12Resource1 *iface,
                 VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT, name);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_GetDevice(ID3D12Resource1 *iface, REFIID iid, void **device)
+static HRESULT STDMETHODCALLTYPE d3d12_resource_GetDevice(ID3D12Resource2 *iface, REFIID iid, void **device)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
 
     TRACE("iface %p, iid %s, device %p.\n", iface, debugstr_guid(iid), device);
 
@@ -1422,10 +1423,10 @@ static void d3d12_resource_flush(struct d3d12_resource *resource, uint64_t offse
         ERR("Failed to flush memory, vr %d.\n", vr);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_Map(ID3D12Resource1 *iface, UINT sub_resource,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_Map(ID3D12Resource2 *iface, UINT sub_resource,
         const D3D12_RANGE *read_range, void **data)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
     unsigned int sub_resource_count;
 
     TRACE("iface %p, sub_resource %u, read_range %p, data %p.\n",
@@ -1471,10 +1472,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_Map(ID3D12Resource1 *iface, UINT
     return S_OK;
 }
 
-static void STDMETHODCALLTYPE d3d12_resource_Unmap(ID3D12Resource1 *iface, UINT sub_resource,
+static void STDMETHODCALLTYPE d3d12_resource_Unmap(ID3D12Resource2 *iface, UINT sub_resource,
         const D3D12_RANGE *written_range)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
     unsigned int sub_resource_count;
 
     TRACE("iface %p, sub_resource %u, written_range %p.\n",
@@ -1493,31 +1494,31 @@ static void STDMETHODCALLTYPE d3d12_resource_Unmap(ID3D12Resource1 *iface, UINT
         d3d12_resource_flush(resource, written_range->Begin, written_range->End - written_range->Begin);
 }
 
-static D3D12_RESOURCE_DESC * STDMETHODCALLTYPE d3d12_resource_GetDesc(ID3D12Resource1 *iface,
+static D3D12_RESOURCE_DESC * STDMETHODCALLTYPE d3d12_resource_GetDesc(ID3D12Resource2 *iface,
         D3D12_RESOURCE_DESC *resource_desc)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
 
     TRACE("iface %p, resource_desc %p.\n", iface, resource_desc);
 
-    *resource_desc = resource->desc;
+    memcpy(resource_desc, &resource->desc, sizeof(*resource_desc));
     return resource_desc;
 }
 
-static D3D12_GPU_VIRTUAL_ADDRESS STDMETHODCALLTYPE d3d12_resource_GetGPUVirtualAddress(ID3D12Resource1 *iface)
+static D3D12_GPU_VIRTUAL_ADDRESS STDMETHODCALLTYPE d3d12_resource_GetGPUVirtualAddress(ID3D12Resource2 *iface)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
 
     TRACE("iface %p.\n", iface);
 
     return resource->gpu_address;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_WriteToSubresource(ID3D12Resource1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_WriteToSubresource(ID3D12Resource2 *iface,
         UINT dst_sub_resource, const D3D12_BOX *dst_box, const void *src_data,
         UINT src_row_pitch, UINT src_slice_pitch)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     VkImageSubresource vk_sub_resource;
     const struct vkd3d_format *format;
@@ -1598,11 +1599,11 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_WriteToSubresource(ID3D12Resourc
     return S_OK;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_ReadFromSubresource(ID3D12Resource1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_ReadFromSubresource(ID3D12Resource2 *iface,
         void *dst_data, UINT dst_row_pitch, UINT dst_slice_pitch,
         UINT src_sub_resource, const D3D12_BOX *src_box)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     VkImageSubresource vk_sub_resource;
     const struct vkd3d_format *format;
@@ -1683,10 +1684,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_ReadFromSubresource(ID3D12Resour
     return S_OK;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_GetHeapProperties(ID3D12Resource1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_GetHeapProperties(ID3D12Resource2 *iface,
         D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS *flags)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
     struct d3d12_heap *heap;
 
     TRACE("iface %p, heap_properties %p, flags %p.\n",
@@ -1720,15 +1721,26 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_GetHeapProperties(ID3D12Resource
     return S_OK;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_GetProtectedResourceSession(ID3D12Resource1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_GetProtectedResourceSession(ID3D12Resource2 *iface,
         REFIID iid, void **session)
 {
     FIXME("iface %p, iid %s, session %p stub!\n", iface, debugstr_guid(iid), session);
 
-    return E_NOTIMPL;
+    return DXGI_ERROR_NOT_FOUND;
+}
+
+static D3D12_RESOURCE_DESC1 * STDMETHODCALLTYPE d3d12_resource_GetDesc1(ID3D12Resource2 *iface,
+        D3D12_RESOURCE_DESC1 *resource_desc)
+{
+    struct d3d12_resource *resource = impl_from_ID3D12Resource2(iface);
+
+    TRACE("iface %p, resource_desc %p.\n", iface, resource_desc);
+
+    *resource_desc = resource->desc;
+    return resource_desc;
 }
 
-static const struct ID3D12Resource1Vtbl d3d12_resource_vtbl =
+static const struct ID3D12Resource2Vtbl d3d12_resource_vtbl =
 {
     /* IUnknown methods */
     d3d12_resource_QueryInterface,
@@ -1751,6 +1763,8 @@ static const struct ID3D12Resource1Vtbl d3d12_resource_vtbl =
     d3d12_resource_GetHeapProperties,
     /* ID3D12Resource1 methods */
     d3d12_resource_GetProtectedResourceSession,
+    /* ID3D12Resource2 methods */
+    d3d12_resource_GetDesc1,
 };
 
 struct d3d12_resource *unsafe_impl_from_ID3D12Resource(ID3D12Resource *iface)
@@ -1777,7 +1791,7 @@ static void d3d12_validate_resource_flags(D3D12_RESOURCE_FLAGS flags)
         FIXME("Ignoring D3D12_RESOURCE_FLAG_ALLOW_CROSS_ADAPTER.\n");
 }
 
-static bool d3d12_resource_validate_texture_format(const D3D12_RESOURCE_DESC *desc,
+static bool d3d12_resource_validate_texture_format(const D3D12_RESOURCE_DESC1 *desc,
         const struct vkd3d_format *format)
 {
     if (desc->Format == DXGI_FORMAT_UNKNOWN)
@@ -1806,7 +1820,7 @@ static bool d3d12_resource_validate_texture_format(const D3D12_RESOURCE_DESC *de
     return true;
 }
 
-static bool d3d12_resource_validate_texture_alignment(const D3D12_RESOURCE_DESC *desc,
+static bool d3d12_resource_validate_texture_alignment(const D3D12_RESOURCE_DESC1 *desc,
         const struct vkd3d_format *format)
 {
     uint64_t estimated_size;
@@ -1841,7 +1855,7 @@ static bool d3d12_resource_validate_texture_alignment(const D3D12_RESOURCE_DESC
     return true;
 }
 
-HRESULT d3d12_resource_validate_desc(const D3D12_RESOURCE_DESC *desc, struct d3d12_device *device)
+HRESULT d3d12_resource_validate_desc(const D3D12_RESOURCE_DESC1 *desc, struct d3d12_device *device)
 {
     const struct vkd3d_format *format;
 
@@ -1950,12 +1964,12 @@ static bool d3d12_resource_validate_heap_properties(const struct d3d12_resource
 
 static HRESULT d3d12_resource_init(struct d3d12_resource *resource, struct d3d12_device *device,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
-        const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
+        const D3D12_RESOURCE_DESC1 *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value)
 {
     HRESULT hr;
 
-    resource->ID3D12Resource1_iface.lpVtbl = &d3d12_resource_vtbl;
+    resource->ID3D12Resource2_iface.lpVtbl = &d3d12_resource_vtbl;
     resource->refcount = 1;
     resource->internal_refcount = 1;
 
@@ -2047,7 +2061,7 @@ static HRESULT d3d12_resource_init(struct d3d12_resource *resource, struct d3d12
 
 static HRESULT d3d12_resource_create(struct d3d12_device *device,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
-        const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
+        const D3D12_RESOURCE_DESC1 *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource)
 {
     struct d3d12_resource *object;
@@ -2086,7 +2100,7 @@ static HRESULT vkd3d_allocate_resource_memory(
 
 HRESULT d3d12_committed_resource_create(struct d3d12_device *device,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
-        const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
+        const D3D12_RESOURCE_DESC1 *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, ID3D12ProtectedResourceSession *protected_session,
         struct d3d12_resource **resource)
 {
@@ -2108,7 +2122,7 @@ HRESULT d3d12_committed_resource_create(struct d3d12_device *device,
 
     if (FAILED(hr = vkd3d_allocate_resource_memory(device, object, heap_properties, heap_flags)))
     {
-        d3d12_resource_Release(&object->ID3D12Resource1_iface);
+        d3d12_resource_Release(&object->ID3D12Resource2_iface);
         return hr;
     }
 
@@ -2189,7 +2203,7 @@ allocate_memory:
 }
 
 HRESULT d3d12_placed_resource_create(struct d3d12_device *device, struct d3d12_heap *heap, uint64_t heap_offset,
-        const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
+        const D3D12_RESOURCE_DESC1 *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource)
 {
     struct d3d12_resource *object;
@@ -2201,7 +2215,7 @@ HRESULT d3d12_placed_resource_create(struct d3d12_device *device, struct d3d12_h
 
     if (FAILED(hr = vkd3d_bind_heap_memory(device, object, heap, heap_offset)))
     {
-        d3d12_resource_Release(&object->ID3D12Resource1_iface);
+        d3d12_resource_Release(&object->ID3D12Resource2_iface);
         return hr;
     }
 
@@ -2213,7 +2227,7 @@ HRESULT d3d12_placed_resource_create(struct d3d12_device *device, struct d3d12_h
 }
 
 HRESULT d3d12_reserved_resource_create(struct d3d12_device *device,
-        const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
+        const D3D12_RESOURCE_DESC1 *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource)
 {
     struct d3d12_resource *object;
@@ -2225,7 +2239,7 @@ HRESULT d3d12_reserved_resource_create(struct d3d12_device *device,
 
     if (!d3d12_resource_init_tiles(object, device))
     {
-        d3d12_resource_Release(&object->ID3D12Resource1_iface);
+        d3d12_resource_Release(&object->ID3D12Resource2_iface);
         return E_OUTOFMEMORY;
     }
 
@@ -2260,7 +2274,7 @@ HRESULT vkd3d_create_image_resource(ID3D12Device *device,
 
     memset(object, 0, sizeof(*object));
 
-    object->ID3D12Resource1_iface.lpVtbl = &d3d12_resource_vtbl;
+    object->ID3D12Resource2_iface.lpVtbl = &d3d12_resource_vtbl;
     object->refcount = 1;
     object->internal_refcount = 1;
     object->desc = create_info->desc;
@@ -2284,7 +2298,7 @@ HRESULT vkd3d_create_image_resource(ID3D12Device *device,
 
     TRACE("Created resource %p.\n", object);
 
-    *resource = (ID3D12Resource *)&object->ID3D12Resource1_iface;
+    *resource = (ID3D12Resource *)&object->ID3D12Resource2_iface;
 
     return S_OK;
 }
@@ -3022,7 +3036,7 @@ static bool init_default_texture_view_desc(struct vkd3d_texture_view_desc *desc,
 }
 
 static void vkd3d_texture_view_desc_normalise(struct vkd3d_texture_view_desc *desc,
-        const D3D12_RESOURCE_DESC *resource_desc)
+        const D3D12_RESOURCE_DESC1 *resource_desc)
 {
     unsigned int max_layer_count;
 
@@ -4815,7 +4829,7 @@ HRESULT vkd3d_init_null_resources(struct vkd3d_null_resources *null_resources,
 {
     const bool use_sparse_resources = device->vk_info.sparse_properties.residencyNonResidentStrict;
     D3D12_HEAP_PROPERTIES heap_properties;
-    D3D12_RESOURCE_DESC resource_desc;
+    D3D12_RESOURCE_DESC1 resource_desc;
     HRESULT hr;
 
     TRACE("Creating resources for NULL views.\n");
@@ -4840,6 +4854,7 @@ HRESULT vkd3d_init_null_resources(struct vkd3d_null_resources *null_resources,
     resource_desc.SampleDesc.Quality = 0;
     resource_desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
     resource_desc.Flags = D3D12_RESOURCE_FLAG_NONE;
+    memset(&resource_desc.SamplerFeedbackMipRegion, 0, sizeof(resource_desc.SamplerFeedbackMipRegion));
 
     if (FAILED(hr = vkd3d_create_buffer(device, &heap_properties, D3D12_HEAP_FLAG_NONE,
             &resource_desc, &null_resources->vk_buffer)))
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
index 78f4f3514e2..ed331ccbcc5 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
@@ -692,11 +692,11 @@ struct d3d12_resource_tile_info
 /* ID3D12Resource */
 struct d3d12_resource
 {
-    ID3D12Resource1 ID3D12Resource1_iface;
+    ID3D12Resource2 ID3D12Resource2_iface;
     unsigned int refcount;
     unsigned int internal_refcount;
 
-    D3D12_RESOURCE_DESC desc;
+    D3D12_RESOURCE_DESC1 desc;
     const struct vkd3d_format *format;
 
     D3D12_GPU_VIRTUAL_ADDRESS gpu_address;
@@ -724,12 +724,12 @@ struct d3d12_resource
 
 static inline struct d3d12_resource *impl_from_ID3D12Resource(ID3D12Resource *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d12_resource, ID3D12Resource1_iface);
+    return CONTAINING_RECORD(iface, struct d3d12_resource, ID3D12Resource2_iface);
 }
 
-static inline struct d3d12_resource *impl_from_ID3D12Resource1(ID3D12Resource1 *iface)
+static inline struct d3d12_resource *impl_from_ID3D12Resource2(ID3D12Resource2 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d12_resource, ID3D12Resource1_iface);
+    return CONTAINING_RECORD(iface, struct d3d12_resource, ID3D12Resource2_iface);
 }
 
 static inline bool d3d12_resource_is_buffer(const struct d3d12_resource *resource)
@@ -750,7 +750,7 @@ struct vkd3d_resource_allocation_info
 };
 
 bool d3d12_resource_is_cpu_accessible(const struct d3d12_resource *resource);
-HRESULT d3d12_resource_validate_desc(const D3D12_RESOURCE_DESC *desc, struct d3d12_device *device);
+HRESULT d3d12_resource_validate_desc(const D3D12_RESOURCE_DESC1 *desc, struct d3d12_device *device);
 void d3d12_resource_get_tiling(struct d3d12_device *device, const struct d3d12_resource *resource,
         UINT *total_tile_count, D3D12_PACKED_MIP_INFO *packed_mip_info, D3D12_TILE_SHAPE *standard_tile_shape,
         UINT *sub_resource_tiling_count, UINT first_sub_resource_tiling,
@@ -758,14 +758,14 @@ void d3d12_resource_get_tiling(struct d3d12_device *device, const struct d3d12_r
 
 HRESULT d3d12_committed_resource_create(struct d3d12_device *device,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
-        const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
+        const D3D12_RESOURCE_DESC1 *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, ID3D12ProtectedResourceSession *protected_session,
         struct d3d12_resource **resource);
 HRESULT d3d12_placed_resource_create(struct d3d12_device *device, struct d3d12_heap *heap, uint64_t heap_offset,
-        const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
+        const D3D12_RESOURCE_DESC1 *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource);
 HRESULT d3d12_reserved_resource_create(struct d3d12_device *device,
-        const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
+        const D3D12_RESOURCE_DESC1 *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource);
 struct d3d12_resource *unsafe_impl_from_ID3D12Resource(ID3D12Resource *iface);
 
@@ -774,9 +774,9 @@ HRESULT vkd3d_allocate_buffer_memory(struct d3d12_device *device, VkBuffer vk_bu
         VkDeviceMemory *vk_memory, uint32_t *vk_memory_type, VkDeviceSize *vk_memory_size);
 HRESULT vkd3d_create_buffer(struct d3d12_device *device,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
-        const D3D12_RESOURCE_DESC *desc, VkBuffer *vk_buffer);
+        const D3D12_RESOURCE_DESC1 *desc, VkBuffer *vk_buffer);
 HRESULT vkd3d_get_image_allocation_info(struct d3d12_device *device,
-        const D3D12_RESOURCE_DESC *desc, struct vkd3d_resource_allocation_info *allocation_info);
+        const D3D12_RESOURCE_DESC1 *desc, struct vkd3d_resource_allocation_info *allocation_info);
 
 enum vkd3d_view_type
 {
@@ -1876,7 +1876,7 @@ HRESULT vkd3d_init_format_info(struct d3d12_device *device);
 void vkd3d_cleanup_format_info(struct d3d12_device *device);
 
 static inline const struct vkd3d_format *vkd3d_format_from_d3d12_resource_desc(
-        const struct d3d12_device *device, const D3D12_RESOURCE_DESC *desc, DXGI_FORMAT view_format)
+        const struct d3d12_device *device, const D3D12_RESOURCE_DESC1 *desc, DXGI_FORMAT view_format)
 {
     return vkd3d_get_format(device, view_format ? view_format : desc->Format,
             desc->Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL);
@@ -1887,31 +1887,31 @@ static inline bool d3d12_box_is_empty(const D3D12_BOX *box)
     return box->right <= box->left || box->bottom <= box->top || box->back <= box->front;
 }
 
-static inline unsigned int d3d12_resource_desc_get_width(const D3D12_RESOURCE_DESC *desc,
+static inline unsigned int d3d12_resource_desc_get_width(const D3D12_RESOURCE_DESC1 *desc,
         unsigned int miplevel_idx)
 {
     return max(1, desc->Width >> miplevel_idx);
 }
 
-static inline unsigned int d3d12_resource_desc_get_height(const D3D12_RESOURCE_DESC *desc,
+static inline unsigned int d3d12_resource_desc_get_height(const D3D12_RESOURCE_DESC1 *desc,
         unsigned int miplevel_idx)
 {
     return max(1, desc->Height >> miplevel_idx);
 }
 
-static inline unsigned int d3d12_resource_desc_get_depth(const D3D12_RESOURCE_DESC *desc,
+static inline unsigned int d3d12_resource_desc_get_depth(const D3D12_RESOURCE_DESC1 *desc,
         unsigned int miplevel_idx)
 {
     unsigned int d = desc->Dimension != D3D12_RESOURCE_DIMENSION_TEXTURE3D ? 1 : desc->DepthOrArraySize;
     return max(1, d >> miplevel_idx);
 }
 
-static inline unsigned int d3d12_resource_desc_get_layer_count(const D3D12_RESOURCE_DESC *desc)
+static inline unsigned int d3d12_resource_desc_get_layer_count(const D3D12_RESOURCE_DESC1 *desc)
 {
     return desc->Dimension != D3D12_RESOURCE_DIMENSION_TEXTURE3D ? desc->DepthOrArraySize : 1;
 }
 
-static inline unsigned int d3d12_resource_desc_get_sub_resource_count(const D3D12_RESOURCE_DESC *desc)
+static inline unsigned int d3d12_resource_desc_get_sub_resource_count(const D3D12_RESOURCE_DESC1 *desc)
 {
     return d3d12_resource_desc_get_layer_count(desc) * desc->MipLevels;
 }
-- 
2.43.0

