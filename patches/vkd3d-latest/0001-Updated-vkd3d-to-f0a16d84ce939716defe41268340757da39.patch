From 8e58d0f477c5a8d65fabc1d12eb364876cd5f173 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 17 May 2023 08:35:40 +1000
Subject: [PATCH] Updated vkd3d to f0a16d84ce939716defe41268340757da3900055.

---
 libs/vkd3d/include/list.h                     |  270 ++
 libs/vkd3d/include/private/list.h             |  270 ++
 libs/vkd3d/include/private/rbtree.h           |  378 ++
 libs/vkd3d/include/private/vkd3d_common.h     |   27 +-
 libs/vkd3d/include/private/vkd3d_test.h       |  432 +++
 libs/vkd3d/include/vkd3d_d3d9types.h          |  237 ++
 libs/vkd3d/include/vkd3d_d3dcompiler.h        |   92 +
 libs/vkd3d/include/vkd3d_d3dcompiler_types.h  |   45 +
 libs/vkd3d/include/vkd3d_shader.h             |  163 +-
 libs/vkd3d/include/vkd3d_utils.h              |  123 +
 libs/vkd3d/include/vkd3d_windows.h            |  289 ++
 libs/vkd3d/libs/vkd3d-common/blob.c           |    2 +
 libs/vkd3d/libs/vkd3d-shader/d3d_asm.c        |  139 +-
 libs/vkd3d/libs/vkd3d-shader/d3dbc.c          |  142 +-
 libs/vkd3d/libs/vkd3d-shader/dxbc.c           |  162 +-
 libs/vkd3d/libs/vkd3d-shader/dxil.c           | 3269 +++++++++++++++--
 libs/vkd3d/libs/vkd3d-shader/hlsl.c           |  353 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.h           |  111 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.l           |   56 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.y           |  698 +++-
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c   |  952 +++--
 .../libs/vkd3d-shader/hlsl_constant_ops.c     |  417 ++-
 libs/vkd3d/libs/vkd3d-shader/ir.c             |  648 +++-
 libs/vkd3d/libs/vkd3d-shader/preproc.h        |    2 +-
 libs/vkd3d/libs/vkd3d-shader/spirv.c          |  923 +++--
 libs/vkd3d/libs/vkd3d-shader/tpf.c            | 1715 +++++----
 .../libs/vkd3d-shader/vkd3d_shader_main.c     |  296 +-
 .../libs/vkd3d-shader/vkd3d_shader_private.h  |  230 +-
 libs/vkd3d/libs/vkd3d/command.c               |  352 +-
 libs/vkd3d/libs/vkd3d/device.c                |  437 ++-
 libs/vkd3d/libs/vkd3d/resource.c              |  121 +-
 libs/vkd3d/libs/vkd3d/state.c                 |  409 ++-
 libs/vkd3d/libs/vkd3d/vkd3d_main.c            |    4 +-
 libs/vkd3d/libs/vkd3d/vkd3d_private.h         |   67 +-
 libs/vkd3d/libs/vkd3d/vkd3d_shaders.h         |  568 +--
 35 files changed, 11546 insertions(+), 2853 deletions(-)
 create mode 100644 libs/vkd3d/include/list.h
 create mode 100644 libs/vkd3d/include/private/list.h
 create mode 100644 libs/vkd3d/include/private/rbtree.h
 create mode 100644 libs/vkd3d/include/private/vkd3d_test.h
 create mode 100644 libs/vkd3d/include/vkd3d_d3d9types.h
 create mode 100644 libs/vkd3d/include/vkd3d_d3dcompiler.h
 create mode 100644 libs/vkd3d/include/vkd3d_d3dcompiler_types.h
 create mode 100644 libs/vkd3d/include/vkd3d_utils.h
 create mode 100644 libs/vkd3d/include/vkd3d_windows.h

diff --git a/libs/vkd3d/include/list.h b/libs/vkd3d/include/list.h
new file mode 100644
index 00000000000..2e1d95f3fd4
--- /dev/null
+++ b/libs/vkd3d/include/list.h
@@ -0,0 +1,270 @@
+/*
+ * Linked lists support
+ *
+ * Copyright (C) 2002 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_SERVER_LIST_H
+#define __WINE_SERVER_LIST_H
+
+#include <stddef.h>
+
+struct list
+{
+    struct list *next;
+    struct list *prev;
+};
+
+/* Define a list like so:
+ *
+ *   struct gadget
+ *   {
+ *       struct list  entry;   <-- doesn't have to be the first item in the struct
+ *       int          a, b;
+ *   };
+ *
+ *   static struct list global_gadgets = LIST_INIT( global_gadgets );
+ *
+ * or
+ *
+ *   struct some_global_thing
+ *   {
+ *       struct list gadgets;
+ *   };
+ *
+ *   list_init( &some_global_thing->gadgets );
+ *
+ * Manipulate it like this:
+ *
+ *   list_add_head( &global_gadgets, &new_gadget->entry );
+ *   list_remove( &new_gadget->entry );
+ *   list_add_after( &some_random_gadget->entry, &new_gadget->entry );
+ *
+ * And to iterate over it:
+ *
+ *   struct gadget *gadget;
+ *   LIST_FOR_EACH_ENTRY( gadget, &global_gadgets, struct gadget, entry )
+ *   {
+ *       ...
+ *   }
+ *
+ */
+
+/* add an element after the specified one */
+static inline void list_add_after( struct list *elem, struct list *to_add )
+{
+    to_add->next = elem->next;
+    to_add->prev = elem;
+    elem->next->prev = to_add;
+    elem->next = to_add;
+}
+
+/* add an element before the specified one */
+static inline void list_add_before( struct list *elem, struct list *to_add )
+{
+    to_add->next = elem;
+    to_add->prev = elem->prev;
+    elem->prev->next = to_add;
+    elem->prev = to_add;
+}
+
+/* add element at the head of the list */
+static inline void list_add_head( struct list *list, struct list *elem )
+{
+    list_add_after( list, elem );
+}
+
+/* add element at the tail of the list */
+static inline void list_add_tail( struct list *list, struct list *elem )
+{
+    list_add_before( list, elem );
+}
+
+/* remove an element from its list */
+static inline void list_remove( struct list *elem )
+{
+    elem->next->prev = elem->prev;
+    elem->prev->next = elem->next;
+}
+
+/* get the next element */
+static inline struct list *list_next( const struct list *list, const struct list *elem )
+{
+    struct list *ret = elem->next;
+    if (elem->next == list) ret = NULL;
+    return ret;
+}
+
+/* get the previous element */
+static inline struct list *list_prev( const struct list *list, const struct list *elem )
+{
+    struct list *ret = elem->prev;
+    if (elem->prev == list) ret = NULL;
+    return ret;
+}
+
+/* get the first element */
+static inline struct list *list_head( const struct list *list )
+{
+    return list_next( list, list );
+}
+
+/* get the last element */
+static inline struct list *list_tail( const struct list *list )
+{
+    return list_prev( list, list );
+}
+
+/* check if a list is empty */
+static inline int list_empty( const struct list *list )
+{
+    return list->next == list;
+}
+
+/* initialize a list */
+static inline void list_init( struct list *list )
+{
+    list->next = list->prev = list;
+}
+
+/* count the elements of a list */
+static inline unsigned int list_count( const struct list *list )
+{
+    unsigned count = 0;
+    const struct list *ptr;
+    for (ptr = list->next; ptr != list; ptr = ptr->next) count++;
+    return count;
+}
+
+/* move all elements from src to before the specified element */
+static inline void list_move_before( struct list *dst, struct list *src )
+{
+    if (list_empty(src)) return;
+
+    dst->prev->next = src->next;
+    src->next->prev = dst->prev;
+    dst->prev = src->prev;
+    src->prev->next = dst;
+    list_init(src);
+}
+
+/* move all elements from src to after the specified element */
+static inline void list_move_after( struct list *dst, struct list *src )
+{
+    if (list_empty(src)) return;
+
+    dst->next->prev = src->prev;
+    src->prev->next = dst->next;
+    dst->next = src->next;
+    src->next->prev = dst;
+    list_init(src);
+}
+
+/* move all elements from src to the head of dst */
+static inline void list_move_head( struct list *dst, struct list *src )
+{
+    list_move_after( dst, src );
+}
+
+/* move all elements from src to the tail of dst */
+static inline void list_move_tail( struct list *dst, struct list *src )
+{
+    list_move_before( dst, src );
+}
+
+/* move the slice of elements from begin to end inclusive to the head of dst */
+static inline void list_move_slice_head( struct list *dst, struct list *begin, struct list *end )
+{
+    struct list *dst_next = dst->next;
+    begin->prev->next = end->next;
+    end->next->prev = begin->prev;
+    dst->next = begin;
+    dst_next->prev = end;
+    begin->prev = dst;
+    end->next = dst_next;
+}
+
+/* move the slice of elements from begin to end inclusive to the tail of dst */
+static inline void list_move_slice_tail( struct list *dst, struct list *begin, struct list *end )
+{
+    struct list *dst_prev = dst->prev;
+    begin->prev->next = end->next;
+    end->next->prev = begin->prev;
+    dst_prev->next = begin;
+    dst->prev = end;
+    begin->prev = dst_prev;
+    end->next = dst;
+}
+
+/* iterate through the list */
+#define LIST_FOR_EACH(cursor,list) \
+    for ((cursor) = (list)->next; (cursor) != (list); (cursor) = (cursor)->next)
+
+/* iterate through the list, with safety against removal */
+#define LIST_FOR_EACH_SAFE(cursor, cursor2, list) \
+    for ((cursor) = (list)->next, (cursor2) = (cursor)->next; \
+         (cursor) != (list); \
+         (cursor) = (cursor2), (cursor2) = (cursor)->next)
+
+/* iterate through the list using a list entry */
+#define LIST_FOR_EACH_ENTRY(elem, list, type, field) \
+    for ((elem) = LIST_ENTRY((list)->next, type, field); \
+         &(elem)->field != (list); \
+         (elem) = LIST_ENTRY((elem)->field.next, type, field))
+
+/* iterate through the list using a list entry, with safety against removal */
+#define LIST_FOR_EACH_ENTRY_SAFE(cursor, cursor2, list, type, field) \
+    for ((cursor) = LIST_ENTRY((list)->next, type, field), \
+         (cursor2) = LIST_ENTRY((cursor)->field.next, type, field); \
+         &(cursor)->field != (list); \
+         (cursor) = (cursor2), \
+         (cursor2) = LIST_ENTRY((cursor)->field.next, type, field))
+
+/* iterate through the list in reverse order */
+#define LIST_FOR_EACH_REV(cursor,list) \
+    for ((cursor) = (list)->prev; (cursor) != (list); (cursor) = (cursor)->prev)
+
+/* iterate through the list in reverse order, with safety against removal */
+#define LIST_FOR_EACH_SAFE_REV(cursor, cursor2, list) \
+    for ((cursor) = (list)->prev, (cursor2) = (cursor)->prev; \
+         (cursor) != (list); \
+         (cursor) = (cursor2), (cursor2) = (cursor)->prev)
+
+/* iterate through the list in reverse order using a list entry */
+#define LIST_FOR_EACH_ENTRY_REV(elem, list, type, field) \
+    for ((elem) = LIST_ENTRY((list)->prev, type, field); \
+         &(elem)->field != (list); \
+         (elem) = LIST_ENTRY((elem)->field.prev, type, field))
+
+/* iterate through the list in reverse order using a list entry, with safety against removal */
+#define LIST_FOR_EACH_ENTRY_SAFE_REV(cursor, cursor2, list, type, field) \
+    for ((cursor) = LIST_ENTRY((list)->prev, type, field), \
+         (cursor2) = LIST_ENTRY((cursor)->field.prev, type, field); \
+         &(cursor)->field != (list); \
+         (cursor) = (cursor2), \
+         (cursor2) = LIST_ENTRY((cursor)->field.prev, type, field))
+
+/* macros for statically initialized lists */
+#undef LIST_INIT
+#define LIST_INIT(list)  { &(list), &(list) }
+
+/* get pointer to object containing list element */
+#undef LIST_ENTRY
+#define LIST_ENTRY(elem, type, field) \
+    ((type *)((char *)(elem) - offsetof(type, field)))
+
+#endif  /* __WINE_SERVER_LIST_H */
diff --git a/libs/vkd3d/include/private/list.h b/libs/vkd3d/include/private/list.h
new file mode 100644
index 00000000000..2e1d95f3fd4
--- /dev/null
+++ b/libs/vkd3d/include/private/list.h
@@ -0,0 +1,270 @@
+/*
+ * Linked lists support
+ *
+ * Copyright (C) 2002 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_SERVER_LIST_H
+#define __WINE_SERVER_LIST_H
+
+#include <stddef.h>
+
+struct list
+{
+    struct list *next;
+    struct list *prev;
+};
+
+/* Define a list like so:
+ *
+ *   struct gadget
+ *   {
+ *       struct list  entry;   <-- doesn't have to be the first item in the struct
+ *       int          a, b;
+ *   };
+ *
+ *   static struct list global_gadgets = LIST_INIT( global_gadgets );
+ *
+ * or
+ *
+ *   struct some_global_thing
+ *   {
+ *       struct list gadgets;
+ *   };
+ *
+ *   list_init( &some_global_thing->gadgets );
+ *
+ * Manipulate it like this:
+ *
+ *   list_add_head( &global_gadgets, &new_gadget->entry );
+ *   list_remove( &new_gadget->entry );
+ *   list_add_after( &some_random_gadget->entry, &new_gadget->entry );
+ *
+ * And to iterate over it:
+ *
+ *   struct gadget *gadget;
+ *   LIST_FOR_EACH_ENTRY( gadget, &global_gadgets, struct gadget, entry )
+ *   {
+ *       ...
+ *   }
+ *
+ */
+
+/* add an element after the specified one */
+static inline void list_add_after( struct list *elem, struct list *to_add )
+{
+    to_add->next = elem->next;
+    to_add->prev = elem;
+    elem->next->prev = to_add;
+    elem->next = to_add;
+}
+
+/* add an element before the specified one */
+static inline void list_add_before( struct list *elem, struct list *to_add )
+{
+    to_add->next = elem;
+    to_add->prev = elem->prev;
+    elem->prev->next = to_add;
+    elem->prev = to_add;
+}
+
+/* add element at the head of the list */
+static inline void list_add_head( struct list *list, struct list *elem )
+{
+    list_add_after( list, elem );
+}
+
+/* add element at the tail of the list */
+static inline void list_add_tail( struct list *list, struct list *elem )
+{
+    list_add_before( list, elem );
+}
+
+/* remove an element from its list */
+static inline void list_remove( struct list *elem )
+{
+    elem->next->prev = elem->prev;
+    elem->prev->next = elem->next;
+}
+
+/* get the next element */
+static inline struct list *list_next( const struct list *list, const struct list *elem )
+{
+    struct list *ret = elem->next;
+    if (elem->next == list) ret = NULL;
+    return ret;
+}
+
+/* get the previous element */
+static inline struct list *list_prev( const struct list *list, const struct list *elem )
+{
+    struct list *ret = elem->prev;
+    if (elem->prev == list) ret = NULL;
+    return ret;
+}
+
+/* get the first element */
+static inline struct list *list_head( const struct list *list )
+{
+    return list_next( list, list );
+}
+
+/* get the last element */
+static inline struct list *list_tail( const struct list *list )
+{
+    return list_prev( list, list );
+}
+
+/* check if a list is empty */
+static inline int list_empty( const struct list *list )
+{
+    return list->next == list;
+}
+
+/* initialize a list */
+static inline void list_init( struct list *list )
+{
+    list->next = list->prev = list;
+}
+
+/* count the elements of a list */
+static inline unsigned int list_count( const struct list *list )
+{
+    unsigned count = 0;
+    const struct list *ptr;
+    for (ptr = list->next; ptr != list; ptr = ptr->next) count++;
+    return count;
+}
+
+/* move all elements from src to before the specified element */
+static inline void list_move_before( struct list *dst, struct list *src )
+{
+    if (list_empty(src)) return;
+
+    dst->prev->next = src->next;
+    src->next->prev = dst->prev;
+    dst->prev = src->prev;
+    src->prev->next = dst;
+    list_init(src);
+}
+
+/* move all elements from src to after the specified element */
+static inline void list_move_after( struct list *dst, struct list *src )
+{
+    if (list_empty(src)) return;
+
+    dst->next->prev = src->prev;
+    src->prev->next = dst->next;
+    dst->next = src->next;
+    src->next->prev = dst;
+    list_init(src);
+}
+
+/* move all elements from src to the head of dst */
+static inline void list_move_head( struct list *dst, struct list *src )
+{
+    list_move_after( dst, src );
+}
+
+/* move all elements from src to the tail of dst */
+static inline void list_move_tail( struct list *dst, struct list *src )
+{
+    list_move_before( dst, src );
+}
+
+/* move the slice of elements from begin to end inclusive to the head of dst */
+static inline void list_move_slice_head( struct list *dst, struct list *begin, struct list *end )
+{
+    struct list *dst_next = dst->next;
+    begin->prev->next = end->next;
+    end->next->prev = begin->prev;
+    dst->next = begin;
+    dst_next->prev = end;
+    begin->prev = dst;
+    end->next = dst_next;
+}
+
+/* move the slice of elements from begin to end inclusive to the tail of dst */
+static inline void list_move_slice_tail( struct list *dst, struct list *begin, struct list *end )
+{
+    struct list *dst_prev = dst->prev;
+    begin->prev->next = end->next;
+    end->next->prev = begin->prev;
+    dst_prev->next = begin;
+    dst->prev = end;
+    begin->prev = dst_prev;
+    end->next = dst;
+}
+
+/* iterate through the list */
+#define LIST_FOR_EACH(cursor,list) \
+    for ((cursor) = (list)->next; (cursor) != (list); (cursor) = (cursor)->next)
+
+/* iterate through the list, with safety against removal */
+#define LIST_FOR_EACH_SAFE(cursor, cursor2, list) \
+    for ((cursor) = (list)->next, (cursor2) = (cursor)->next; \
+         (cursor) != (list); \
+         (cursor) = (cursor2), (cursor2) = (cursor)->next)
+
+/* iterate through the list using a list entry */
+#define LIST_FOR_EACH_ENTRY(elem, list, type, field) \
+    for ((elem) = LIST_ENTRY((list)->next, type, field); \
+         &(elem)->field != (list); \
+         (elem) = LIST_ENTRY((elem)->field.next, type, field))
+
+/* iterate through the list using a list entry, with safety against removal */
+#define LIST_FOR_EACH_ENTRY_SAFE(cursor, cursor2, list, type, field) \
+    for ((cursor) = LIST_ENTRY((list)->next, type, field), \
+         (cursor2) = LIST_ENTRY((cursor)->field.next, type, field); \
+         &(cursor)->field != (list); \
+         (cursor) = (cursor2), \
+         (cursor2) = LIST_ENTRY((cursor)->field.next, type, field))
+
+/* iterate through the list in reverse order */
+#define LIST_FOR_EACH_REV(cursor,list) \
+    for ((cursor) = (list)->prev; (cursor) != (list); (cursor) = (cursor)->prev)
+
+/* iterate through the list in reverse order, with safety against removal */
+#define LIST_FOR_EACH_SAFE_REV(cursor, cursor2, list) \
+    for ((cursor) = (list)->prev, (cursor2) = (cursor)->prev; \
+         (cursor) != (list); \
+         (cursor) = (cursor2), (cursor2) = (cursor)->prev)
+
+/* iterate through the list in reverse order using a list entry */
+#define LIST_FOR_EACH_ENTRY_REV(elem, list, type, field) \
+    for ((elem) = LIST_ENTRY((list)->prev, type, field); \
+         &(elem)->field != (list); \
+         (elem) = LIST_ENTRY((elem)->field.prev, type, field))
+
+/* iterate through the list in reverse order using a list entry, with safety against removal */
+#define LIST_FOR_EACH_ENTRY_SAFE_REV(cursor, cursor2, list, type, field) \
+    for ((cursor) = LIST_ENTRY((list)->prev, type, field), \
+         (cursor2) = LIST_ENTRY((cursor)->field.prev, type, field); \
+         &(cursor)->field != (list); \
+         (cursor) = (cursor2), \
+         (cursor2) = LIST_ENTRY((cursor)->field.prev, type, field))
+
+/* macros for statically initialized lists */
+#undef LIST_INIT
+#define LIST_INIT(list)  { &(list), &(list) }
+
+/* get pointer to object containing list element */
+#undef LIST_ENTRY
+#define LIST_ENTRY(elem, type, field) \
+    ((type *)((char *)(elem) - offsetof(type, field)))
+
+#endif  /* __WINE_SERVER_LIST_H */
diff --git a/libs/vkd3d/include/private/rbtree.h b/libs/vkd3d/include/private/rbtree.h
new file mode 100644
index 00000000000..b5d38bca54c
--- /dev/null
+++ b/libs/vkd3d/include/private/rbtree.h
@@ -0,0 +1,378 @@
+/*
+ * Red-black search tree support
+ *
+ * Copyright 2009 Henri Verbeet
+ * Copyright 2009 Andrew Riedi
+ * Copyright 2016 Jacek Caban for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WINE_RBTREE_H
+#define __WINE_WINE_RBTREE_H
+
+#define RB_ENTRY_VALUE(element, type, field) \
+    ((type *)((char *)(element) - offsetof(type, field)))
+
+struct rb_entry
+{
+    struct rb_entry *parent;
+    struct rb_entry *left;
+    struct rb_entry *right;
+    unsigned int flags;
+};
+
+typedef int (*rb_compare_func)(const void *key, const struct rb_entry *entry);
+
+struct rb_tree
+{
+    rb_compare_func compare;
+    struct rb_entry *root;
+};
+
+typedef void (rb_traverse_func)(struct rb_entry *entry, void *context);
+
+#define RB_FLAG_RED                0x1
+
+static inline int rb_is_red(struct rb_entry *entry)
+{
+    return entry && (entry->flags & RB_FLAG_RED);
+}
+
+static inline void rb_rotate_left(struct rb_tree *tree, struct rb_entry *e)
+{
+    struct rb_entry *right = e->right;
+
+    if (!e->parent)
+        tree->root = right;
+    else if (e->parent->left == e)
+        e->parent->left = right;
+    else
+        e->parent->right = right;
+
+    e->right = right->left;
+    if (e->right) e->right->parent = e;
+    right->left = e;
+    right->parent = e->parent;
+    e->parent = right;
+}
+
+static inline void rb_rotate_right(struct rb_tree *tree, struct rb_entry *e)
+{
+    struct rb_entry *left = e->left;
+
+    if (!e->parent)
+        tree->root = left;
+    else if (e->parent->left == e)
+        e->parent->left = left;
+    else
+        e->parent->right = left;
+
+    e->left = left->right;
+    if (e->left) e->left->parent = e;
+    left->right = e;
+    left->parent = e->parent;
+    e->parent = left;
+}
+
+static inline void rb_flip_color(struct rb_entry *entry)
+{
+    entry->flags ^= RB_FLAG_RED;
+    entry->left->flags ^= RB_FLAG_RED;
+    entry->right->flags ^= RB_FLAG_RED;
+}
+
+static inline struct rb_entry *rb_head(struct rb_entry *iter)
+{
+    if (!iter) return NULL;
+    while (iter->left) iter = iter->left;
+    return iter;
+}
+
+static inline struct rb_entry *rb_next(struct rb_entry *iter)
+{
+    if (iter->right) return rb_head(iter->right);
+    while (iter->parent && iter->parent->right == iter) iter = iter->parent;
+    return iter->parent;
+}
+
+static inline struct rb_entry *rb_postorder_head(struct rb_entry *iter)
+{
+    if (!iter) return NULL;
+
+    for (;;) {
+        while (iter->left) iter = iter->left;
+        if (!iter->right) return iter;
+        iter = iter->right;
+    }
+}
+
+static inline struct rb_entry *rb_postorder_next(struct rb_entry *iter)
+{
+    if (!iter->parent) return NULL;
+    if (iter == iter->parent->right || !iter->parent->right) return iter->parent;
+    return rb_postorder_head(iter->parent->right);
+}
+
+/* iterate through the tree */
+#define RB_FOR_EACH(cursor, tree) \
+    for ((cursor) = rb_head((tree)->root); (cursor); (cursor) = rb_next(cursor))
+
+/* iterate through the tree using a tree entry */
+#define RB_FOR_EACH_ENTRY(elem, tree, type, field) \
+    for ((elem) = RB_ENTRY_VALUE(rb_head((tree)->root), type, field); \
+         (elem) != RB_ENTRY_VALUE(0, type, field); \
+         (elem) = RB_ENTRY_VALUE(rb_next(&elem->field), type, field))
+
+/* iterate through the tree using using postorder, making it safe to free the entry */
+#define RB_FOR_EACH_DESTRUCTOR(cursor, cursor2, tree) \
+    for ((cursor) = rb_postorder_head((tree)->root); \
+         (cursor) && (((cursor2) = rb_postorder_next(cursor)) || 1); \
+         (cursor) = (cursor2))
+
+/* iterate through the tree using a tree entry and postorder, making it safe to free the entry */
+#define RB_FOR_EACH_ENTRY_DESTRUCTOR(elem, elem2, tree, type, field) \
+    for ((elem) = RB_ENTRY_VALUE(rb_postorder_head((tree)->root), type, field); \
+         (elem) != WINE_RB_ENTRY_VALUE(0, type, field) \
+             && (((elem2) = RB_ENTRY_VALUE(rb_postorder_next(&(elem)->field), type, field)) || 1); \
+         (elem) = (elem2))
+
+
+static inline void rb_postorder(struct rb_tree *tree, rb_traverse_func *callback, void *context)
+{
+    struct rb_entry *iter, *next;
+    RB_FOR_EACH_DESTRUCTOR(iter, next, tree) callback(iter, context);
+}
+
+static inline void rb_init(struct rb_tree *tree, rb_compare_func compare)
+{
+    tree->compare = compare;
+    tree->root = NULL;
+}
+
+static inline void rb_for_each_entry(struct rb_tree *tree, rb_traverse_func *callback, void *context)
+{
+    struct rb_entry *iter;
+    RB_FOR_EACH(iter, tree) callback(iter, context);
+}
+
+static inline void rb_clear(struct rb_tree *tree, rb_traverse_func *callback, void *context)
+{
+    /* Note that we use postorder here because the callback will likely free the entry. */
+    if (callback) rb_postorder(tree, callback, context);
+    tree->root = NULL;
+}
+
+static inline void rb_destroy(struct rb_tree *tree, rb_traverse_func *callback, void *context)
+{
+    rb_clear(tree, callback, context);
+}
+
+static inline struct rb_entry *rb_get(const struct rb_tree *tree, const void *key)
+{
+    struct rb_entry *entry = tree->root;
+    while (entry)
+    {
+        int c = tree->compare(key, entry);
+        if (!c) return entry;
+        entry = c < 0 ? entry->left : entry->right;
+    }
+    return NULL;
+}
+
+static inline int rb_put(struct rb_tree *tree, const void *key, struct rb_entry *entry)
+{
+    struct rb_entry **iter = &tree->root, *parent = tree->root;
+
+    while (*iter)
+    {
+        int c;
+
+        parent = *iter;
+        c = tree->compare(key, parent);
+        if (!c) return -1;
+        else if (c < 0) iter = &parent->left;
+        else iter = &parent->right;
+    }
+
+    entry->flags = RB_FLAG_RED;
+    entry->parent = parent;
+    entry->left = NULL;
+    entry->right = NULL;
+    *iter = entry;
+
+    while (rb_is_red(entry->parent))
+    {
+        if (entry->parent == entry->parent->parent->left)
+        {
+            if (rb_is_red(entry->parent->parent->right))
+            {
+                rb_flip_color(entry->parent->parent);
+                entry = entry->parent->parent;
+            }
+            else
+            {
+                if (entry == entry->parent->right)
+                {
+                    entry = entry->parent;
+                    rb_rotate_left(tree, entry);
+                }
+                entry->parent->flags &= ~RB_FLAG_RED;
+                entry->parent->parent->flags |= RB_FLAG_RED;
+                rb_rotate_right(tree, entry->parent->parent);
+            }
+        }
+        else
+        {
+            if (rb_is_red(entry->parent->parent->left))
+            {
+                rb_flip_color(entry->parent->parent);
+                entry = entry->parent->parent;
+            }
+            else
+            {
+                if (entry == entry->parent->left)
+                {
+                    entry = entry->parent;
+                    rb_rotate_right(tree, entry);
+                }
+                entry->parent->flags &= ~RB_FLAG_RED;
+                entry->parent->parent->flags |= RB_FLAG_RED;
+                rb_rotate_left(tree, entry->parent->parent);
+            }
+        }
+    }
+
+    tree->root->flags &= ~RB_FLAG_RED;
+
+    return 0;
+}
+
+static inline void rb_remove(struct rb_tree *tree, struct rb_entry *entry)
+{
+    struct rb_entry *iter, *child, *parent, *w;
+    int need_fixup;
+
+    if (entry->right && entry->left)
+        for(iter = entry->right; iter->left; iter = iter->left);
+    else
+        iter = entry;
+
+    child = iter->left ? iter->left : iter->right;
+
+    if (!iter->parent)
+        tree->root = child;
+    else if (iter == iter->parent->left)
+        iter->parent->left = child;
+    else
+        iter->parent->right = child;
+
+    if (child) child->parent = iter->parent;
+    parent = iter->parent;
+
+    need_fixup = !rb_is_red(iter);
+
+    if (entry != iter)
+    {
+        *iter = *entry;
+        if (!iter->parent)
+            tree->root = iter;
+        else if (entry == iter->parent->left)
+            iter->parent->left = iter;
+        else
+            iter->parent->right = iter;
+
+        if (iter->right) iter->right->parent = iter;
+        if (iter->left)  iter->left->parent = iter;
+        if (parent == entry) parent = iter;
+    }
+
+    if (need_fixup)
+    {
+        while (parent && !rb_is_red(child))
+        {
+            if (child == parent->left)
+            {
+                w = parent->right;
+                if (rb_is_red(w))
+                {
+                    w->flags &= ~RB_FLAG_RED;
+                    parent->flags |= RB_FLAG_RED;
+                    rb_rotate_left(tree, parent);
+                    w = parent->right;
+                }
+                if (rb_is_red(w->left) || rb_is_red(w->right))
+                {
+                    if (!rb_is_red(w->right))
+                    {
+                        w->left->flags &= ~RB_FLAG_RED;
+                        w->flags |= RB_FLAG_RED;
+                        rb_rotate_right(tree, w);
+                        w = parent->right;
+                    }
+                    w->flags = (w->flags & ~RB_FLAG_RED) | (parent->flags & RB_FLAG_RED);
+                    parent->flags &= ~RB_FLAG_RED;
+                    if (w->right)
+                        w->right->flags &= ~RB_FLAG_RED;
+                    rb_rotate_left(tree, parent);
+                    child = NULL;
+                    break;
+                }
+            }
+            else
+            {
+                w = parent->left;
+                if (rb_is_red(w))
+                {
+                    w->flags &= ~RB_FLAG_RED;
+                    parent->flags |= RB_FLAG_RED;
+                    rb_rotate_right(tree, parent);
+                    w = parent->left;
+                }
+                if (rb_is_red(w->left) || rb_is_red(w->right))
+                {
+                    if (!rb_is_red(w->left))
+                    {
+                        w->right->flags &= ~RB_FLAG_RED;
+                        w->flags |= RB_FLAG_RED;
+                        rb_rotate_left(tree, w);
+                        w = parent->left;
+                    }
+                    w->flags = (w->flags & ~RB_FLAG_RED) | (parent->flags & RB_FLAG_RED);
+                    parent->flags &= ~RB_FLAG_RED;
+                    if (w->left)
+                        w->left->flags &= ~RB_FLAG_RED;
+                    rb_rotate_right(tree, parent);
+                    child = NULL;
+                    break;
+                }
+            }
+            w->flags |= RB_FLAG_RED;
+            child = parent;
+            parent = child->parent;
+        }
+        if (child) child->flags &= ~RB_FLAG_RED;
+    }
+
+    if (tree->root) tree->root->flags &= ~RB_FLAG_RED;
+}
+
+static inline void rb_remove_key(struct rb_tree *tree, const void *key)
+{
+    struct rb_entry *entry = rb_get(tree, key);
+    if (entry) rb_remove(tree, entry);
+}
+
+#endif  /* __WINE_WINE_RBTREE_H */
diff --git a/libs/vkd3d/include/private/vkd3d_common.h b/libs/vkd3d/include/private/vkd3d_common.h
index 6b5cdf8cf2c..e9bff2fbba3 100644
--- a/libs/vkd3d/include/private/vkd3d_common.h
+++ b/libs/vkd3d/include/private/vkd3d_common.h
@@ -49,17 +49,38 @@
         ((uint32_t)(ch0) | ((uint32_t)(ch1) << 8) \
         | ((uint32_t)(ch2) << 16) | ((uint32_t)(ch3) << 24))
 
+#define TAG_AON9 VKD3D_MAKE_TAG('A', 'o', 'n', '9')
+#define TAG_DXBC VKD3D_MAKE_TAG('D', 'X', 'B', 'C')
+#define TAG_DXIL VKD3D_MAKE_TAG('D', 'X', 'I', 'L')
+#define TAG_ISG1 VKD3D_MAKE_TAG('I', 'S', 'G', '1')
+#define TAG_ISGN VKD3D_MAKE_TAG('I', 'S', 'G', 'N')
+#define TAG_OSG1 VKD3D_MAKE_TAG('O', 'S', 'G', '1')
+#define TAG_OSG5 VKD3D_MAKE_TAG('O', 'S', 'G', '5')
+#define TAG_OSGN VKD3D_MAKE_TAG('O', 'S', 'G', 'N')
+#define TAG_PCSG VKD3D_MAKE_TAG('P', 'C', 'S', 'G')
+#define TAG_PSG1 VKD3D_MAKE_TAG('P', 'S', 'G', '1')
+#define TAG_RD11 VKD3D_MAKE_TAG('R', 'D', '1', '1')
+#define TAG_RDEF VKD3D_MAKE_TAG('R', 'D', 'E', 'F')
+#define TAG_RTS0 VKD3D_MAKE_TAG('R', 'T', 'S', '0')
+#define TAG_SDBG VKD3D_MAKE_TAG('S', 'D', 'B', 'G')
+#define TAG_SHDR VKD3D_MAKE_TAG('S', 'H', 'D', 'R')
+#define TAG_SHEX VKD3D_MAKE_TAG('S', 'H', 'E', 'X')
+#define TAG_STAT VKD3D_MAKE_TAG('S', 'T', 'A', 'T')
+#define TAG_TEXT VKD3D_MAKE_TAG('T', 'E', 'X', 'T')
+#define TAG_XNAP VKD3D_MAKE_TAG('X', 'N', 'A', 'P')
+#define TAG_XNAS VKD3D_MAKE_TAG('X', 'N', 'A', 'S')
+
 static inline size_t align(size_t addr, size_t alignment)
 {
     return (addr + (alignment - 1)) & ~(alignment - 1);
 }
 
-#ifdef __GNUC__
+#if defined(__GNUC__) || defined(__clang__)
 # define VKD3D_NORETURN __attribute__((noreturn))
 # ifdef __MINGW_PRINTF_FORMAT
 #  define VKD3D_PRINTF_FUNC(fmt, args) __attribute__((format(__MINGW_PRINTF_FORMAT, fmt, args)))
 # else
-#  define VKD3D_PRINTF_FUNC(fmt, args) /* __attribute__((format(printf, fmt, args))) */
+#  define VKD3D_PRINTF_FUNC(fmt, args) __attribute__((format(printf, fmt, args)))
 # endif
 # define VKD3D_UNUSED __attribute__((unused))
 # define VKD3D_UNREACHABLE __builtin_unreachable()
@@ -86,7 +107,7 @@ static inline unsigned int vkd3d_popcount(unsigned int v)
 {
 #ifdef _MSC_VER
     return __popcnt(v);
-#elif defined(__MINGW32__)
+#elif defined(HAVE_BUILTIN_POPCOUNT)
     return __builtin_popcount(v);
 #else
     v -= (v >> 1) & 0x55555555;
diff --git a/libs/vkd3d/include/private/vkd3d_test.h b/libs/vkd3d/include/private/vkd3d_test.h
new file mode 100644
index 00000000000..081443c4fa6
--- /dev/null
+++ b/libs/vkd3d/include/private/vkd3d_test.h
@@ -0,0 +1,432 @@
+/*
+ * Copyright 2016 Józef Kucia for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __VKD3D_TEST_H
+#define __VKD3D_TEST_H
+
+#include "vkd3d_common.h"
+#include <assert.h>
+#include <inttypes.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+extern const char *vkd3d_test_name;
+extern const char *vkd3d_test_platform;
+
+static void vkd3d_test_start_todo(bool is_todo);
+static int vkd3d_test_loop_todo(void);
+static void vkd3d_test_end_todo(void);
+
+#define START_TEST(name) \
+        const char *vkd3d_test_name = #name; \
+        static void vkd3d_test_main(int argc, char **argv)
+
+/*
+ * Use assert_that() for conditions that should always be true.
+ * todo_if() and bug_if() do not influence assert_that().
+ */
+#define assert_that assert_that_(__LINE__)
+
+#define ok ok_(__LINE__)
+
+#define skip skip_(__LINE__)
+
+#define trace trace_(__LINE__)
+
+#define assert_that_(line) \
+        do { \
+        unsigned int vkd3d_line = line; \
+        VKD3D_TEST_ASSERT_THAT
+
+#define VKD3D_TEST_ASSERT_THAT(...) \
+        vkd3d_test_assert_that(vkd3d_line, __VA_ARGS__); } while (0)
+
+#define ok_(line) \
+        do { \
+        unsigned int vkd3d_line = line; \
+        VKD3D_TEST_OK
+
+#define VKD3D_TEST_OK(...) \
+        vkd3d_test_ok(vkd3d_line, __VA_ARGS__); } while (0)
+
+#define todo_(line) \
+        do { \
+        unsigned int vkd3d_line = line; \
+        VKD3D_TEST_TODO
+
+#define VKD3D_TEST_TODO(...) \
+        vkd3d_test_todo(vkd3d_line, __VA_ARGS__); } while (0)
+
+#define skip_(line) \
+        do { \
+        unsigned int vkd3d_line = line; \
+        VKD3D_TEST_SKIP
+
+#define VKD3D_TEST_SKIP(...) \
+        vkd3d_test_skip(vkd3d_line, __VA_ARGS__); } while (0)
+
+#define trace_(line) \
+        do { \
+        unsigned int vkd3d_line = line; \
+        VKD3D_TEST_TRACE
+
+#define VKD3D_TEST_TRACE(...) \
+        vkd3d_test_trace(vkd3d_line, __VA_ARGS__); } while (0)
+
+#define todo_if(is_todo) \
+    for (vkd3d_test_start_todo(is_todo); vkd3d_test_loop_todo(); vkd3d_test_end_todo())
+
+#define bug_if(is_bug) \
+    for (vkd3d_test_start_bug(is_bug); vkd3d_test_loop_bug(); vkd3d_test_end_bug())
+
+#define todo todo_if(true)
+
+struct vkd3d_test_state
+{
+    LONG success_count;
+    LONG failure_count;
+    LONG skip_count;
+    LONG todo_count;
+    LONG todo_success_count;
+    LONG bug_count;
+
+    unsigned int debug_level;
+
+    unsigned int todo_level;
+    bool todo_do_loop;
+
+    unsigned int bug_level;
+    bool bug_do_loop;
+    bool bug_enabled;
+
+    const char *test_name_filter;
+    char context[8][128];
+    unsigned int context_count;
+};
+extern struct vkd3d_test_state vkd3d_test_state;
+
+static bool
+vkd3d_test_platform_is_windows(void)
+{
+    return !strcmp(vkd3d_test_platform, "windows");
+}
+
+static inline bool
+broken(bool condition)
+{
+    return condition && vkd3d_test_platform_is_windows();
+}
+
+static void vkd3d_test_printf(unsigned int line, const char *msg)
+{
+    unsigned int i;
+
+    printf("%s:%u: ", vkd3d_test_name, line);
+    for (i = 0; i < vkd3d_test_state.context_count; ++i)
+        printf("%s: ", vkd3d_test_state.context[i]);
+    printf("%s", msg);
+}
+
+static void
+vkd3d_test_check_assert_that(unsigned int line, bool result, const char *fmt, va_list args)
+{
+    if (result)
+    {
+        InterlockedIncrement(&vkd3d_test_state.success_count);
+        if (vkd3d_test_state.debug_level > 1)
+            vkd3d_test_printf(line, "Test succeeded.\n");
+    }
+    else
+    {
+        InterlockedIncrement(&vkd3d_test_state.failure_count);
+        vkd3d_test_printf(line, "Test failed: ");
+        vprintf(fmt, args);
+    }
+}
+
+static void VKD3D_PRINTF_FUNC(3, 4) VKD3D_UNUSED
+vkd3d_test_assert_that(unsigned int line, bool result, const char *fmt, ...)
+{
+    va_list args;
+
+    va_start(args, fmt);
+    vkd3d_test_check_assert_that(line, result, fmt, args);
+    va_end(args);
+}
+
+static void
+vkd3d_test_check_ok(unsigned int line, bool result, const char *fmt, va_list args)
+{
+    bool is_todo = vkd3d_test_state.todo_level && !vkd3d_test_platform_is_windows();
+    bool is_bug = vkd3d_test_state.bug_level && !vkd3d_test_platform_is_windows();
+
+    if (is_bug && vkd3d_test_state.bug_enabled)
+    {
+        InterlockedIncrement(&vkd3d_test_state.bug_count);
+        if (is_todo)
+            result = !result;
+        if (result)
+            vkd3d_test_printf(line, "Fixed bug: ");
+        else
+            vkd3d_test_printf(line, "Bug: ");
+        vprintf(fmt, args);
+    }
+    else if (is_todo)
+    {
+        if (result)
+        {
+            InterlockedIncrement(&vkd3d_test_state.todo_success_count);
+            vkd3d_test_printf(line, "Todo succeeded: ");
+        }
+        else
+        {
+            InterlockedIncrement(&vkd3d_test_state.todo_count);
+            vkd3d_test_printf(line, "Todo: ");
+        }
+        vprintf(fmt, args);
+    }
+    else
+    {
+        vkd3d_test_check_assert_that(line, result, fmt, args);
+    }
+}
+
+static void VKD3D_PRINTF_FUNC(3, 4) VKD3D_UNUSED
+vkd3d_test_ok(unsigned int line, bool result, const char *fmt, ...)
+{
+    va_list args;
+
+    va_start(args, fmt);
+    vkd3d_test_check_ok(line, result, fmt, args);
+    va_end(args);
+}
+
+static void VKD3D_PRINTF_FUNC(2, 3) VKD3D_UNUSED
+vkd3d_test_skip(unsigned int line, const char *fmt, ...)
+{
+    va_list args;
+    va_start(args, fmt);
+    vkd3d_test_printf(line, "Test skipped: ");
+    vprintf(fmt, args);
+    va_end(args);
+    InterlockedIncrement(&vkd3d_test_state.skip_count);
+}
+
+static void VKD3D_PRINTF_FUNC(2, 3) VKD3D_UNUSED
+vkd3d_test_trace(unsigned int line, const char *fmt, ...)
+{
+    va_list args;
+    va_start(args, fmt);
+    vkd3d_test_printf(line, "");
+    vprintf(fmt, args);
+    va_end(args);
+}
+
+static void VKD3D_PRINTF_FUNC(1, 2) VKD3D_UNUSED
+vkd3d_test_debug(const char *fmt, ...)
+{
+    char buffer[512];
+    va_list args;
+    int size;
+
+    size = snprintf(buffer, sizeof(buffer), "%s: ", vkd3d_test_name);
+    if (0 < size && size < sizeof(buffer))
+    {
+        va_start(args, fmt);
+        vsnprintf(buffer + size, sizeof(buffer) - size, fmt, args);
+        va_end(args);
+    }
+    buffer[sizeof(buffer) - 1] = '\0';
+
+#ifdef _WIN32
+    OutputDebugStringA(buffer);
+#endif
+
+    if (vkd3d_test_state.debug_level > 0)
+        printf("%s\n", buffer);
+}
+
+#ifndef VKD3D_TEST_NO_DEFS
+const char *vkd3d_test_platform = "other";
+struct vkd3d_test_state vkd3d_test_state;
+
+static void vkd3d_test_main(int argc, char **argv);
+
+int main(int argc, char **argv)
+{
+    const char *test_filter = getenv("VKD3D_TEST_FILTER");
+    const char *debug_level = getenv("VKD3D_TEST_DEBUG");
+    char *test_platform = getenv("VKD3D_TEST_PLATFORM");
+    const char *bug = getenv("VKD3D_TEST_BUG");
+
+    memset(&vkd3d_test_state, 0, sizeof(vkd3d_test_state));
+    vkd3d_test_state.debug_level = debug_level ? atoi(debug_level) : 0;
+    vkd3d_test_state.bug_enabled = bug ? atoi(bug) : true;
+    vkd3d_test_state.test_name_filter = test_filter;
+
+    if (test_platform)
+    {
+        test_platform = strdup(test_platform);
+        vkd3d_test_platform = test_platform;
+    }
+
+    if (vkd3d_test_state.debug_level > 1)
+        printf("Test platform: '%s'.\n", vkd3d_test_platform);
+
+    vkd3d_test_main(argc, argv);
+
+    printf("%s: %lu tests executed (%lu failures, %lu skipped, %lu todo, %lu bugs).\n",
+            vkd3d_test_name,
+            (unsigned long)(vkd3d_test_state.success_count
+            + vkd3d_test_state.failure_count + vkd3d_test_state.todo_count
+            + vkd3d_test_state.todo_success_count),
+            (unsigned long)(vkd3d_test_state.failure_count
+            + vkd3d_test_state.todo_success_count),
+            (unsigned long)vkd3d_test_state.skip_count,
+            (unsigned long)vkd3d_test_state.todo_count,
+            (unsigned long)vkd3d_test_state.bug_count);
+
+    if (test_platform)
+        free(test_platform);
+
+    return vkd3d_test_state.failure_count || vkd3d_test_state.todo_success_count;
+}
+
+#ifdef _WIN32
+static char *vkd3d_test_strdupWtoA(WCHAR *str)
+{
+    char *out;
+    int len;
+
+    if (!(len = WideCharToMultiByte(CP_ACP, 0, str, -1, NULL, 0, NULL, NULL)))
+        return NULL;
+    if (!(out = malloc(len)))
+        return NULL;
+    WideCharToMultiByte(CP_ACP, 0, str, -1, out, len, NULL, NULL);
+
+    return out;
+}
+
+static bool running_under_wine(void)
+{
+    HMODULE module = GetModuleHandleA("ntdll.dll");
+    return module && GetProcAddress(module, "wine_server_call");
+}
+
+int wmain(int argc, WCHAR **wargv)
+{
+    char **argv;
+    int i, ret;
+
+    argv = malloc(argc * sizeof(*argv));
+    assert(argv);
+    for (i = 0; i < argc; ++i)
+    {
+        if (!(argv[i] = vkd3d_test_strdupWtoA(wargv[i])))
+            break;
+    }
+    assert(i == argc);
+
+    vkd3d_test_platform = running_under_wine() ? "wine" : "windows";
+
+    ret = main(argc, argv);
+
+    for (i = 0; i < argc; ++i)
+        free(argv[i]);
+    free(argv);
+
+    return ret;
+}
+#endif  /* _WIN32 */
+#endif /* VKD3D_TEST_NO_DEFS */
+
+typedef void (*vkd3d_test_pfn)(void);
+
+static inline void vkd3d_run_test(const char *name, vkd3d_test_pfn test_pfn)
+{
+    if (vkd3d_test_state.test_name_filter && !strstr(name, vkd3d_test_state.test_name_filter))
+        return;
+
+    vkd3d_test_debug("%s", name);
+    test_pfn();
+}
+
+static inline void vkd3d_test_start_todo(bool is_todo)
+{
+    vkd3d_test_state.todo_level = (vkd3d_test_state.todo_level << 1) | is_todo;
+    vkd3d_test_state.todo_do_loop = true;
+}
+
+static inline int vkd3d_test_loop_todo(void)
+{
+    bool do_loop = vkd3d_test_state.todo_do_loop;
+    vkd3d_test_state.todo_do_loop = false;
+    return do_loop;
+}
+
+static inline void vkd3d_test_end_todo(void)
+{
+    vkd3d_test_state.todo_level >>= 1;
+}
+
+static inline void vkd3d_test_start_bug(bool is_bug)
+{
+    vkd3d_test_state.bug_level = (vkd3d_test_state.bug_level << 1) | is_bug;
+    vkd3d_test_state.bug_do_loop = true;
+}
+
+static inline int vkd3d_test_loop_bug(void)
+{
+    bool do_loop = vkd3d_test_state.bug_do_loop;
+    vkd3d_test_state.bug_do_loop = false;
+    return do_loop;
+}
+
+static inline void vkd3d_test_end_bug(void)
+{
+    vkd3d_test_state.bug_level >>= 1;
+}
+
+static inline void vkd3d_test_push_context(const char *fmt, ...)
+{
+    va_list args;
+
+    if (vkd3d_test_state.context_count < ARRAY_SIZE(vkd3d_test_state.context))
+    {
+        va_start(args, fmt);
+        vsnprintf(vkd3d_test_state.context[vkd3d_test_state.context_count],
+                sizeof(vkd3d_test_state.context), fmt, args);
+        va_end(args);
+        vkd3d_test_state.context[vkd3d_test_state.context_count][sizeof(vkd3d_test_state.context[0]) - 1] = '\0';
+    }
+    ++vkd3d_test_state.context_count;
+}
+
+static inline void vkd3d_test_pop_context(void)
+{
+    if (vkd3d_test_state.context_count)
+        --vkd3d_test_state.context_count;
+}
+
+#define run_test(test_pfn) \
+        vkd3d_run_test(#test_pfn, test_pfn)
+
+#endif  /* __VKD3D_TEST_H */
diff --git a/libs/vkd3d/include/vkd3d_d3d9types.h b/libs/vkd3d/include/vkd3d_d3d9types.h
new file mode 100644
index 00000000000..75d0461409d
--- /dev/null
+++ b/libs/vkd3d/include/vkd3d_d3d9types.h
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2002-2003 Jason Edmeades
+ * Copyright 2002-2003 Raphael Junqueira
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __VKD3D_D3D9TYPES_H
+#define __VKD3D_D3D9TYPES_H
+#ifndef _d3d9TYPES_H_
+
+#ifndef MAKEFOURCC
+#define MAKEFOURCC(ch0, ch1, ch2, ch3)  \
+    ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |  \
+    ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
+#endif
+
+#define D3DSI_INSTLENGTH_SHIFT  24
+
+#define D3DSP_DCL_USAGE_SHIFT       0
+#define D3DSP_DCL_USAGEINDEX_SHIFT  16
+#define D3DSP_DSTMOD_SHIFT          20
+
+#define D3DSP_SRCMOD_SHIFT      24
+
+#define D3DSP_REGTYPE_SHIFT     28
+#define D3DSP_REGTYPE_SHIFT2    8
+#define D3DSP_REGTYPE_MASK      (0x7 << D3DSP_REGTYPE_SHIFT)
+#define D3DSP_REGTYPE_MASK2     0x00001800
+
+#define D3DSP_WRITEMASK_0       0x00010000
+#define D3DSP_WRITEMASK_1       0x00020000
+#define D3DSP_WRITEMASK_2       0x00040000
+#define D3DSP_WRITEMASK_3       0x00080000
+#define D3DSP_WRITEMASK_ALL     0x000f0000
+
+#define D3DPS_VERSION(major, minor) (0xffff0000 | ((major) << 8) | (minor))
+#define D3DVS_VERSION(major, minor) (0xfffe0000 | ((major) << 8) | (minor))
+
+typedef enum _D3DDECLUSAGE
+{
+    D3DDECLUSAGE_POSITION       = 0x0,
+    D3DDECLUSAGE_BLENDWEIGHT    = 0x1,
+    D3DDECLUSAGE_BLENDINDICES   = 0x2,
+    D3DDECLUSAGE_NORMAL         = 0x3,
+    D3DDECLUSAGE_PSIZE          = 0x4,
+    D3DDECLUSAGE_TEXCOORD       = 0x5,
+    D3DDECLUSAGE_TANGENT        = 0x6,
+    D3DDECLUSAGE_BINORMAL       = 0x7,
+    D3DDECLUSAGE_TESSFACTOR     = 0x8,
+    D3DDECLUSAGE_POSITIONT      = 0x9,
+    D3DDECLUSAGE_COLOR          = 0xa,
+    D3DDECLUSAGE_FOG            = 0xb,
+    D3DDECLUSAGE_DEPTH          = 0xc,
+    D3DDECLUSAGE_SAMPLE         = 0xd,
+} D3DDECLUSAGE;
+
+typedef enum _D3DSHADER_INSTRUCTION_OPCODE_TYPE
+{
+    D3DSIO_NOP          = 0x00,
+    D3DSIO_MOV          = 0x01,
+    D3DSIO_ADD          = 0x02,
+    D3DSIO_SUB          = 0x03,
+    D3DSIO_MAD          = 0x04,
+    D3DSIO_MUL          = 0x05,
+    D3DSIO_RCP          = 0x06,
+    D3DSIO_RSQ          = 0x07,
+    D3DSIO_DP3          = 0x08,
+    D3DSIO_DP4          = 0x09,
+    D3DSIO_MIN          = 0x0a,
+    D3DSIO_MAX          = 0x0b,
+    D3DSIO_SLT          = 0x0c,
+    D3DSIO_SGE          = 0x0d,
+    D3DSIO_EXP          = 0x0e,
+    D3DSIO_LOG          = 0x0f,
+    D3DSIO_LIT          = 0x10,
+    D3DSIO_DST          = 0x11,
+    D3DSIO_LRP          = 0x12,
+    D3DSIO_FRC          = 0x13,
+    D3DSIO_M4x4         = 0x14,
+    D3DSIO_M4x3         = 0x15,
+    D3DSIO_M3x4         = 0x16,
+    D3DSIO_M3x3         = 0x17,
+    D3DSIO_M3x2         = 0x18,
+    D3DSIO_CALL         = 0x19,
+    D3DSIO_CALLNZ       = 0x1a,
+    D3DSIO_LOOP         = 0x1b,
+    D3DSIO_RET          = 0x1c,
+    D3DSIO_ENDLOOP      = 0x1d,
+    D3DSIO_LABEL        = 0x1e,
+    D3DSIO_DCL          = 0x1f,
+    D3DSIO_POW          = 0x20,
+    D3DSIO_CRS          = 0x21,
+    D3DSIO_SGN          = 0x22,
+    D3DSIO_ABS          = 0x23,
+    D3DSIO_NRM          = 0x24,
+    D3DSIO_SINCOS       = 0x25,
+    D3DSIO_REP          = 0x26,
+    D3DSIO_ENDREP       = 0x27,
+    D3DSIO_IF           = 0x28,
+    D3DSIO_IFC          = 0x29,
+    D3DSIO_ELSE         = 0x2a,
+    D3DSIO_ENDIF        = 0x2b,
+    D3DSIO_BREAK        = 0x2c,
+    D3DSIO_BREAKC       = 0x2d,
+    D3DSIO_MOVA         = 0x2e,
+    D3DSIO_DEFB         = 0x2f,
+    D3DSIO_DEFI         = 0x30,
+
+    D3DSIO_TEXCOORD     = 0x40,
+    D3DSIO_TEXKILL      = 0x41,
+    D3DSIO_TEX          = 0x42,
+    D3DSIO_TEXBEM       = 0x43,
+    D3DSIO_TEXBEML      = 0x44,
+    D3DSIO_TEXREG2AR    = 0x45,
+    D3DSIO_TEXREG2GB    = 0x46,
+    D3DSIO_TEXM3x2PAD   = 0x47,
+    D3DSIO_TEXM3x2TEX   = 0x48,
+    D3DSIO_TEXM3x3PAD   = 0x49,
+    D3DSIO_TEXM3x3TEX   = 0x4a,
+    D3DSIO_TEXM3x3DIFF  = 0x4b,
+    D3DSIO_TEXM3x3SPEC  = 0x4c,
+    D3DSIO_TEXM3x3VSPEC = 0x4d,
+    D3DSIO_EXPP         = 0x4e,
+    D3DSIO_LOGP         = 0x4f,
+    D3DSIO_CND          = 0x50,
+    D3DSIO_DEF          = 0x51,
+    D3DSIO_TEXREG2RGB   = 0x52,
+    D3DSIO_TEXDP3TEX    = 0x53,
+    D3DSIO_TEXM3x2DEPTH = 0x54,
+    D3DSIO_TEXDP3       = 0x55,
+    D3DSIO_TEXM3x3      = 0x56,
+    D3DSIO_TEXDEPTH     = 0x57,
+    D3DSIO_CMP          = 0x58,
+    D3DSIO_BEM          = 0x59,
+    D3DSIO_DP2ADD       = 0x5a,
+    D3DSIO_DSX          = 0x5b,
+    D3DSIO_DSY          = 0x5c,
+    D3DSIO_TEXLDD       = 0x5d,
+    D3DSIO_SETP         = 0x5e,
+    D3DSIO_TEXLDL       = 0x5f,
+    D3DSIO_BREAKP       = 0x60,
+
+    D3DSIO_PHASE        = 0xfffd,
+    D3DSIO_COMMENT      = 0xfffe,
+    D3DSIO_END          = 0xffff,
+
+    D3DSIO_FORCE_DWORD  = 0x7fffffff,
+} D3DSHADER_INSTRUCTION_OPCODE_TYPE;
+
+typedef enum _D3DSHADER_PARAM_DSTMOD_TYPE
+{
+    D3DSPDM_NONE                = 0 << D3DSP_DSTMOD_SHIFT,
+    D3DSPDM_SATURATE            = 1 << D3DSP_DSTMOD_SHIFT,
+    D3DSPDM_PARTIALPRECISION    = 2 << D3DSP_DSTMOD_SHIFT,
+    D3DSPDM_MSAMPCENTROID       = 4 << D3DSP_DSTMOD_SHIFT,
+
+    D3DSPDM_FORCE_DWORD         = 0x7fffffff,
+} D3DSHADER_PARAM_DSTMOD_TYPE;
+
+typedef enum _D3DSHADER_PARAM_REGISTER_TYPE
+{
+    D3DSPR_TEMP         = 0x00,
+    D3DSPR_INPUT        = 0x01,
+    D3DSPR_CONST        = 0x02,
+    D3DSPR_ADDR         = 0x03,
+    D3DSPR_TEXTURE      = 0x03,
+    D3DSPR_RASTOUT      = 0x04,
+    D3DSPR_ATTROUT      = 0x05,
+    D3DSPR_TEXCRDOUT    = 0x06,
+    D3DSPR_OUTPUT       = 0x06,
+    D3DSPR_CONSTINT     = 0x07,
+    D3DSPR_COLOROUT     = 0x08,
+    D3DSPR_DEPTHOUT     = 0x09,
+    D3DSPR_SAMPLER      = 0x0a,
+    D3DSPR_CONST2       = 0x0b,
+    D3DSPR_CONST3       = 0x0c,
+    D3DSPR_CONST4       = 0x0d,
+    D3DSPR_CONSTBOOL    = 0x0e,
+    D3DSPR_LOOP         = 0x0f,
+    D3DSPR_TEMPFLOAT16  = 0x10,
+    D3DSPR_MISCTYPE     = 0x11,
+    D3DSPR_LABEL        = 0x12,
+    D3DSPR_PREDICATE    = 0x13,
+
+    D3DSPR_FORCE_DWORD  = 0x7fffffff,
+} D3DSHADER_PARAM_REGISTER_TYPE;
+
+typedef enum _D3DSHADER_PARAM_SRCMOD_TYPE
+{
+    D3DSPSM_NONE        = 0x0 << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_NEG         = 0x1 << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_BIAS        = 0x2 << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_BIASNEG     = 0x3 << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_SIGN        = 0x4 << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_SIGNNEG     = 0x5 << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_COMP        = 0x6 << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_X2          = 0x7 << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_X2NEG       = 0x8 << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_DZ          = 0x9 << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_DW          = 0xa << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_ABS         = 0xb << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_ABSNEG      = 0xc << D3DSP_SRCMOD_SHIFT,
+    D3DSPSM_NOT         = 0xd << D3DSP_SRCMOD_SHIFT,
+
+    D3DSPSM_FORCE_DWORD = 0x7fffffff,
+} D3DSHADER_PARAM_SRCMOD_TYPE;
+
+typedef enum _D3DSHADER_MISCTYPE_OFFSETS
+{
+    D3DSMO_POSITION  = 0x0,
+    D3DSMO_FACE      = 0x1,
+} D3DSHADER_MISCTYPE_OFFSETS;
+
+typedef enum _D3DVS_RASTOUT_OFFSETS
+{
+    D3DSRO_POSITION     = 0x0,
+    D3DSRO_FOG          = 0x1,
+    D3DSRO_POINT_SIZE   = 0x2,
+
+    D3DSRO_FORCE_DWORD  = 0x7fffffff,
+} D3DVS_RASTOUT_OFFSETS;
+
+#endif  /* _d3d9TYPES_H_ */
+#endif  /* __VKD3D_D3D9TYPES_H */
diff --git a/libs/vkd3d/include/vkd3d_d3dcompiler.h b/libs/vkd3d/include/vkd3d_d3dcompiler.h
new file mode 100644
index 00000000000..c78cf25b955
--- /dev/null
+++ b/libs/vkd3d/include/vkd3d_d3dcompiler.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2010 Matteo Bruni for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __VKD3D_D3DCOMPILER_H
+#define __VKD3D_D3DCOMPILER_H
+#ifndef __D3DCOMPILER_H__
+
+#include <vkd3d_d3dcompiler_types.h>
+
+#define D3DCOMPILE_DEBUG                                0x00000001
+#define D3DCOMPILE_SKIP_VALIDATION                      0x00000002
+#define D3DCOMPILE_SKIP_OPTIMIZATION                    0x00000004
+#define D3DCOMPILE_PACK_MATRIX_ROW_MAJOR                0x00000008
+#define D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR             0x00000010
+#define D3DCOMPILE_PARTIAL_PRECISION                    0x00000020
+#define D3DCOMPILE_FORCE_VS_SOFTWARE_NO_OPT             0x00000040
+#define D3DCOMPILE_FORCE_PS_SOFTWARE_NO_OPT             0x00000080
+#define D3DCOMPILE_NO_PRESHADER                         0x00000100
+#define D3DCOMPILE_AVOID_FLOW_CONTROL                   0x00000200
+#define D3DCOMPILE_PREFER_FLOW_CONTROL                  0x00000400
+#define D3DCOMPILE_ENABLE_STRICTNESS                    0x00000800
+#define D3DCOMPILE_ENABLE_BACKWARDS_COMPATIBILITY       0x00001000
+#define D3DCOMPILE_IEEE_STRICTNESS                      0x00002000
+#define D3DCOMPILE_OPTIMIZATION_LEVEL0                  0x00004000
+#define D3DCOMPILE_OPTIMIZATION_LEVEL1                  0x00000000
+#define D3DCOMPILE_OPTIMIZATION_LEVEL2                  0x0000c000
+#define D3DCOMPILE_OPTIMIZATION_LEVEL3                  0x00008000
+#define D3DCOMPILE_RESERVED16                           0x00010000
+#define D3DCOMPILE_RESERVED17                           0x00020000
+#define D3DCOMPILE_WARNINGS_ARE_ERRORS                  0x00040000
+#define D3DCOMPILE_RESOURCES_MAY_ALIAS                  0x00080000
+#define D3DCOMPILE_ENABLE_UNBOUNDED_DESCRIPTOR_TABLES   0x00100000
+#define D3DCOMPILE_ALL_RESOURCES_BOUND                  0x00200000
+#define D3DCOMPILE_DEBUG_NAME_FOR_SOURCE                0x00400000
+#define D3DCOMPILE_DEBUG_NAME_FOR_BINARY                0x00800000
+
+#define D3DCOMPILE_EFFECT_CHILD_EFFECT                  0x00000001
+#define D3DCOMPILE_EFFECT_ALLOW_SLOW_OPS                0x00000002
+
+#define D3DCOMPILE_FLAGS2_FORCE_ROOT_SIGNATURE_LATEST   0x00000000
+#define D3DCOMPILE_FLAGS2_FORCE_ROOT_SIGNATURE_1_0      0x00000010
+#define D3DCOMPILE_FLAGS2_FORCE_ROOT_SIGNATURE_1_1      0x00000020
+
+#define D3DCOMPILE_SECDATA_MERGE_UAV_SLOTS              0x00000001
+#define D3DCOMPILE_SECDATA_PRESERVE_TEMPLATE_SLOTS      0x00000002
+#define D3DCOMPILE_SECDATA_REQUIRE_TEMPLATE_MATCH       0x00000004
+
+typedef enum D3DCOMPILER_STRIP_FLAGS
+{
+    D3DCOMPILER_STRIP_REFLECTION_DATA = 0x00000001,
+    D3DCOMPILER_STRIP_DEBUG_INFO      = 0x00000002,
+    D3DCOMPILER_STRIP_TEST_BLOBS      = 0x00000004,
+    D3DCOMPILER_STRIP_PRIVATE_DATA    = 0x00000008,
+    D3DCOMPILER_STRIP_ROOT_SIGNATURE  = 0x00000010,
+    D3DCOMPILER_STRIP_FORCE_DWORD     = 0x7fffffff,
+} D3DCOMPILER_STRIP_FLAGS;
+
+HRESULT WINAPI D3DCompile(const void *data, SIZE_T data_size, const char *filename,
+        const D3D_SHADER_MACRO *macros, ID3DInclude *include, const char *entrypoint,
+        const char *profile, UINT flags, UINT effect_flags, ID3DBlob **shader, ID3DBlob **error_messages);
+HRESULT WINAPI D3DCompile2(const void *data, SIZE_T data_size, const char *filename,
+        const D3D_SHADER_MACRO *macros, ID3DInclude *include, const char *entrypoint,
+        const char *profile, UINT flags, UINT effect_flags, UINT secondary_flags,
+        const void *secondary_data, SIZE_T secondary_data_size, ID3DBlob **shader,
+        ID3DBlob **error_messages);
+HRESULT WINAPI D3DCreateBlob(SIZE_T size, ID3DBlob **blob);
+HRESULT WINAPI D3DGetBlobPart(const void *data, SIZE_T data_size, D3D_BLOB_PART part, UINT flags, ID3DBlob **blob);
+HRESULT WINAPI D3DGetDebugInfo(const void *data, SIZE_T data_size, ID3DBlob **blob);
+HRESULT WINAPI D3DGetInputAndOutputSignatureBlob(const void *data, SIZE_T data_size, ID3DBlob **blob);
+HRESULT WINAPI D3DGetInputSignatureBlob(const void *data, SIZE_T data_size, ID3DBlob **blob);
+HRESULT WINAPI D3DGetOutputSignatureBlob(const void *data, SIZE_T data_size, ID3DBlob **blob);
+HRESULT WINAPI D3DPreprocess(const void *data, SIZE_T size, const char *filename, const D3D_SHADER_MACRO *macros,
+        ID3DInclude *include, ID3DBlob **shader, ID3DBlob **error_messages);
+HRESULT WINAPI D3DStripShader(const void *data, SIZE_T data_size, UINT flags, ID3DBlob **blob);
+
+#endif /* __D3DCOMPILER_H__ */
+#endif /* __VKD3D_D3DCOMPILER_H */
diff --git a/libs/vkd3d/include/vkd3d_d3dcompiler_types.h b/libs/vkd3d/include/vkd3d_d3dcompiler_types.h
new file mode 100644
index 00000000000..b3a47cdd912
--- /dev/null
+++ b/libs/vkd3d/include/vkd3d_d3dcompiler_types.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2010 Matteo Bruni for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __VKD3D_D3DCOMPILER_TYPES_H
+#define __VKD3D_D3DCOMPILER_TYPES_H
+#ifndef __D3DCOMPILER_H__
+
+typedef enum D3D_BLOB_PART
+{
+    D3D_BLOB_INPUT_SIGNATURE_BLOB,
+    D3D_BLOB_OUTPUT_SIGNATURE_BLOB,
+    D3D_BLOB_INPUT_AND_OUTPUT_SIGNATURE_BLOB,
+    D3D_BLOB_PATCH_CONSTANT_SIGNATURE_BLOB,
+    D3D_BLOB_ALL_SIGNATURE_BLOB,
+    D3D_BLOB_DEBUG_INFO,
+    D3D_BLOB_LEGACY_SHADER,
+    D3D_BLOB_XNA_PREPASS_SHADER,
+    D3D_BLOB_XNA_SHADER,
+    D3D_BLOB_PDB,
+    D3D_BLOB_PRIVATE_DATA,
+    D3D_BLOB_ROOT_SIGNATURE,
+    D3D_BLOB_DEBUG_NAME,
+    D3D_BLOB_TEST_ALTERNATE_SHADER = 0x8000,
+    D3D_BLOB_TEST_COMPILE_DETAILS,
+    D3D_BLOB_TEST_COMPILE_PERF,
+    D3D_BLOB_TEST_COMPILE_REPORT
+} D3D_BLOB_PART;
+
+#endif /* __D3DCOMPILER_H__ */
+#endif /* __VKD3D_D3DCOMPILER_TYPES_H */
diff --git a/libs/vkd3d/include/vkd3d_shader.h b/libs/vkd3d/include/vkd3d_shader.h
index 01356ce3931..66a7de9b571 100644
--- a/libs/vkd3d/include/vkd3d_shader.h
+++ b/libs/vkd3d/include/vkd3d_shader.h
@@ -96,6 +96,11 @@ enum vkd3d_shader_structure_type
      * \since 1.9
      */
     VKD3D_SHADER_STRUCTURE_TYPE_VARYING_MAP_INFO,
+    /**
+     * The structure is a vkd3d_shader_scan_combined_resource_sampler_info structure.
+     * \since 1.10
+     */
+    VKD3D_SHADER_STRUCTURE_TYPE_SCAN_COMBINED_RESOURCE_SAMPLER_INFO,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_STRUCTURE_TYPE),
 };
@@ -154,6 +159,40 @@ enum vkd3d_shader_compile_option_pack_matrix_order
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_PACK_MATRIX_ORDER),
 };
 
+/** Individual options to enable various backward compatibility features. \since 1.10 */
+enum vkd3d_shader_compile_option_backward_compatibility
+{
+    /**
+     *  Causes compiler to convert SM1-3 semantics to corresponding System Value semantics,
+     *  when compiling HLSL sources for SM4+ targets.
+     *
+     *  This option does the following conversions:
+     *
+     *  - POSITION to SV_Position for vertex shader outputs, pixel shader inputs,
+     *    and geometry shader inputs and outputs;
+     *  - COLORN to SV_TargetN for pixel shader outputs;
+     *  - DEPTH to SV_Depth for pixel shader outputs.
+     */
+    VKD3D_SHADER_COMPILE_OPTION_BACKCOMPAT_MAP_SEMANTIC_NAMES = 0x00000001,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_BACKWARD_COMPATIBILITY),
+};
+
+/**
+ * Determines the origin of fragment coordinates.
+ *
+ * \since 1.10
+ */
+enum vkd3d_shader_compile_option_fragment_coordinate_origin
+{
+    /** Fragment coordinates originate from the upper-left. This is the
+     * default; it's also the only value supported by Vulkan environments. */
+    VKD3D_SHADER_COMPILE_OPTION_FRAGMENT_COORDINATE_ORIGIN_UPPER_LEFT = 0x00000000,
+    /** Fragment coordinates originate from the lower-left. This matches the
+     * traditional behaviour of OpenGL environments. */
+    VKD3D_SHADER_COMPILE_OPTION_FRAGMENT_COORDINATE_ORIGIN_LOWER_LEFT = 0x00000001,
+};
+
 enum vkd3d_shader_compile_option_name
 {
     /**
@@ -193,6 +232,24 @@ enum vkd3d_shader_compile_option_name
      * \since 1.9
      */
     VKD3D_SHADER_COMPILE_OPTION_PACK_MATRIX_ORDER = 0x00000007,
+    /**
+     * This option is used to enable various backward compatibility features.
+     *
+     * \a value is a mask of values from enum vkd3d_shader_compile_option_backward_compatibility.
+     *
+     * \since 1.10
+     */
+    VKD3D_SHADER_COMPILE_OPTION_BACKWARD_COMPATIBILITY = 0x00000008,
+    /**
+     * This option specifies the origin of fragment coordinates for SPIR-V
+     * targets.
+     *
+     * \a value is a member of enum
+     * vkd3d_shader_compile_option_fragment_coordinate_origin.
+     *
+     * \since 1.10
+     */
+    VKD3D_SHADER_COMPILE_OPTION_FRAGMENT_COORDINATE_ORIGIN = 0x00000009,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_NAME),
 };
@@ -1383,19 +1440,33 @@ struct vkd3d_shader_descriptor_info
  *
  * This structure extends vkd3d_shader_compile_info.
  *
- * When scanning a legacy Direct3D shader, vkd3d-shader enumerates each
- * constant register set used by the shader as a single constant buffer
- * descriptor, as follows:
- * - The \ref vkd3d_shader_descriptor_info.type field is set to
- *   VKD3D_SHADER_DESCRIPTOR_TYPE_CBV.
- * - The \ref vkd3d_shader_descriptor_info.register_space field is set to zero.
- * - The \ref vkd3d_shader_descriptor_info.register_index field is set to a
- *   member of enum vkd3d_shader_d3dbc_constant_register denoting which set
- *   is used.
- * - The \ref vkd3d_shader_descriptor_info.count field is set to one.
- *
- * In summary, there may be up to three such descriptors, one for each register
- * set used by the shader: float, integer, and boolean.
+ * When scanning a legacy Direct3D shader, vkd3d-shader enumerates descriptors
+ * as follows:
+ *
+ * - Each constant register set used by the shader is scanned as a single
+ *   constant buffer descriptor.
+ *   There may therefore be up to three such descriptors, one for each register
+ *   set used by the shader: float, integer, and boolean.
+ *   The fields are set as follows:
+ *   * The \ref vkd3d_shader_descriptor_info.type field is set to
+ *     VKD3D_SHADER_DESCRIPTOR_TYPE_CBV.
+ *   * The \ref vkd3d_shader_descriptor_info.register_space field is set to zero.
+ *   * The \ref vkd3d_shader_descriptor_info.register_index field is set to a
+ *     member of enum vkd3d_shader_d3dbc_constant_register denoting which set
+ *     is used.
+ *   * The \ref vkd3d_shader_descriptor_info.count field is set to one.
+ * - Each sampler used by the shader is scanned as two separate descriptors,
+ *   one representing the texture, and one representing the sampler state.
+ *   If desired, these may be mapped back into a single combined sampler using
+ *   struct vkd3d_shader_combined_resource_sampler.
+ *   The fields are set as follows:
+ *   * The \ref vkd3d_shader_descriptor_info.type field is set to
+ *     VKD3D_SHADER_DESCRIPTOR_TYPE_SRV and VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER
+ *     respectively.
+ *   * The \ref vkd3d_shader_descriptor_info.register_space field is set to zero.
+ *   * The \ref vkd3d_shader_descriptor_info.register_index field is set to the
+ *     binding index of the original sampler, for both descriptors.
+ *   * The \ref vkd3d_shader_descriptor_info.count field is set to one.
  */
 struct vkd3d_shader_scan_descriptor_info
 {
@@ -1412,6 +1483,53 @@ struct vkd3d_shader_scan_descriptor_info
     unsigned int descriptor_count;
 };
 
+/**
+ * This structure describes a single resource-sampler pair. It is returned as
+ * part of struct vkd3d_shader_scan_combined_resource_sampler_info.
+ *
+ * \since 1.10
+ */
+struct vkd3d_shader_combined_resource_sampler_info
+{
+    unsigned int resource_space;
+    unsigned int resource_index;
+    unsigned int sampler_space;
+    unsigned int sampler_index;
+};
+
+/**
+ * A chained structure describing the resource-sampler pairs used by a shader.
+ *
+ * This structure extends vkd3d_shader_compile_info.
+ *
+ * The information returned in this structure can be used to populate the
+ * \ref vkd3d_shader_interface_info.combined_samplers field. This is
+ * particularly useful when targeting environments without separate binding
+ * points for samplers and resources, like OpenGL.
+ *
+ * No resource-sampler pairs are returned for dynamic accesses to
+ * resource/sampler descriptor arrays, as can occur in Direct3D shader model
+ * 5.1 shaders.
+ *
+ * Members of this structure are allocated by vkd3d-shader and should be freed
+ * with vkd3d_shader_free_scan_combined_resource_sampler_info() when no longer
+ * needed.
+ *
+ * \since 1.10
+ */
+struct vkd3d_shader_scan_combined_resource_sampler_info
+{
+    /** Must be set to VKD3D_SHADER_STRUCTURE_TYPE_SCAN_COMBINED_RESOURCE_SAMPLER_INFO. */
+    enum vkd3d_shader_structure_type type;
+    /** Optional pointer to a structure containing further parameters. */
+    const void *next;
+
+    /** Pointer to an array of resource-sampler pairs. */
+    struct vkd3d_shader_combined_resource_sampler_info *combined_samplers;
+    /** The number of resource-sampler pairs in \ref combined_samplers. */
+    unsigned int combined_sampler_count;
+};
+
 /**
  * Data type of a shader varying, returned as part of struct
  * vkd3d_shader_signature_element.
@@ -2313,6 +2431,21 @@ VKD3D_SHADER_API void vkd3d_shader_build_varying_map(const struct vkd3d_shader_s
         const struct vkd3d_shader_signature *input_signature,
         unsigned int *count, struct vkd3d_shader_varying_map *varyings);
 
+/**
+ * Free members of struct vkd3d_shader_scan_combined_resource_sampler_info
+ * allocated by vkd3d_shader_scan().
+ *
+ * This function may free members of
+ * vkd3d_shader_scan_combined_resource_sampler_info, but does not free the
+ * structure itself.
+ *
+ * \param info Combined resource-sampler information to free.
+ *
+ * \since 1.10
+ */
+VKD3D_SHADER_API void vkd3d_shader_free_scan_combined_resource_sampler_info(
+        struct vkd3d_shader_scan_combined_resource_sampler_info *info);
+
 #endif  /* VKD3D_SHADER_NO_PROTOTYPES */
 
 /** Type of vkd3d_shader_get_version(). */
@@ -2385,6 +2518,10 @@ typedef void (*PFN_vkd3d_shader_build_varying_map)(const struct vkd3d_shader_sig
 /** Type of vkd3d_shader_free_scan_signature_info(). \since 1.9 */
 typedef void (*PFN_vkd3d_shader_free_scan_signature_info)(struct vkd3d_shader_scan_signature_info *info);
 
+/** Type of vkd3d_shader_free_scan_combined_resource_sampler_info(). \since 1.10 */
+typedef void (*PFN_vkd3d_shader_free_scan_combined_resource_sampler_info)(
+        struct vkd3d_shader_scan_combined_resource_sampler_info *info);
+
 #ifdef __cplusplus
 }
 #endif  /* __cplusplus */
diff --git a/libs/vkd3d/include/vkd3d_utils.h b/libs/vkd3d/include/vkd3d_utils.h
new file mode 100644
index 00000000000..686ddf386e7
--- /dev/null
+++ b/libs/vkd3d/include/vkd3d_utils.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2016 Józef Kucia for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __VKD3D_UTILS_H
+#define __VKD3D_UTILS_H
+
+#include <vkd3d.h>
+#include <vkd3d_d3dcompiler_types.h>
+
+#ifndef VKD3D_UTILS_API_VERSION
+#define VKD3D_UTILS_API_VERSION VKD3D_API_VERSION_1_0
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/**
+ * \file vkd3d_utils.h
+ *
+ * This file contains definitions for the vkd3d-utils library.
+ *
+ * The vkd3d-utils library is a collections of routines to ease the
+ * porting of a Direct3D 12 application to vkd3d.
+ *
+ * \since 1.0
+ */
+
+#define VKD3D_WAIT_OBJECT_0 (0)
+#define VKD3D_WAIT_TIMEOUT (1)
+#define VKD3D_WAIT_FAILED (~0u)
+#define VKD3D_INFINITE (~0u)
+
+#ifdef LIBVKD3D_UTILS_SOURCE
+# define VKD3D_UTILS_API VKD3D_EXPORT
+#else
+# define VKD3D_UTILS_API VKD3D_IMPORT
+#endif
+
+/* 1.0 */
+VKD3D_UTILS_API HANDLE vkd3d_create_event(void);
+VKD3D_UTILS_API HRESULT vkd3d_signal_event(HANDLE event);
+VKD3D_UTILS_API unsigned int vkd3d_wait_event(HANDLE event, unsigned int milliseconds);
+VKD3D_UTILS_API void vkd3d_destroy_event(HANDLE event);
+
+#define D3D12CreateDevice(a, b, c, d) D3D12CreateDeviceVKD3D(a, b, c, d, VKD3D_UTILS_API_VERSION)
+VKD3D_UTILS_API HRESULT WINAPI D3D12CreateRootSignatureDeserializer(
+        const void *data, SIZE_T data_size, REFIID iid, void **deserializer);
+VKD3D_UTILS_API HRESULT WINAPI D3D12GetDebugInterface(REFIID iid, void **debug);
+VKD3D_UTILS_API HRESULT WINAPI D3D12SerializeRootSignature(const D3D12_ROOT_SIGNATURE_DESC *desc,
+        D3D_ROOT_SIGNATURE_VERSION version, ID3DBlob **blob, ID3DBlob **error_blob);
+
+/* 1.2 */
+VKD3D_UTILS_API HRESULT WINAPI D3D12CreateDeviceVKD3D(IUnknown *adapter, D3D_FEATURE_LEVEL feature_level,
+        REFIID iid, void **device, enum vkd3d_api_version api_version);
+VKD3D_UTILS_API HRESULT WINAPI D3D12CreateVersionedRootSignatureDeserializer(const void *data,
+        SIZE_T data_size, REFIID iid, void **deserializer);
+VKD3D_UTILS_API HRESULT WINAPI D3D12SerializeVersionedRootSignature(const D3D12_VERSIONED_ROOT_SIGNATURE_DESC *desc,
+        ID3DBlob **blob, ID3DBlob **error_blob);
+
+/* 1.3 */
+VKD3D_UTILS_API HRESULT WINAPI D3DCompile(const void *data, SIZE_T data_size, const char *filename,
+        const D3D_SHADER_MACRO *defines, ID3DInclude *include, const char *entrypoint,
+        const char *target, UINT flags, UINT effect_flags, ID3DBlob **shader, ID3DBlob **error_messages);
+VKD3D_UTILS_API HRESULT WINAPI D3DCompile2(const void *data, SIZE_T data_size, const char *filename,
+        const D3D_SHADER_MACRO *defines, ID3DInclude *include, const char *entrypoint,
+        const char *target, UINT flags, UINT effect_flags, UINT secondary_flags,
+        const void *secondary_data, SIZE_T secondary_data_size, ID3DBlob **shader,
+        ID3DBlob **error_messages);
+VKD3D_UTILS_API HRESULT WINAPI D3DCreateBlob(SIZE_T data_size, ID3DBlob **blob);
+VKD3D_UTILS_API HRESULT WINAPI D3DPreprocess(const void *data, SIZE_T size, const char *filename,
+        const D3D_SHADER_MACRO *defines, ID3DInclude *include,
+        ID3DBlob **shader, ID3DBlob **error_messages);
+
+/**
+ * Set a callback to be called when vkd3d-utils outputs debug logging.
+ *
+ * If NULL, or if this function has not been called, libvkd3d-utils will print
+ * all enabled log output to stderr.
+ *
+ * Calling this function will also set the log callback for libvkd3d and
+ * libvkd3d-shader.
+ *
+ * \param callback Callback function to set.
+ *
+ * \since 1.4
+ */
+VKD3D_UTILS_API void vkd3d_utils_set_log_callback(PFN_vkd3d_log callback);
+
+/** \since 1.10 */
+VKD3D_UTILS_API HRESULT WINAPI D3DGetBlobPart(const void *data,
+        SIZE_T data_size, D3D_BLOB_PART part, UINT flags, ID3DBlob **blob);
+/** \since 1.10 */
+VKD3D_UTILS_API HRESULT WINAPI D3DGetDebugInfo(const void *data, SIZE_T data_size, ID3DBlob **blob);
+/** \since 1.10 */
+VKD3D_UTILS_API HRESULT WINAPI D3DGetInputAndOutputSignatureBlob(const void *data, SIZE_T data_size, ID3DBlob **blob);
+/** \since 1.10 */
+VKD3D_UTILS_API HRESULT WINAPI D3DGetInputSignatureBlob(const void *data, SIZE_T data_size, ID3DBlob **blob);
+/** \since 1.10 */
+VKD3D_UTILS_API HRESULT WINAPI D3DGetOutputSignatureBlob(const void *data, SIZE_T data_size, ID3DBlob **blob);
+/** \since 1.10 */
+VKD3D_UTILS_API HRESULT WINAPI D3DStripShader(const void *data, SIZE_T data_size, UINT flags, ID3DBlob **blob);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* __VKD3D_UTILS_H */
diff --git a/libs/vkd3d/include/vkd3d_windows.h b/libs/vkd3d/include/vkd3d_windows.h
new file mode 100644
index 00000000000..7b0e972d828
--- /dev/null
+++ b/libs/vkd3d/include/vkd3d_windows.h
@@ -0,0 +1,289 @@
+/*
+ * Copyright 2016 Józef Kucia for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __VKD3D_WINDOWS_H
+#define __VKD3D_WINDOWS_H
+#ifndef _INC_WINDOWS
+
+/* Nameless unions */
+#ifndef __C89_NAMELESS
+# ifdef NONAMELESSUNION
+#  define __C89_NAMELESS
+#  define __C89_NAMELESSUNIONNAME u
+# else
+#  define __C89_NAMELESS
+#  define __C89_NAMELESSUNIONNAME
+# endif /* NONAMELESSUNION */
+#endif  /* __C89_NAMELESS */
+
+#if !defined(_WIN32) || defined(__WIDL__)
+
+# if !defined(__WIDL__)
+#  if !defined(VKD3D_WIN32_WCHAR)
+#   include <wchar.h>
+#  endif
+#  include <stdint.h>
+# endif
+
+# ifdef __GNUC__
+#  define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))
+# endif
+
+/* HRESULT */
+typedef int HRESULT;
+# define SUCCEEDED(hr) ((HRESULT)(hr) >= 0)
+# define FAILED(hr)    ((HRESULT)(hr) < 0)
+
+# define _HRESULT_TYPEDEF_(x) ((HRESULT)x)
+
+# define S_OK    _HRESULT_TYPEDEF_(0)
+# define S_FALSE _HRESULT_TYPEDEF_(1)
+
+# define E_NOTIMPL     _HRESULT_TYPEDEF_(0x80004001)
+# define E_NOINTERFACE _HRESULT_TYPEDEF_(0x80004002)
+# define E_POINTER     _HRESULT_TYPEDEF_(0x80004003)
+# define E_ABORT       _HRESULT_TYPEDEF_(0x80004004)
+# define E_FAIL        _HRESULT_TYPEDEF_(0x80004005)
+# define E_OUTOFMEMORY _HRESULT_TYPEDEF_(0x8007000E)
+# define E_INVALIDARG  _HRESULT_TYPEDEF_(0x80070057)
+
+# define DXGI_ERROR_NOT_FOUND _HRESULT_TYPEDEF_(0x887a0002)
+# define DXGI_ERROR_MORE_DATA _HRESULT_TYPEDEF_(0x887a0003)
+# define DXGI_ERROR_UNSUPPORTED _HRESULT_TYPEDEF_(0x887a0004)
+
+# define D3DERR_INVALIDCALL _HRESULT_TYPEDEF_(0x8876086c)
+
+/* Basic types */
+typedef unsigned char BYTE;
+typedef unsigned int DWORD;
+typedef int INT;
+typedef unsigned int UINT;
+typedef int LONG;
+typedef unsigned int ULONG;
+typedef float FLOAT;
+typedef LONG BOOL;
+
+/* Assuming LP64 model */
+typedef char INT8;
+typedef unsigned char UINT8;
+typedef short INT16;
+typedef unsigned short UINT16;
+typedef int INT32;
+typedef unsigned int UINT32;
+# if defined(__WIDL__)
+typedef __int64 INT64;
+typedef unsigned __int64 UINT64;
+# else
+typedef int64_t DECLSPEC_ALIGN(8) INT64;
+typedef uint64_t DECLSPEC_ALIGN(8) UINT64;
+# endif
+typedef INT64 LONG64;
+typedef long LONG_PTR;
+typedef unsigned long ULONG_PTR;
+
+typedef ULONG_PTR SIZE_T;
+
+# ifdef VKD3D_WIN32_WCHAR
+typedef unsigned short WCHAR;
+# else
+typedef wchar_t WCHAR;
+# endif /* VKD3D_WIN32_WCHAR */
+typedef void *HANDLE;
+
+/* GUID */
+# ifdef __WIDL__
+typedef struct
+{
+    unsigned long Data1;
+    unsigned short Data2;
+    unsigned short Data3;
+    unsigned char Data4[8];
+} GUID;
+# else
+typedef struct _GUID
+{
+    unsigned int Data1;
+    unsigned short Data2;
+    unsigned short Data3;
+    unsigned char Data4[8];
+} GUID;
+# endif
+
+typedef GUID IID;
+typedef GUID CLSID;
+typedef GUID UUID;
+
+# ifdef INITGUID
+#  ifndef __cplusplus
+#   define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+        const GUID name DECLSPEC_HIDDEN; \
+        const GUID name = \
+    { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 }}
+#  else
+#   define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+        EXTERN_C const GUID name DECLSPEC_HIDDEN; \
+        EXTERN_C const GUID name = \
+    { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 }}
+#  endif
+# else
+#  define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+        EXTERN_C const GUID name DECLSPEC_HIDDEN;
+# endif /* INITGUID */
+
+/* __uuidof emulation */
+#if defined(__cplusplus) && !defined(_MSC_VER)
+
+extern "C++"
+{
+    template<typename T> const GUID &__vkd3d_uuidof();
+}
+
+# define __CRT_UUID_DECL(type, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+    extern "C++" \
+    { \
+        template<> inline const GUID &__vkd3d_uuidof<type>() \
+        { \
+            static const IID __uuid_inst = {l, w1, w2, {b1, b2, b3, b4, b5, b6, b7, b8}}; \
+            return __uuid_inst; \
+        } \
+        template<> inline const GUID &__vkd3d_uuidof<type *>() \
+        { \
+            return __vkd3d_uuidof<type>(); \
+        } \
+    }
+
+# define __uuidof(type) __vkd3d_uuidof<typeof(type)>()
+#else
+# define __CRT_UUID_DECL(type, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)
+#endif /* defined(__cplusplus) && !defined(_MSC_VER) */
+
+typedef struct SECURITY_ATTRIBUTES SECURITY_ATTRIBUTES;
+#endif  /* !defined(_WIN32) || defined(__WIDL__) */
+
+
+#ifndef _WIN32
+# include <stddef.h>
+# include <stdlib.h>
+# include <string.h>
+
+# define COM_NO_WINDOWS_H
+
+# define FORCEINLINE inline
+
+# define CONTAINING_RECORD(address, type, field) \
+        ((type *)((char *)(address) - offsetof(type, field)))
+
+# ifdef __x86_64__
+#  define __stdcall __attribute__((ms_abi))
+# else
+#  if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 2)) || defined(__APPLE__)
+#   define __stdcall __attribute__((__stdcall__)) __attribute__((__force_align_arg_pointer__))
+#  else
+#   define __stdcall __attribute__((__stdcall__))
+#  endif
+# endif
+
+# define WINAPI __stdcall
+# define STDMETHODCALLTYPE __stdcall
+
+# ifdef __GNUC__
+#  define DECLSPEC_SELECTANY __attribute__((weak))
+# endif
+
+/* Macros for COM interfaces */
+# define interface struct
+# define BEGIN_INTERFACE
+# define END_INTERFACE
+# define MIDL_INTERFACE(x) struct
+
+# ifdef __cplusplus
+#  define EXTERN_C extern "C"
+# else
+#  define EXTERN_C extern
+# endif
+
+# define CONST_VTBL const
+
+# define TRUE 1
+# define FALSE 0
+
+# if defined(__cplusplus) && !defined(CINTERFACE)
+#  define REFIID const IID &
+#  define REFGUID const GUID &
+#  define REFCLSID const CLSID &
+# else
+#  define REFIID const IID * const
+#  define REFGUID const GUID * const
+#  define REFCLSID const CLSID * const
+# endif
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+# define IsEqualGUID(guid1, guid2) (!memcmp(&(guid1), &(guid2), sizeof(GUID)))
+#else
+# define IsEqualGUID(guid1, guid2) (!memcmp(guid1, guid2, sizeof(GUID)))
+#endif
+
+#elif !defined(__WIDL__)
+
+# include <windows.h>
+
+#endif  /* _WIN32 */
+
+
+/* Define DECLSPEC_HIDDEN */
+#ifndef DECLSPEC_HIDDEN
+# if defined(__MINGW32__)
+#  define DECLSPEC_HIDDEN
+# elif defined(__GNUC__)
+#  define DECLSPEC_HIDDEN __attribute__((visibility("hidden")))
+# else
+#  define DECLSPEC_HIDDEN
+# endif
+#endif  /* DECLSPEC_HIDDEN */
+
+/* Define min() & max() macros */
+#ifndef NOMINMAX
+# ifndef min
+#  define min(a, b) (((a) <= (b)) ? (a) : (b))
+# endif
+
+# ifndef max
+#  define max(a, b) (((a) >= (b)) ? (a) : (b))
+# endif
+#endif /* NOMINMAX */
+
+#ifndef DEFINE_ENUM_FLAG_OPERATORS
+#ifdef __cplusplus
+# define DEFINE_ENUM_FLAG_OPERATORS(type) \
+extern "C++" \
+{ \
+    inline type operator &(type x, type y) { return (type)((int)x & (int)y); } \
+    inline type operator &=(type &x, type y) { return (type &)((int &)x &= (int)y); } \
+    inline type operator ~(type x) { return (type)~(int)x; } \
+    inline type operator |(type x, type y) { return (type)((int)x | (int)y); } \
+    inline type operator |=(type &x, type y) { return (type &)((int &)x |= (int)y); } \
+    inline type operator ^(type x, type y) { return (type)((int)x ^ (int)y); } \
+    inline type operator ^=(type &x, type y) { return (type &)((int &)x ^= (int)y); } \
+}
+#else
+# define DEFINE_ENUM_FLAG_OPERATORS(type)
+#endif
+#endif /* DEFINE_ENUM_FLAG_OPERATORS */
+
+#endif  /* _INC_WINDOWS */
+#endif  /* __VKD3D_WINDOWS_H */
diff --git a/libs/vkd3d/libs/vkd3d-common/blob.c b/libs/vkd3d/libs/vkd3d-common/blob.c
index 30205088b1b..fa2812619ac 100644
--- a/libs/vkd3d/libs/vkd3d-common/blob.c
+++ b/libs/vkd3d/libs/vkd3d-common/blob.c
@@ -17,6 +17,8 @@
  */
 
 #define COBJMACROS
+
+#define CONST_VTABLE
 #include "vkd3d.h"
 #include "vkd3d_blob.h"
 #include "vkd3d_debug.h"
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index f0c386f1b3a..82d1d71d9d3 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -106,9 +106,9 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_DEFAULT                         ] = "default",
     [VKD3DSIH_DEFB                            ] = "defb",
     [VKD3DSIH_DEFI                            ] = "defi",
-    [VKD3DSIH_DEQ                             ] = "deq",
+    [VKD3DSIH_DEQO                            ] = "deq",
     [VKD3DSIH_DFMA                            ] = "dfma",
-    [VKD3DSIH_DGE                             ] = "dge",
+    [VKD3DSIH_DGEO                            ] = "dge",
     [VKD3DSIH_DISCARD                         ] = "discard",
     [VKD3DSIH_DIV                             ] = "div",
     [VKD3DSIH_DLT                             ] = "dlt",
@@ -140,7 +140,8 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_ENDLOOP                         ] = "endloop",
     [VKD3DSIH_ENDREP                          ] = "endrep",
     [VKD3DSIH_ENDSWITCH                       ] = "endswitch",
-    [VKD3DSIH_EQ                              ] = "eq",
+    [VKD3DSIH_EQO                             ] = "eq",
+    [VKD3DSIH_EQU                             ] = "eq_unord",
     [VKD3DSIH_EVAL_CENTROID                   ] = "eval_centroid",
     [VKD3DSIH_EVAL_SAMPLE_INDEX               ] = "eval_sample_index",
     [VKD3DSIH_EXP                             ] = "exp",
@@ -152,6 +153,7 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_FIRSTBIT_LO                     ] = "firstbit_lo",
     [VKD3DSIH_FIRSTBIT_SHI                    ] = "firstbit_shi",
     [VKD3DSIH_FRC                             ] = "frc",
+    [VKD3DSIH_FREM                            ] = "frem",
     [VKD3DSIH_FTOD                            ] = "ftod",
     [VKD3DSIH_FTOI                            ] = "ftoi",
     [VKD3DSIH_FTOU                            ] = "ftou",
@@ -163,13 +165,15 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_GATHER4_PO_C_S                  ] = "gather4_po_c_s",
     [VKD3DSIH_GATHER4_PO_S                    ] = "gather4_po_s",
     [VKD3DSIH_GATHER4_S                       ] = "gather4_s",
-    [VKD3DSIH_GE                              ] = "ge",
+    [VKD3DSIH_GEO                             ] = "ge",
+    [VKD3DSIH_GEU                             ] = "ge_unord",
     [VKD3DSIH_HS_CONTROL_POINT_PHASE          ] = "hs_control_point_phase",
     [VKD3DSIH_HS_DECLS                        ] = "hs_decls",
     [VKD3DSIH_HS_FORK_PHASE                   ] = "hs_fork_phase",
     [VKD3DSIH_HS_JOIN_PHASE                   ] = "hs_join_phase",
     [VKD3DSIH_IADD                            ] = "iadd",
     [VKD3DSIH_IBFE                            ] = "ibfe",
+    [VKD3DSIH_IDIV                            ] = "idiv",
     [VKD3DSIH_IEQ                             ] = "ieq",
     [VKD3DSIH_IF                              ] = "if",
     [VKD3DSIH_IFC                             ] = "ifc",
@@ -197,6 +201,7 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_ISHR                            ] = "ishr",
     [VKD3DSIH_ITOD                            ] = "itod",
     [VKD3DSIH_ITOF                            ] = "itof",
+    [VKD3DSIH_ITOI                            ] = "itoi",
     [VKD3DSIH_LABEL                           ] = "label",
     [VKD3DSIH_LD                              ] = "ld",
     [VKD3DSIH_LD2DMS                          ] = "ld2dms",
@@ -214,7 +219,8 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_LOGP                            ] = "logp",
     [VKD3DSIH_LOOP                            ] = "loop",
     [VKD3DSIH_LRP                             ] = "lrp",
-    [VKD3DSIH_LT                              ] = "lt",
+    [VKD3DSIH_LTO                             ] = "lt",
+    [VKD3DSIH_LTU                             ] = "lt_unord",
     [VKD3DSIH_M3x2                            ] = "m3x2",
     [VKD3DSIH_M3x3                            ] = "m3x3",
     [VKD3DSIH_M3x4                            ] = "m3x4",
@@ -228,7 +234,8 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_MOVC                            ] = "movc",
     [VKD3DSIH_MSAD                            ] = "msad",
     [VKD3DSIH_MUL                             ] = "mul",
-    [VKD3DSIH_NE                              ] = "ne",
+    [VKD3DSIH_NEO                             ] = "ne_ord",
+    [VKD3DSIH_NEU                             ] = "ne",
     [VKD3DSIH_NOP                             ] = "nop",
     [VKD3DSIH_NOT                             ] = "not",
     [VKD3DSIH_NRM                             ] = "nrm",
@@ -304,6 +311,7 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_USHR                            ] = "ushr",
     [VKD3DSIH_UTOD                            ] = "utod",
     [VKD3DSIH_UTOF                            ] = "utof",
+    [VKD3DSIH_UTOU                            ] = "utou",
     [VKD3DSIH_XOR                             ] = "xor",
 };
 
@@ -358,11 +366,6 @@ struct vkd3d_d3d_asm_compiler
     struct vkd3d_d3d_asm_colours colours;
 };
 
-static int shader_ver_ge(const struct vkd3d_shader_version *v, int major, int minor)
-{
-    return v->major > major || (v->major == major && v->minor >= minor);
-}
-
 static int VKD3D_PRINTF_FUNC(2, 3) shader_addline(struct vkd3d_string_buffer *buffer, const char *format, ...)
 {
     va_list args;
@@ -391,13 +394,14 @@ static unsigned int shader_get_float_offset(enum vkd3d_shader_register_type regi
     }
 }
 
-static void shader_dump_global_flags(struct vkd3d_d3d_asm_compiler *compiler, uint32_t global_flags)
+static void shader_dump_global_flags(struct vkd3d_d3d_asm_compiler *compiler,
+        enum vkd3d_shader_global_flags global_flags)
 {
     unsigned int i;
 
     static const struct
     {
-        unsigned int flag;
+        enum vkd3d_shader_global_flags flag;
         const char *name;
     }
     global_flag_info[] =
@@ -423,7 +427,7 @@ static void shader_dump_global_flags(struct vkd3d_d3d_asm_compiler *compiler, ui
     }
 
     if (global_flags)
-        vkd3d_string_buffer_printf(&compiler->buffer, "unknown_flags(%#x)", global_flags);
+        vkd3d_string_buffer_printf(&compiler->buffer, "unknown_flags(%#"PRIx64")", (uint64_t)global_flags);
 }
 
 static void shader_dump_sync_flags(struct vkd3d_d3d_asm_compiler *compiler, uint32_t sync_flags)
@@ -477,6 +481,11 @@ static void shader_dump_uav_flags(struct vkd3d_d3d_asm_compiler *compiler, uint3
         vkd3d_string_buffer_printf(&compiler->buffer, "_opc");
         uav_flags &= ~VKD3DSUF_ORDER_PRESERVING_COUNTER;
     }
+    if (uav_flags & VKD3DSUF_RASTERISER_ORDERED_VIEW)
+    {
+        vkd3d_string_buffer_printf(&compiler->buffer, "_rov");
+        uav_flags &= ~VKD3DSUF_RASTERISER_ORDERED_VIEW;
+    }
 
     if (uav_flags)
         vkd3d_string_buffer_printf(&compiler->buffer, "_unknown_flags(%#x)", uav_flags);
@@ -637,7 +646,7 @@ static void shader_dump_decl_usage(struct vkd3d_d3d_asm_compiler *compiler,
 {
     struct vkd3d_string_buffer *buffer = &compiler->buffer;
 
-    if (semantic->resource.reg.reg.type == VKD3DSPR_SAMPLER)
+    if (semantic->resource.reg.reg.type == VKD3DSPR_COMBINED_SAMPLER)
     {
         switch (semantic->resource_type)
         {
@@ -678,7 +687,7 @@ static void shader_dump_decl_usage(struct vkd3d_d3d_asm_compiler *compiler,
     else
     {
         /* Pixel shaders 3.0 don't have usage semantics. */
-        if (!shader_ver_ge(&compiler->shader_version, 3, 0)
+        if (!vkd3d_shader_ver_ge(&compiler->shader_version, 3, 0)
                 && compiler->shader_version.type == VKD3D_SHADER_TYPE_PIXEL)
             return;
         else
@@ -880,9 +889,7 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
             break;
 
         case VKD3DSPR_COLOROUT:
-            shader_addline(buffer, "o");
-            if (!shader_ver_ge(&compiler->shader_version, 4, 0))
-                shader_addline(buffer, "C");
+            shader_addline(buffer, "oC");
             break;
 
         case VKD3DSPR_DEPTHOUT:
@@ -904,7 +911,7 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
         case VKD3DSPR_TEXCRDOUT:
             /* Vertex shaders >= 3.0 use general purpose output registers
              * (VKD3DSPR_OUTPUT), which can include an address token. */
-            if (shader_ver_ge(&compiler->shader_version, 3, 0))
+            if (vkd3d_shader_ver_ge(&compiler->shader_version, 3, 0))
                 shader_addline(buffer, "o");
             else
                 shader_addline(buffer, "oT");
@@ -926,6 +933,7 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
             shader_addline(buffer, "aL");
             break;
 
+        case VKD3DSPR_COMBINED_SAMPLER:
         case VKD3DSPR_SAMPLER:
             shader_addline(buffer, "s");
             is_descriptor = true;
@@ -1066,6 +1074,14 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
             shader_addline(buffer, "oStencilRef");
             break;
 
+        case VKD3DSPR_UNDEF:
+            shader_addline(buffer, "undef");
+            break;
+
+        case VKD3DSPR_SSA:
+            shader_addline(buffer, "sr");
+            break;
+
         default:
             shader_addline(buffer, "<unhandled_rtype(%#x)>", reg->type);
             break;
@@ -1074,9 +1090,9 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
     if (reg->type == VKD3DSPR_IMMCONST)
     {
         shader_addline(buffer, "%s(", compiler->colours.reset);
-        switch (reg->immconst_type)
+        switch (reg->dimension)
         {
-            case VKD3D_IMMCONST_SCALAR:
+            case VSIR_DIMENSION_SCALAR:
                 switch (reg->data_type)
                 {
                     case VKD3D_DATA_FLOAT:
@@ -1096,7 +1112,7 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
                 }
                 break;
 
-            case VKD3D_IMMCONST_VEC4:
+            case VSIR_DIMENSION_VEC4:
                 switch (reg->data_type)
                 {
                     case VKD3D_DATA_FLOAT:
@@ -1126,7 +1142,7 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
                 break;
 
             default:
-                shader_addline(buffer, "<unhandled immconst_type %#x>", reg->immconst_type);
+                shader_addline(buffer, "<unhandled immconst dimension %#x>", reg->dimension);
                 break;
         }
         shader_addline(buffer, ")");
@@ -1134,13 +1150,13 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
     else if (reg->type == VKD3DSPR_IMMCONST64)
     {
         shader_addline(buffer, "%s(", compiler->colours.reset);
-        /* A double2 vector is treated as a float4 vector in enum vkd3d_immconst_type. */
-        if (reg->immconst_type == VKD3D_IMMCONST_SCALAR || reg->immconst_type == VKD3D_IMMCONST_VEC4)
+        /* A double2 vector is treated as a float4 vector in enum vsir_dimension. */
+        if (reg->dimension == VSIR_DIMENSION_SCALAR || reg->dimension == VSIR_DIMENSION_VEC4)
         {
             if (reg->data_type == VKD3D_DATA_DOUBLE)
             {
                 shader_print_double_literal(compiler, "", reg->u.immconst_double[0], "");
-                if (reg->immconst_type == VKD3D_IMMCONST_VEC4)
+                if (reg->dimension == VSIR_DIMENSION_VEC4)
                     shader_print_double_literal(compiler, ", ", reg->u.immconst_double[1], "");
             }
             else
@@ -1150,17 +1166,18 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
         }
         else
         {
-            shader_addline(buffer, "<unhandled immconst_type %#x>", reg->immconst_type);
+            shader_addline(buffer, "<unhandled immconst64 dimension %#x>", reg->dimension);
         }
         shader_addline(buffer, ")");
     }
     else if (reg->type != VKD3DSPR_RASTOUT
             && reg->type != VKD3DSPR_MISCTYPE
-            && reg->type != VKD3DSPR_NULL)
+            && reg->type != VKD3DSPR_NULL
+            && reg->type != VKD3DSPR_DEPTHOUT)
     {
         if (offset != ~0u)
         {
-            bool is_sm_5_1 = shader_ver_ge(&compiler->shader_version, 5, 1);
+            bool is_sm_5_1 = vkd3d_shader_ver_ge(&compiler->shader_version, 5, 1);
 
             if (reg->idx[0].rel_addr || reg->type == VKD3DSPR_IMMCONSTBUFFER
                     || reg->type == VKD3DSPR_INCONTROLPOINT || (reg->type == VKD3DSPR_INPUT
@@ -1181,7 +1198,7 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
             {
                 shader_print_subscript_range(compiler, reg->idx[1].offset, reg->idx[2].offset);
             }
-            else
+            else if (reg->type != VKD3DSPR_SSA)
             {
                 /* For descriptors in sm < 5.1 we move the reg->idx values up one slot
                  * to normalise with 5.1.
@@ -1256,7 +1273,7 @@ static void shader_dump_dst_param(struct vkd3d_d3d_asm_compiler *compiler,
 
     shader_dump_register(compiler, &param->reg, is_declaration);
 
-    if (write_mask)
+    if (write_mask && param->reg.dimension == VSIR_DIMENSION_VEC4)
     {
         static const char write_mask_chars[] = "xyzw";
 
@@ -1322,7 +1339,7 @@ static void shader_dump_src_param(struct vkd3d_d3d_asm_compiler *compiler,
     }
 
     if (param->reg.type != VKD3DSPR_IMMCONST && param->reg.type != VKD3DSPR_IMMCONST64
-            && param->reg.type != VKD3DSPR_SAMPLER)
+            && param->reg.dimension == VSIR_DIMENSION_VEC4)
     {
         unsigned int swizzle_x = vkd3d_swizzle_get_component(swizzle, 0);
         unsigned int swizzle_y = vkd3d_swizzle_get_component(swizzle, 1);
@@ -1374,7 +1391,7 @@ static void shader_dump_ins_modifiers(struct vkd3d_d3d_asm_compiler *compiler,
     if (mmask & VKD3DSPDM_PARTIALPRECISION) shader_addline(buffer, "_pp");
     if (mmask & VKD3DSPDM_MSAMPCENTROID)    shader_addline(buffer, "_centroid");
 
-    mmask &= ~(VKD3DSPDM_SATURATE | VKD3DSPDM_PARTIALPRECISION | VKD3DSPDM_MSAMPCENTROID);
+    mmask &= ~VKD3DSPDM_MASK;
     if (mmask) FIXME("Unrecognised modifier %#x.\n", mmask);
 }
 
@@ -1556,7 +1573,7 @@ static void shader_dump_instruction_flags(struct vkd3d_d3d_asm_compiler *compile
             break;
 
         case VKD3DSIH_TEX:
-            if (shader_ver_ge(&compiler->shader_version, 2, 0) && (ins->flags & VKD3DSI_TEXLD_PROJECT))
+            if (vkd3d_shader_ver_ge(&compiler->shader_version, 2, 0) && (ins->flags & VKD3DSI_TEXLD_PROJECT))
                 shader_addline(buffer, "p");
             break;
 
@@ -1568,7 +1585,7 @@ static void shader_dump_instruction_flags(struct vkd3d_d3d_asm_compiler *compile
 
 static void shader_dump_register_space(struct vkd3d_d3d_asm_compiler *compiler, unsigned int register_space)
 {
-    if (shader_ver_ge(&compiler->shader_version, 5, 1))
+    if (vkd3d_shader_ver_ge(&compiler->shader_version, 5, 1))
         shader_print_uint_literal(compiler, ", space=", register_space, "");
 }
 
@@ -1578,6 +1595,36 @@ static void shader_print_opcode(struct vkd3d_d3d_asm_compiler *compiler, enum vk
             shader_opcode_names[opcode], compiler->colours.reset);
 }
 
+static void shader_dump_icb(struct vkd3d_d3d_asm_compiler *compiler,
+        const struct vkd3d_shader_immediate_constant_buffer *icb)
+{
+    struct vkd3d_string_buffer *buffer = &compiler->buffer;
+    unsigned int i, j;
+
+    vkd3d_string_buffer_printf(buffer, " {\n");
+    if (icb->component_count == 1)
+    {
+        for (i = 0; i < icb->element_count; )
+        {
+            for (j = 0; i < icb->element_count && j < 4; ++i, ++j)
+                shader_print_hex_literal(compiler, !j ? "    " : ", ", icb->data[i], "");
+            vkd3d_string_buffer_printf(buffer, "\n");
+        }
+    }
+    else
+    {
+        assert(icb->component_count == VKD3D_VEC4_SIZE);
+        for (i = 0; i < icb->element_count; ++i)
+        {
+            shader_print_hex_literal(compiler, "    {", icb->data[4 * i + 0], "");
+            shader_print_hex_literal(compiler, ", ", icb->data[4 * i + 1], "");
+            shader_print_hex_literal(compiler, ", ", icb->data[4 * i + 2], "");
+            shader_print_hex_literal(compiler, ", ", icb->data[4 * i + 3], "},\n");
+        }
+    }
+    shader_addline(buffer, "}");
+}
+
 static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
         const struct vkd3d_shader_instruction *ins)
 {
@@ -1612,8 +1659,10 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
         case VKD3DSIH_DCL_CONSTANT_BUFFER:
             vkd3d_string_buffer_printf(buffer, " ");
             shader_dump_register(compiler, &ins->declaration.cb.src.reg, true);
-            if (shader_ver_ge(&compiler->shader_version, 5, 1))
+            if (vkd3d_shader_ver_ge(&compiler->shader_version, 6, 0))
                 shader_print_subscript(compiler, ins->declaration.cb.size, NULL);
+            else if (vkd3d_shader_ver_ge(&compiler->shader_version, 5, 1))
+                shader_print_subscript(compiler, ins->declaration.cb.size / VKD3D_VEC4_SIZE / sizeof(float), NULL);
             shader_addline(buffer, ", %s",
                     ins->flags & VKD3DSI_INDEXED_DYNAMIC ? "dynamicIndexed" : "immediateIndexed");
             shader_dump_register_space(compiler, ins->declaration.cb.range.space);
@@ -1629,7 +1678,7 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
 
         case VKD3DSIH_DCL_GLOBAL_FLAGS:
             vkd3d_string_buffer_printf(buffer, " ");
-            shader_dump_global_flags(compiler, ins->flags);
+            shader_dump_global_flags(compiler, ins->declaration.global_flags);
             break;
 
         case VKD3DSIH_DCL_HS_MAX_TESSFACTOR:
@@ -1637,15 +1686,7 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
             break;
 
         case VKD3DSIH_DCL_IMMEDIATE_CONSTANT_BUFFER:
-            vkd3d_string_buffer_printf(buffer, " {\n");
-            for (i = 0; i < ins->declaration.icb->vec4_count; ++i)
-            {
-                shader_print_hex_literal(compiler, "    {", ins->declaration.icb->data[4 * i + 0], "");
-                shader_print_hex_literal(compiler, ", ", ins->declaration.icb->data[4 * i + 1], "");
-                shader_print_hex_literal(compiler, ", ", ins->declaration.icb->data[4 * i + 2], "");
-                shader_print_hex_literal(compiler, ", ", ins->declaration.icb->data[4 * i + 3], "},\n");
-            }
-            shader_addline(buffer, "}");
+            shader_dump_icb(compiler, ins->declaration.icb);
             break;
 
         case VKD3DSIH_DCL_INDEX_RANGE:
@@ -1659,6 +1700,10 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
                     ins->declaration.indexable_temp.register_idx, compiler->colours.reset);
             shader_print_subscript(compiler, ins->declaration.indexable_temp.register_size, NULL);
             shader_print_uint_literal(compiler, ", ", ins->declaration.indexable_temp.component_count, "");
+            if (ins->declaration.indexable_temp.alignment)
+                shader_print_uint_literal(compiler, ", align ", ins->declaration.indexable_temp.alignment, "");
+            if (ins->declaration.indexable_temp.initialiser)
+                shader_dump_icb(compiler, ins->declaration.indexable_temp.initialiser);
             break;
 
         case VKD3DSIH_DCL_INPUT_PS:
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
index 1fd5ab2446d..3d139416b61 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -261,7 +261,7 @@ static const struct vkd3d_sm1_opcode_info vs_opcode_table[] =
     {VKD3D_SM1_OP_M3x3,         1, 2, VKD3DSIH_M3x3},
     {VKD3D_SM1_OP_M3x2,         1, 2, VKD3DSIH_M3x2},
     /* Declarations */
-    {VKD3D_SM1_OP_DCL,          0, 2, VKD3DSIH_DCL},
+    {VKD3D_SM1_OP_DCL,          0, 0, VKD3DSIH_DCL},
     /* Constant definitions */
     {VKD3D_SM1_OP_DEF,          1, 1, VKD3DSIH_DEF},
     {VKD3D_SM1_OP_DEFB,         1, 1, VKD3DSIH_DEFB},
@@ -328,7 +328,7 @@ static const struct vkd3d_sm1_opcode_info ps_opcode_table[] =
     {VKD3D_SM1_OP_M3x3,         1, 2, VKD3DSIH_M3x3},
     {VKD3D_SM1_OP_M3x2,         1, 2, VKD3DSIH_M3x2},
     /* Declarations */
-    {VKD3D_SM1_OP_DCL,          0, 2, VKD3DSIH_DCL},
+    {VKD3D_SM1_OP_DCL,          0, 0, VKD3DSIH_DCL},
     /* Constant definitions */
     {VKD3D_SM1_OP_DEF,          1, 1, VKD3DSIH_DEF},
     {VKD3D_SM1_OP_DEFB,         1, 1, VKD3DSIH_DEFB},
@@ -402,16 +402,6 @@ static uint32_t read_u32(const uint32_t **ptr)
     return *(*ptr)++;
 }
 
-static bool shader_ver_ge(const struct vkd3d_shader_version *v, unsigned int major, unsigned int minor)
-{
-    return v->major > major || (v->major == major && v->minor >= minor);
-}
-
-static bool shader_ver_le(const struct vkd3d_shader_version *v, unsigned int major, unsigned int minor)
-{
-    return v->major < major || (v->major == major && v->minor <= minor);
-}
-
 static bool has_relative_address(uint32_t param)
 {
     enum vkd3d_sm1_address_mode_type address_mode;
@@ -434,8 +424,8 @@ static const struct vkd3d_sm1_opcode_info *shader_sm1_get_opcode_info(
             return NULL;
 
         if (opcode == info->sm1_opcode
-                && shader_ver_ge(&sm1->p.shader_version, info->min_version.major, info->min_version.minor)
-                && (shader_ver_le(&sm1->p.shader_version, info->max_version.major, info->max_version.minor)
+                && vkd3d_shader_ver_ge(&sm1->p.shader_version, info->min_version.major, info->min_version.minor)
+                && (vkd3d_shader_ver_le(&sm1->p.shader_version, info->max_version.major, info->max_version.minor)
                         || !info->max_version.major))
             return info;
     }
@@ -457,18 +447,20 @@ static uint32_t swizzle_from_sm1(uint32_t swizzle)
 static void shader_sm1_parse_src_param(uint32_t param, const struct vkd3d_shader_src_param *rel_addr,
         struct vkd3d_shader_src_param *src)
 {
-    src->reg.type = ((param & VKD3D_SM1_REGISTER_TYPE_MASK) >> VKD3D_SM1_REGISTER_TYPE_SHIFT)
+    enum vkd3d_shader_register_type reg_type = ((param & VKD3D_SM1_REGISTER_TYPE_MASK) >> VKD3D_SM1_REGISTER_TYPE_SHIFT)
             | ((param & VKD3D_SM1_REGISTER_TYPE_MASK2) >> VKD3D_SM1_REGISTER_TYPE_SHIFT2);
+
+    vsir_register_init(&src->reg, reg_type, VKD3D_DATA_FLOAT, 1);
     src->reg.precision = VKD3D_SHADER_REGISTER_PRECISION_DEFAULT;
     src->reg.non_uniform = false;
-    src->reg.data_type = VKD3D_DATA_FLOAT;
     src->reg.idx[0].offset = param & VKD3D_SM1_REGISTER_NUMBER_MASK;
     src->reg.idx[0].rel_addr = rel_addr;
-    src->reg.idx[1].offset = ~0u;
-    src->reg.idx[1].rel_addr = NULL;
-    src->reg.idx[2].offset = ~0u;
-    src->reg.idx[2].rel_addr = NULL;
-    src->reg.idx_count = 1;
+    if (src->reg.type == VKD3DSPR_SAMPLER)
+        src->reg.dimension = VSIR_DIMENSION_NONE;
+    else if (src->reg.type == VKD3DSPR_DEPTHOUT)
+        src->reg.dimension = VSIR_DIMENSION_SCALAR;
+    else
+        src->reg.dimension = VSIR_DIMENSION_VEC4;
     src->swizzle = swizzle_from_sm1((param & VKD3D_SM1_SWIZZLE_MASK) >> VKD3D_SM1_SWIZZLE_SHIFT);
     src->modifiers = (param & VKD3D_SM1_SRC_MODIFIER_MASK) >> VKD3D_SM1_SRC_MODIFIER_SHIFT;
 }
@@ -476,18 +468,20 @@ static void shader_sm1_parse_src_param(uint32_t param, const struct vkd3d_shader
 static void shader_sm1_parse_dst_param(uint32_t param, const struct vkd3d_shader_src_param *rel_addr,
         struct vkd3d_shader_dst_param *dst)
 {
-    dst->reg.type = ((param & VKD3D_SM1_REGISTER_TYPE_MASK) >> VKD3D_SM1_REGISTER_TYPE_SHIFT)
+    enum vkd3d_shader_register_type reg_type = ((param & VKD3D_SM1_REGISTER_TYPE_MASK) >> VKD3D_SM1_REGISTER_TYPE_SHIFT)
             | ((param & VKD3D_SM1_REGISTER_TYPE_MASK2) >> VKD3D_SM1_REGISTER_TYPE_SHIFT2);
+
+    vsir_register_init(&dst->reg, reg_type, VKD3D_DATA_FLOAT, 1);
     dst->reg.precision = VKD3D_SHADER_REGISTER_PRECISION_DEFAULT;
     dst->reg.non_uniform = false;
-    dst->reg.data_type = VKD3D_DATA_FLOAT;
     dst->reg.idx[0].offset = param & VKD3D_SM1_REGISTER_NUMBER_MASK;
     dst->reg.idx[0].rel_addr = rel_addr;
-    dst->reg.idx[1].offset = ~0u;
-    dst->reg.idx[1].rel_addr = NULL;
-    dst->reg.idx[2].offset = ~0u;
-    dst->reg.idx[2].rel_addr = NULL;
-    dst->reg.idx_count = 1;
+    if (dst->reg.type == VKD3DSPR_SAMPLER)
+        dst->reg.dimension = VSIR_DIMENSION_NONE;
+    else if (dst->reg.type == VKD3DSPR_DEPTHOUT)
+        dst->reg.dimension = VSIR_DIMENSION_SCALAR;
+    else
+        dst->reg.dimension = VSIR_DIMENSION_VEC4;
     dst->write_mask = (param & VKD3D_SM1_WRITEMASK_MASK) >> VKD3D_SM1_WRITEMASK_SHIFT;
     dst->modifiers = (param & VKD3D_SM1_DST_MODIFIER_MASK) >> VKD3D_SM1_DST_MODIFIER_SHIFT;
     dst->shift = (param & VKD3D_SM1_DSTSHIFT_MASK) >> VKD3D_SM1_DSTSHIFT_SHIFT;
@@ -551,9 +545,9 @@ static bool add_signature_element(struct vkd3d_shader_sm1_parser *sm1, bool outp
         return false;
     element = &signature->elements[signature->element_count++];
 
+    memset(element, 0, sizeof(*element));
     element->semantic_name = name;
     element->semantic_index = index;
-    element->stream_index = 0;
     element->sysval_semantic = sysval;
     element->component_type = VKD3D_SHADER_COMPONENT_FLOAT;
     element->register_index = register_index;
@@ -561,7 +555,8 @@ static bool add_signature_element(struct vkd3d_shader_sm1_parser *sm1, bool outp
     element->register_count = 1;
     element->mask = mask;
     element->used_mask = is_dcl ? 0 : mask;
-    element->min_precision = VKD3D_SHADER_MINIMUM_PRECISION_NONE;
+    if (sm1->p.shader_version.type == VKD3D_SHADER_TYPE_PIXEL && !output)
+        element->interpolation_mode = VKD3DSIM_LINEAR;
 
     return true;
 }
@@ -853,6 +848,22 @@ static void shader_sm1_skip_opcode(const struct vkd3d_shader_sm1_parser *sm1, co
         return;
     }
 
+    /* DCL instructions do not have sources or destinations, but they
+     * read two tokens to a semantic. See
+     * shader_sm1_read_semantic(). */
+    if (opcode_info->vkd3d_opcode == VKD3DSIH_DCL)
+    {
+        *ptr += 2;
+    }
+    /* Somewhat similarly, DEF and DEFI have a single source, but need to read
+     * four tokens for that source. See shader_sm1_read_immconst().
+     * Technically shader model 1 doesn't have integer registers or DEFI; we
+     * handle it here anyway because it's easy. */
+    else if (opcode_info->vkd3d_opcode == VKD3DSIH_DEF || opcode_info->vkd3d_opcode == VKD3DSIH_DEFI)
+    {
+        *ptr += 3;
+    }
+
     *ptr += (opcode_info->dst_count + opcode_info->src_count);
 }
 
@@ -951,9 +962,9 @@ static void shader_sm1_read_semantic(struct vkd3d_shader_sm1_parser *sm1,
 }
 
 static void shader_sm1_read_immconst(struct vkd3d_shader_sm1_parser *sm1, const uint32_t **ptr,
-        struct vkd3d_shader_src_param *src_param, enum vkd3d_immconst_type type, enum vkd3d_data_type data_type)
+        struct vkd3d_shader_src_param *src_param, enum vsir_dimension dimension, enum vkd3d_data_type data_type)
 {
-    unsigned int count = type == VKD3D_IMMCONST_VEC4 ? 4 : 1;
+    unsigned int count = dimension == VSIR_DIMENSION_VEC4 ? 4 : 1;
 
     if (*ptr >= sm1->end || sm1->end - *ptr < count)
     {
@@ -975,7 +986,7 @@ static void shader_sm1_read_immconst(struct vkd3d_shader_sm1_parser *sm1, const
     src_param->reg.idx[2].offset = ~0u;
     src_param->reg.idx[2].rel_addr = NULL;
     src_param->reg.idx_count = 0;
-    src_param->reg.immconst_type = type;
+    src_param->reg.dimension = dimension;
     memcpy(src_param->reg.u.immconst_uint, *ptr, count * sizeof(uint32_t));
     src_param->swizzle = VKD3D_SHADER_NO_SWIZZLE;
     src_param->modifiers = 0;
@@ -1090,7 +1101,7 @@ static void shader_sm1_read_instruction(struct vkd3d_shader_sm1_parser *sm1, str
         goto fail;
     }
 
-    ins->handler_idx = opcode_info->vkd3d_opcode;
+    vsir_instruction_init(ins, &sm1->p.location, opcode_info->vkd3d_opcode);
     ins->flags = (opcode_token & VKD3D_SM1_INSTRUCTION_FLAGS_MASK) >> VKD3D_SM1_INSTRUCTION_FLAGS_SHIFT;
     ins->coissue = opcode_token & VKD3D_SM1_COISSUE;
     ins->raw = false;
@@ -1132,19 +1143,19 @@ static void shader_sm1_read_instruction(struct vkd3d_shader_sm1_parser *sm1, str
     else if (ins->handler_idx == VKD3DSIH_DEF)
     {
         shader_sm1_read_dst_param(sm1, &p, dst_param);
-        shader_sm1_read_immconst(sm1, &p, &src_params[0], VKD3D_IMMCONST_VEC4, VKD3D_DATA_FLOAT);
+        shader_sm1_read_immconst(sm1, &p, &src_params[0], VSIR_DIMENSION_VEC4, VKD3D_DATA_FLOAT);
         shader_sm1_scan_register(sm1, &dst_param->reg, dst_param->write_mask, true);
     }
     else if (ins->handler_idx == VKD3DSIH_DEFB)
     {
         shader_sm1_read_dst_param(sm1, &p, dst_param);
-        shader_sm1_read_immconst(sm1, &p, &src_params[0], VKD3D_IMMCONST_SCALAR, VKD3D_DATA_UINT);
+        shader_sm1_read_immconst(sm1, &p, &src_params[0], VSIR_DIMENSION_SCALAR, VKD3D_DATA_UINT);
         shader_sm1_scan_register(sm1, &dst_param->reg, dst_param->write_mask, true);
     }
     else if (ins->handler_idx == VKD3DSIH_DEFI)
     {
         shader_sm1_read_dst_param(sm1, &p, dst_param);
-        shader_sm1_read_immconst(sm1, &p, &src_params[0], VKD3D_IMMCONST_VEC4, VKD3D_DATA_INT);
+        shader_sm1_read_immconst(sm1, &p, &src_params[0], VSIR_DIMENSION_VEC4, VKD3D_DATA_INT);
         shader_sm1_scan_register(sm1, &dst_param->reg, dst_param->write_mask, true);
     }
     else
@@ -1250,7 +1261,7 @@ static enum vkd3d_result shader_sm1_init(struct vkd3d_shader_sm1_parser *sm1,
             return VKD3D_ERROR_INVALID_SHADER;
     }
 
-    if (!shader_ver_le(&version, 3, 0))
+    if (!vkd3d_shader_ver_le(&version, 3, 0))
     {
         vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_D3DBC_INVALID_VERSION_TOKEN,
                 "Invalid shader version %u.%u (token 0x%08x).", version.major, version.minor, code[0]);
@@ -1333,12 +1344,22 @@ int vkd3d_shader_sm1_parser_create(const struct vkd3d_shader_compile_info *compi
         ++instructions->count;
     }
 
-    *parser = &sm1->p;
-
     for (i = 0; i < ARRAY_SIZE(sm1->p.shader_desc.flat_constant_count); ++i)
         sm1->p.shader_desc.flat_constant_count[i].external = get_external_constant_count(sm1, i);
 
-    return sm1->p.failed ? VKD3D_ERROR_INVALID_SHADER : VKD3D_OK;
+    if (!sm1->p.failed)
+        vsir_validate(&sm1->p);
+
+    if (sm1->p.failed)
+    {
+        WARN("Failed to parse shader.\n");
+        shader_sm1_destroy(&sm1->p);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    *parser = &sm1->p;
+
+    return VKD3D_OK;
 }
 
 bool hlsl_sm1_register_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_semantic *semantic,
@@ -1811,6 +1832,37 @@ static void write_sm1_dp2add(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer
     write_sm1_instruction(ctx, buffer, &instr);
 }
 
+static void write_sm1_ternary_op(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *buffer,
+        D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode, const struct hlsl_reg *dst, const struct hlsl_reg *src1,
+        const struct hlsl_reg *src2, const struct hlsl_reg *src3)
+{
+    struct sm1_instruction instr =
+    {
+        .opcode = opcode,
+
+        .dst.type = D3DSPR_TEMP,
+        .dst.writemask = dst->writemask,
+        .dst.reg = dst->id,
+        .has_dst = 1,
+
+        .srcs[0].type = D3DSPR_TEMP,
+        .srcs[0].swizzle = hlsl_swizzle_from_writemask(src1->writemask),
+        .srcs[0].reg = src1->id,
+        .srcs[1].type = D3DSPR_TEMP,
+        .srcs[1].swizzle = hlsl_swizzle_from_writemask(src2->writemask),
+        .srcs[1].reg = src2->id,
+        .srcs[2].type = D3DSPR_TEMP,
+        .srcs[2].swizzle = hlsl_swizzle_from_writemask(src3->writemask),
+        .srcs[2].reg = src3->id,
+        .src_count = 3,
+    };
+
+    sm1_map_src_swizzle(&instr.srcs[0], instr.dst.writemask);
+    sm1_map_src_swizzle(&instr.srcs[1], instr.dst.writemask);
+    sm1_map_src_swizzle(&instr.srcs[2], instr.dst.writemask);
+    write_sm1_instruction(ctx, buffer, &instr);
+}
+
 static void write_sm1_binary_op(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *buffer,
         D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode, const struct hlsl_reg *dst,
         const struct hlsl_reg *src1, const struct hlsl_reg *src2)
@@ -2177,6 +2229,10 @@ static void write_sm1_expr(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *b
             }
             break;
 
+        case HLSL_OP3_CMP:
+            write_sm1_ternary_op(ctx, buffer, D3DSIO_CMP, &instr->reg, &arg1->reg, &arg2->reg, &arg3->reg);
+            break;
+
         case HLSL_OP3_DP2ADD:
             write_sm1_dp2add(ctx, buffer, &instr->reg, &arg1->reg, &arg2->reg, &arg3->reg);
             break;
@@ -2199,7 +2255,7 @@ static void write_sm1_jump(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *b
 
             struct sm1_instruction instr =
             {
-                .opcode = VKD3D_SM1_OP_TEXKILL,
+                .opcode = D3DSIO_TEXKILL,
 
                 .dst.type = D3DSPR_TEMP,
                 .dst.reg = reg->id,
@@ -2289,6 +2345,8 @@ static void write_sm1_resource_load(struct hlsl_ctx *ctx, struct vkd3d_bytecode_
 
         .src_count = 2,
     };
+    if (load->load_type == HLSL_RESOURCE_SAMPLE_PROJ)
+        sm1_instr.opcode |= VKD3DSI_TEXLD_PROJECT << VKD3D_SM1_INSTRUCTION_FLAGS_SHIFT;
 
     assert(instr->reg.allocated);
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxbc.c b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
index 1cb00688c76..7834c1e1615 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
@@ -94,16 +94,24 @@ static bool require_space(size_t offset, size_t count, size_t size, size_t data_
     return !count || (data_size - offset) / count >= size;
 }
 
-static void read_dword(const char **ptr, uint32_t *d)
+static uint32_t read_u32(const char **ptr)
 {
-    memcpy(d, *ptr, sizeof(*d));
-    *ptr += sizeof(*d);
+    unsigned int ret;
+    memcpy(&ret, *ptr, sizeof(ret));
+    *ptr += sizeof(ret);
+    return ret;
 }
 
-static void read_float(const char **ptr, float *f)
+static float read_float(const char **ptr)
 {
+    union
+    {
+        uint32_t i;
+        float f;
+    } u;
     STATIC_ASSERT(sizeof(float) == sizeof(uint32_t));
-    read_dword(ptr, (uint32_t *)f);
+    u.i = read_u32(ptr);
+    return u.f;
 }
 
 static void skip_dword_unknown(const char **ptr, unsigned int count)
@@ -117,7 +125,7 @@ static void skip_dword_unknown(const char **ptr, unsigned int count)
     WARN("Skipping %u unknown DWORDs:\n", count);
     for (i = 0; i < count; ++i)
     {
-        read_dword(ptr, &d);
+        d = read_u32(ptr);
         WARN("\t0x%08x\n", d);
     }
 }
@@ -164,7 +172,7 @@ static int parse_dxbc(const struct vkd3d_shader_code *dxbc, struct vkd3d_shader_
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
-    read_dword(&ptr, &tag);
+    tag = read_u32(&ptr);
     TRACE("tag: %#x.\n", tag);
 
     if (tag != TAG_DXBC)
@@ -174,10 +182,10 @@ static int parse_dxbc(const struct vkd3d_shader_code *dxbc, struct vkd3d_shader_
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
-    read_dword(&ptr, &checksum[0]);
-    read_dword(&ptr, &checksum[1]);
-    read_dword(&ptr, &checksum[2]);
-    read_dword(&ptr, &checksum[3]);
+    checksum[0] = read_u32(&ptr);
+    checksum[1] = read_u32(&ptr);
+    checksum[2] = read_u32(&ptr);
+    checksum[3] = read_u32(&ptr);
     vkd3d_compute_dxbc_checksum(data, data_size, calculated_checksum);
     if (memcmp(checksum, calculated_checksum, sizeof(checksum)))
     {
@@ -191,7 +199,7 @@ static int parse_dxbc(const struct vkd3d_shader_code *dxbc, struct vkd3d_shader_
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
-    read_dword(&ptr, &version);
+    version = read_u32(&ptr);
     TRACE("version: %#x.\n", version);
     if (version != 0x00000001)
     {
@@ -201,10 +209,10 @@ static int parse_dxbc(const struct vkd3d_shader_code *dxbc, struct vkd3d_shader_
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
-    read_dword(&ptr, &total_size);
+    total_size = read_u32(&ptr);
     TRACE("total size: %#x\n", total_size);
 
-    read_dword(&ptr, &chunk_count);
+    chunk_count = read_u32(&ptr);
     TRACE("chunk count: %#x\n", chunk_count);
 
     if (!(sections = vkd3d_calloc(chunk_count, sizeof(*sections))))
@@ -219,7 +227,7 @@ static int parse_dxbc(const struct vkd3d_shader_code *dxbc, struct vkd3d_shader_
         const char *chunk_ptr;
         uint32_t chunk_offset;
 
-        read_dword(&ptr, &chunk_offset);
+        chunk_offset = read_u32(&ptr);
         TRACE("chunk %u at offset %#x\n", i, chunk_offset);
 
         if (chunk_offset >= data_size || !require_space(chunk_offset, 2, sizeof(DWORD), data_size))
@@ -233,8 +241,8 @@ static int parse_dxbc(const struct vkd3d_shader_code *dxbc, struct vkd3d_shader_
 
         chunk_ptr = data + chunk_offset;
 
-        read_dword(&chunk_ptr, &chunk_tag);
-        read_dword(&chunk_ptr, &chunk_size);
+        chunk_tag = read_u32(&chunk_ptr);
+        chunk_size = read_u32(&chunk_ptr);
 
         if (!require_space(chunk_ptr - data, 1, chunk_size, data_size))
         {
@@ -359,10 +367,10 @@ static int shader_parse_signature(const struct vkd3d_shader_dxbc_section_desc *s
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
-    read_dword(&ptr, &count);
+    count = read_u32(&ptr);
     TRACE("%u elements.\n", count);
 
-    read_dword(&ptr, &header_size);
+    header_size = read_u32(&ptr);
     i = header_size / sizeof(uint32_t);
     if (align(header_size, sizeof(uint32_t)) != header_size || i < 2
             || !require_space(2, i - 2, sizeof(uint32_t), section->data.size))
@@ -396,24 +404,24 @@ static int shader_parse_signature(const struct vkd3d_shader_dxbc_section_desc *s
         e[i].sort_index = i;
 
         if (has_stream_index)
-            read_dword(&ptr, &e[i].stream_index);
+            e[i].stream_index = read_u32(&ptr);
         else
             e[i].stream_index = 0;
 
-        read_dword(&ptr, &name_offset);
+        name_offset = read_u32(&ptr);
         if (!(e[i].semantic_name = shader_get_string(data, section->data.size, name_offset)))
         {
             WARN("Invalid name offset %#x (data size %#zx).\n", name_offset, section->data.size);
             vkd3d_free(e);
             return VKD3D_ERROR_INVALID_ARGUMENT;
         }
-        read_dword(&ptr, &e[i].semantic_index);
-        read_dword(&ptr, &e[i].sysval_semantic);
-        read_dword(&ptr, &e[i].component_type);
-        read_dword(&ptr, &e[i].register_index);
+        e[i].semantic_index = read_u32(&ptr);
+        e[i].sysval_semantic = read_u32(&ptr);
+        e[i].component_type = read_u32(&ptr);
+        e[i].register_index = read_u32(&ptr);
         e[i].target_location = e[i].register_index;
         e[i].register_count = 1;
-        read_dword(&ptr, &mask);
+        mask = read_u32(&ptr);
         e[i].mask = mask & 0xff;
         e[i].used_mask = (mask >> 8) & 0xff;
         switch (section->tag)
@@ -431,10 +439,12 @@ static int shader_parse_signature(const struct vkd3d_shader_dxbc_section_desc *s
         }
 
         if (has_min_precision)
-            read_dword(&ptr, &e[i].min_precision);
+            e[i].min_precision = read_u32(&ptr);
         else
             e[i].min_precision = VKD3D_SHADER_MINIMUM_PRECISION_NONE;
 
+        e[i].interpolation_mode = VKD3DSIM_NONE;
+
         TRACE("Stream: %u, semantic: %s, semantic idx: %u, sysval_semantic %#x, "
                 "type %u, register idx: %u, use_mask %#x, input_mask %#x, precision %u.\n",
                 e[i].stream_index, debugstr_a(e[i].semantic_name), e[i].semantic_index, e[i].sysval_semantic,
@@ -452,7 +462,7 @@ static int isgn_handler(const struct vkd3d_shader_dxbc_section_desc *section,
 {
     struct shader_signature *is = ctx;
 
-    if (section->tag != TAG_ISGN)
+    if (section->tag != TAG_ISGN && section->tag != TAG_ISG1)
         return VKD3D_OK;
 
     if (is->elements)
@@ -595,11 +605,11 @@ static int shader_parse_descriptor_ranges(struct root_signature_parser_context *
 
     for (i = 0; i < count; ++i)
     {
-        read_dword(&ptr, &ranges[i].range_type);
-        read_dword(&ptr, &ranges[i].descriptor_count);
-        read_dword(&ptr, &ranges[i].base_shader_register);
-        read_dword(&ptr, &ranges[i].register_space);
-        read_dword(&ptr, &ranges[i].descriptor_table_offset);
+        ranges[i].range_type = read_u32(&ptr);
+        ranges[i].descriptor_count = read_u32(&ptr);
+        ranges[i].base_shader_register = read_u32(&ptr);
+        ranges[i].register_space = read_u32(&ptr);
+        ranges[i].descriptor_table_offset = read_u32(&ptr);
 
         TRACE("Type %#x, descriptor count %u, base shader register %u, "
                 "register space %u, offset %u.\n",
@@ -638,12 +648,12 @@ static int shader_parse_descriptor_ranges1(struct root_signature_parser_context
 
     for (i = 0; i < count; ++i)
     {
-        read_dword(&ptr, &ranges[i].range_type);
-        read_dword(&ptr, &ranges[i].descriptor_count);
-        read_dword(&ptr, &ranges[i].base_shader_register);
-        read_dword(&ptr, &ranges[i].register_space);
-        read_dword(&ptr, &ranges[i].flags);
-        read_dword(&ptr, &ranges[i].descriptor_table_offset);
+        ranges[i].range_type = read_u32(&ptr);
+        ranges[i].descriptor_count = read_u32(&ptr);
+        ranges[i].base_shader_register = read_u32(&ptr);
+        ranges[i].register_space = read_u32(&ptr);
+        ranges[i].flags = read_u32(&ptr);
+        ranges[i].descriptor_table_offset = read_u32(&ptr);
 
         TRACE("Type %#x, descriptor count %u, base shader register %u, "
                 "register space %u, flags %#x, offset %u.\n",
@@ -671,8 +681,8 @@ static int shader_parse_descriptor_table(struct root_signature_parser_context *c
     }
     ptr = &context->data[offset];
 
-    read_dword(&ptr, &count);
-    read_dword(&ptr, &offset);
+    count = read_u32(&ptr);
+    offset = read_u32(&ptr);
 
     TRACE("Descriptor range count %u.\n", count);
 
@@ -698,8 +708,8 @@ static int shader_parse_descriptor_table1(struct root_signature_parser_context *
     }
     ptr = &context->data[offset];
 
-    read_dword(&ptr, &count);
-    read_dword(&ptr, &offset);
+    count = read_u32(&ptr);
+    offset = read_u32(&ptr);
 
     TRACE("Descriptor range count %u.\n", count);
 
@@ -723,9 +733,9 @@ static int shader_parse_root_constants(struct root_signature_parser_context *con
     }
     ptr = &context->data[offset];
 
-    read_dword(&ptr, &constants->shader_register);
-    read_dword(&ptr, &constants->register_space);
-    read_dword(&ptr, &constants->value_count);
+    constants->shader_register = read_u32(&ptr);
+    constants->register_space = read_u32(&ptr);
+    constants->value_count = read_u32(&ptr);
 
     TRACE("Shader register %u, register space %u, 32-bit value count %u.\n",
             constants->shader_register, constants->register_space, constants->value_count);
@@ -745,8 +755,8 @@ static int shader_parse_root_descriptor(struct root_signature_parser_context *co
     }
     ptr = &context->data[offset];
 
-    read_dword(&ptr, &descriptor->shader_register);
-    read_dword(&ptr, &descriptor->register_space);
+    descriptor->shader_register = read_u32(&ptr);
+    descriptor->register_space = read_u32(&ptr);
 
     TRACE("Shader register %u, register space %u.\n",
             descriptor->shader_register, descriptor->register_space);
@@ -777,9 +787,9 @@ static int shader_parse_root_descriptor1(struct root_signature_parser_context *c
     }
     ptr = &context->data[offset];
 
-    read_dword(&ptr, &descriptor->shader_register);
-    read_dword(&ptr, &descriptor->register_space);
-    read_dword(&ptr, &descriptor->flags);
+    descriptor->shader_register = read_u32(&ptr);
+    descriptor->register_space = read_u32(&ptr);
+    descriptor->flags = read_u32(&ptr);
 
     TRACE("Shader register %u, register space %u, flags %#x.\n",
             descriptor->shader_register, descriptor->register_space, descriptor->flags);
@@ -805,9 +815,9 @@ static int shader_parse_root_parameters(struct root_signature_parser_context *co
 
     for (i = 0; i < count; ++i)
     {
-        read_dword(&ptr, &parameters[i].parameter_type);
-        read_dword(&ptr, &parameters[i].shader_visibility);
-        read_dword(&ptr, &offset);
+        parameters[i].parameter_type = read_u32(&ptr);
+        parameters[i].shader_visibility = read_u32(&ptr);
+        offset = read_u32(&ptr);
 
         TRACE("Type %#x, shader visibility %#x.\n",
                 parameters[i].parameter_type, parameters[i].shader_visibility);
@@ -853,9 +863,9 @@ static int shader_parse_root_parameters1(struct root_signature_parser_context *c
 
     for (i = 0; i < count; ++i)
     {
-        read_dword(&ptr, &parameters[i].parameter_type);
-        read_dword(&ptr, &parameters[i].shader_visibility);
-        read_dword(&ptr, &offset);
+        parameters[i].parameter_type = read_u32(&ptr);
+        parameters[i].shader_visibility = read_u32(&ptr);
+        offset = read_u32(&ptr);
 
         TRACE("Type %#x, shader visibility %#x.\n",
                 parameters[i].parameter_type, parameters[i].shader_visibility);
@@ -900,19 +910,19 @@ static int shader_parse_static_samplers(struct root_signature_parser_context *co
 
     for (i = 0; i < count; ++i)
     {
-        read_dword(&ptr, &sampler_descs[i].filter);
-        read_dword(&ptr, &sampler_descs[i].address_u);
-        read_dword(&ptr, &sampler_descs[i].address_v);
-        read_dword(&ptr, &sampler_descs[i].address_w);
-        read_float(&ptr, &sampler_descs[i].mip_lod_bias);
-        read_dword(&ptr, &sampler_descs[i].max_anisotropy);
-        read_dword(&ptr, &sampler_descs[i].comparison_func);
-        read_dword(&ptr, &sampler_descs[i].border_colour);
-        read_float(&ptr, &sampler_descs[i].min_lod);
-        read_float(&ptr, &sampler_descs[i].max_lod);
-        read_dword(&ptr, &sampler_descs[i].shader_register);
-        read_dword(&ptr, &sampler_descs[i].register_space);
-        read_dword(&ptr, &sampler_descs[i].shader_visibility);
+        sampler_descs[i].filter = read_u32(&ptr);
+        sampler_descs[i].address_u = read_u32(&ptr);
+        sampler_descs[i].address_v = read_u32(&ptr);
+        sampler_descs[i].address_w = read_u32(&ptr);
+        sampler_descs[i].mip_lod_bias = read_float(&ptr);
+        sampler_descs[i].max_anisotropy = read_u32(&ptr);
+        sampler_descs[i].comparison_func = read_u32(&ptr);
+        sampler_descs[i].border_colour = read_u32(&ptr);
+        sampler_descs[i].min_lod = read_float(&ptr);
+        sampler_descs[i].max_lod = read_float(&ptr);
+        sampler_descs[i].shader_register = read_u32(&ptr);
+        sampler_descs[i].register_space = read_u32(&ptr);
+        sampler_descs[i].shader_visibility = read_u32(&ptr);
     }
 
     return VKD3D_OK;
@@ -936,7 +946,7 @@ static int shader_parse_root_signature(const struct vkd3d_shader_code *data,
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
-    read_dword(&ptr, &version);
+    version = read_u32(&ptr);
     TRACE("Version %#x.\n", version);
     if (version != VKD3D_SHADER_ROOT_SIGNATURE_VERSION_1_0 && version != VKD3D_SHADER_ROOT_SIGNATURE_VERSION_1_1)
     {
@@ -945,8 +955,8 @@ static int shader_parse_root_signature(const struct vkd3d_shader_code *data,
     }
     desc->version = version;
 
-    read_dword(&ptr, &count);
-    read_dword(&ptr, &offset);
+    count = read_u32(&ptr);
+    offset = read_u32(&ptr);
     TRACE("Parameter count %u, offset %u.\n", count, offset);
 
     if (desc->version == VKD3D_SHADER_ROOT_SIGNATURE_VERSION_1_0)
@@ -980,8 +990,8 @@ static int shader_parse_root_signature(const struct vkd3d_shader_code *data,
         }
     }
 
-    read_dword(&ptr, &count);
-    read_dword(&ptr, &offset);
+    count = read_u32(&ptr);
+    offset = read_u32(&ptr);
     TRACE("Static sampler count %u, offset %u.\n", count, offset);
 
     v_1_0->static_sampler_count = count;
@@ -995,7 +1005,7 @@ static int shader_parse_root_signature(const struct vkd3d_shader_code *data,
             return ret;
     }
 
-    read_dword(&ptr, &v_1_0->flags);
+    v_1_0->flags = read_u32(&ptr);
     TRACE("Flags %#x.\n", v_1_0->flags);
 
     return VKD3D_OK;
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index b78c78d34a7..1709212fa99 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -20,9 +20,18 @@
 
 #define VKD3D_SM6_VERSION_MAJOR(version) (((version) >> 4) & 0xf)
 #define VKD3D_SM6_VERSION_MINOR(version) (((version) >> 0) & 0xf)
+/* Two seems to be the maximum but leave some extra room. */
+#define VKD3D_SM6_MAX_METADATA_TABLES 4
 
 #define BITCODE_MAGIC VKD3D_MAKE_TAG('B', 'C', 0xc0, 0xde)
 #define DXIL_OP_MAX_OPERANDS 17
+static const uint64_t MAX_ALIGNMENT_EXPONENT = 29;
+static const uint64_t GLOBALVAR_FLAG_IS_CONSTANT = 1;
+static const uint64_t GLOBALVAR_FLAG_EXPLICIT_TYPE = 2;
+static const unsigned int GLOBALVAR_ADDRESS_SPACE_SHIFT = 2;
+static const unsigned int SHADER_DESCRIPTOR_TYPE_COUNT = 4;
+
+static const unsigned int dx_max_thread_group_size[3] = {1024, 1024, 64};
 
 enum bitcode_block_id
 {
@@ -114,6 +123,19 @@ enum bitcode_function_code
     FUNC_CODE_INST_CMPXCHG     = 46,
 };
 
+enum bitcode_metadata_code
+{
+    METADATA_STRING             =  1,
+    METADATA_VALUE              =  2,
+    METADATA_NODE               =  3,
+    METADATA_NAME               =  4,
+    METADATA_DISTINCT_NODE      =  5,
+    METADATA_KIND               =  6,
+    METADATA_LOCATION           =  7,
+    METADATA_NAMED_NODE         = 10,
+    METADATA_ATTACHMENT         = 11,
+};
+
 enum bitcode_type_code
 {
     TYPE_CODE_NUMENTRY     =  1,
@@ -139,9 +161,190 @@ enum bitcode_value_symtab_code
     VST_CODE_BBENTRY = 2,
 };
 
+enum bitcode_linkage
+{
+    LINKAGE_EXTERNAL  = 0,
+    LINKAGE_APPENDING = 2,
+    LINKAGE_INTERNAL  = 3,
+};
+
+enum dxil_component_type
+{
+    COMPONENT_TYPE_INVALID     =  0,
+    COMPONENT_TYPE_I1          =  1,
+    COMPONENT_TYPE_I16         =  2,
+    COMPONENT_TYPE_U16         =  3,
+    COMPONENT_TYPE_I32         =  4,
+    COMPONENT_TYPE_U32         =  5,
+    COMPONENT_TYPE_I64         =  6,
+    COMPONENT_TYPE_U64         =  7,
+    COMPONENT_TYPE_F16         =  8,
+    COMPONENT_TYPE_F32         =  9,
+    COMPONENT_TYPE_F64         = 10,
+    COMPONENT_TYPE_SNORMF16    = 11,
+    COMPONENT_TYPE_UNORMF16    = 12,
+    COMPONENT_TYPE_SNORMF32    = 13,
+    COMPONENT_TYPE_UNORMF32    = 14,
+    COMPONENT_TYPE_SNORMF64    = 15,
+    COMPONENT_TYPE_UNORMF64    = 16,
+    COMPONENT_TYPE_PACKEDS8X32 = 17,
+    COMPONENT_TYPE_PACKEDU8X32 = 18,
+};
+
+enum dxil_semantic_kind
+{
+    SEMANTIC_KIND_ARBITRARY            =  0,
+    SEMANTIC_KIND_VERTEXID             =  1,
+    SEMANTIC_KIND_INSTANCEID           =  2,
+    SEMANTIC_KIND_POSITION             =  3,
+    SEMANTIC_KIND_RTARRAYINDEX         =  4,
+    SEMANTIC_KIND_VIEWPORTARRAYINDEX   =  5,
+    SEMANTIC_KIND_CLIPDISTANCE         =  6,
+    SEMANTIC_KIND_CULLDISTANCE         =  7,
+    SEMANTIC_KIND_OUTPUTCONTROLPOINTID =  8,
+    SEMANTIC_KIND_DOMAINLOCATION       =  9,
+    SEMANTIC_KIND_PRIMITIVEID          = 10,
+    SEMANTIC_KIND_GSINSTANCEID         = 11,
+    SEMANTIC_KIND_SAMPLEINDEX          = 12,
+    SEMANTIC_KIND_ISFRONTFACE          = 13,
+    SEMANTIC_KIND_COVERAGE             = 14,
+    SEMANTIC_KIND_INNERCOVERAGE        = 15,
+    SEMANTIC_KIND_TARGET               = 16,
+    SEMANTIC_KIND_DEPTH                = 17,
+    SEMANTIC_KIND_DEPTHLESSEQUAL       = 18,
+    SEMANTIC_KIND_DEPTHGREATEREQUAL    = 19,
+    SEMANTIC_KIND_STENCILREF           = 20,
+    SEMANTIC_KIND_DISPATCHTHREADID     = 21,
+    SEMANTIC_KIND_GROUPID              = 22,
+    SEMANTIC_KIND_GROUPINDEX           = 23,
+    SEMANTIC_KIND_GROUPTHREADID        = 24,
+    SEMANTIC_KIND_TESSFACTOR           = 25,
+    SEMANTIC_KIND_INSIDETESSFACTOR     = 26,
+    SEMANTIC_KIND_VIEWID               = 27,
+    SEMANTIC_KIND_BARYCENTRICS         = 28,
+    SEMANTIC_KIND_SHADINGRATE          = 29,
+    SEMANTIC_KIND_CULLPRIMITIVE        = 30,
+    SEMANTIC_KIND_COUNT                = 31,
+    SEMANTIC_KIND_INVALID              = SEMANTIC_KIND_COUNT,
+};
+
+enum dxil_element_additional_tag
+{
+    ADDITIONAL_TAG_STREAM_INDEX  = 0,
+    ADDITIONAL_TAG_GLOBAL_SYMBOL = 1, /* not used */
+    ADDITIONAL_TAG_RELADDR_MASK  = 2,
+    ADDITIONAL_TAG_USED_MASK     = 3,
+};
+
+enum dxil_shader_properties_tag
+{
+    SHADER_PROPERTIES_FLAGS              =  0,
+    SHADER_PROPERTIES_GEOMETRY           =  1,
+    SHADER_PROPERTIES_DOMAIN             =  2,
+    SHADER_PROPERTIES_HULL               =  3,
+    SHADER_PROPERTIES_COMPUTE            =  4,
+    SHADER_PROPERTIES_AUTO_BINDING_SPACE =  5,
+    SHADER_PROPERTIES_RAY_PAYLOAD_SIZE   =  6,
+    SHADER_PROPERTIES_RAY_ATTRIB_SIZE    =  7,
+    SHADER_PROPERTIES_SHADER_KIND        =  8,
+    SHADER_PROPERTIES_MESH               =  9,
+    SHADER_PROPERTIES_AMPLIFICATION      = 10,
+    SHADER_PROPERTIES_WAVE_SIZE          = 11,
+    SHADER_PROPERTIES_ENTRY_ROOT_SIG     = 12,
+};
+
+enum dxil_binop_code
+{
+    BINOP_ADD  =  0,
+    BINOP_SUB  =  1,
+    BINOP_MUL  =  2,
+    BINOP_UDIV =  3,
+    BINOP_SDIV =  4,
+    BINOP_UREM =  5,
+    BINOP_SREM =  6,
+    BINOP_SHL  =  7,
+    BINOP_LSHR =  8,
+    BINOP_ASHR =  9,
+    BINOP_AND  = 10,
+    BINOP_OR   = 11,
+    BINOP_XOR  = 12
+};
+
+enum dxil_fast_fp_flags
+{
+    FP_ALLOW_UNSAFE_ALGEBRA =  0x1,
+    FP_NO_NAN               =  0x2,
+    FP_NO_INF               =  0x4,
+    FP_NO_SIGNED_ZEROS      =  0x8,
+    FP_ALLOW_RECIPROCAL     = 0x10,
+};
+
+enum dxil_overflowing_binop_flags
+{
+    /* Operation is known to never overflow. */
+    OB_NO_UNSIGNED_WRAP = 0x1,
+    OB_NO_SIGNED_WRAP   = 0x2,
+};
+
+enum dxil_possibly_exact_binop_flags
+{
+    /* "A udiv or sdiv instruction, which can be marked as "exact", indicating that no bits are destroyed." */
+    PEB_EXACT = 0x1,
+};
+
 enum dx_intrinsic_opcode
 {
+    DX_LOAD_INPUT                   =   4,
     DX_STORE_OUTPUT                 =   5,
+    DX_CREATE_HANDLE                =  57,
+    DX_CBUFFER_LOAD_LEGACY          =  59,
+};
+
+enum dxil_cast_code
+{
+    CAST_TRUNC    =  0,
+    CAST_ZEXT     =  1,
+    CAST_SEXT     =  2,
+    CAST_FPTOUI   =  3,
+    CAST_FPTOSI   =  4,
+    CAST_UITOFP   =  5,
+    CAST_SITOFP   =  6,
+    CAST_FPTRUNC  =  7,
+    CAST_FPEXT    =  8,
+    CAST_PTRTOINT =  9,
+    CAST_INTTOPTR = 10,
+    CAST_BITCAST  = 11,
+    CAST_ADDRSPACECAST = 12,
+};
+
+enum dxil_predicate
+{
+    FCMP_FALSE =  0,
+    FCMP_OEQ   =  1,
+    FCMP_OGT   =  2,
+    FCMP_OGE   =  3,
+    FCMP_OLT   =  4,
+    FCMP_OLE   =  5,
+    FCMP_ONE   =  6,
+    FCMP_ORD   =  7,
+    FCMP_UNO   =  8,
+    FCMP_UEQ   =  9,
+    FCMP_UGT   = 10,
+    FCMP_UGE   = 11,
+    FCMP_ULT   = 12,
+    FCMP_ULE   = 13,
+    FCMP_UNE   = 14,
+    FCMP_TRUE  = 15,
+    ICMP_EQ    = 32,
+    ICMP_NE    = 33,
+    ICMP_UGT   = 34,
+    ICMP_UGE   = 35,
+    ICMP_ULT   = 36,
+    ICMP_ULE   = 37,
+    ICMP_SGT   = 38,
+    ICMP_SGE   = 39,
+    ICMP_SLT   = 40,
+    ICMP_SLE   = 41,
 };
 
 struct sm6_pointer_info
@@ -201,6 +404,8 @@ enum sm6_value_type
 {
     VALUE_TYPE_FUNCTION,
     VALUE_TYPE_REG,
+    VALUE_TYPE_ICB,
+    VALUE_TYPE_HANDLE,
 };
 
 struct sm6_function_data
@@ -210,6 +415,12 @@ struct sm6_function_data
     unsigned int attribs_id;
 };
 
+struct sm6_handle_data
+{
+    const struct sm6_descriptor_info *d;
+    struct vkd3d_shader_register reg;
+};
+
 struct sm6_value
 {
     const struct sm6_type *type;
@@ -219,6 +430,8 @@ struct sm6_value
     {
         struct sm6_function_data function;
         struct vkd3d_shader_register reg;
+        const struct vkd3d_shader_immediate_constant_buffer *icb;
+        struct sm6_handle_data handle;
     } u;
 };
 
@@ -277,6 +490,59 @@ struct dxil_block
     size_t record_count;
 };
 
+enum sm6_metadata_type
+{
+    VKD3D_METADATA_KIND,
+    VKD3D_METADATA_NODE,
+    VKD3D_METADATA_STRING,
+    VKD3D_METADATA_VALUE,
+};
+
+struct sm6_metadata_node
+{
+    bool is_distinct;
+    unsigned int operand_count;
+    struct sm6_metadata_value *operands[];
+};
+
+struct sm6_metadata_kind
+{
+    uint64_t id;
+    char *name;
+};
+
+struct sm6_metadata_value
+{
+    enum sm6_metadata_type type;
+    const struct sm6_type *value_type;
+    union
+    {
+        char *string_value;
+        const struct sm6_value *value;
+        struct sm6_metadata_node *node;
+        struct sm6_metadata_kind kind;
+    } u;
+};
+
+struct sm6_metadata_table
+{
+    struct sm6_metadata_value *values;
+    unsigned int count;
+};
+
+struct sm6_named_metadata
+{
+    char *name;
+    struct sm6_metadata_value value;
+};
+
+struct sm6_descriptor_info
+{
+    enum vkd3d_shader_descriptor_type type;
+    unsigned int id;
+    struct vkd3d_shader_register_range range;
+};
+
 struct sm6_parser
 {
     const uint32_t *ptr, *start, *end;
@@ -291,19 +557,36 @@ struct sm6_parser
 
     struct sm6_type *types;
     size_t type_count;
+    struct sm6_type *bool_type;
+    struct sm6_type *metadata_type;
+    struct sm6_type *handle_type;
 
     struct sm6_symbol *global_symbols;
     size_t global_symbol_count;
 
+    const char *entry_point;
+
     struct vkd3d_shader_dst_param *output_params;
+    struct vkd3d_shader_dst_param *input_params;
 
     struct sm6_function *functions;
     size_t function_count;
 
+    struct sm6_metadata_table metadata_tables[VKD3D_SM6_MAX_METADATA_TABLES];
+    struct sm6_named_metadata *named_metadata;
+    unsigned int named_metadata_count;
+
+    struct sm6_descriptor_info *descriptors;
+    size_t descriptor_capacity;
+    size_t descriptor_count;
+
+    unsigned int indexable_temp_count;
+
     struct sm6_value *values;
     size_t value_count;
     size_t value_capacity;
     size_t cur_max_value;
+    unsigned int ssa_next_id;
 
     struct vkd3d_shader_parser p;
 };
@@ -970,14 +1253,18 @@ static const struct dxil_block *sm6_parser_get_level_one_block(const struct sm6_
     return found;
 }
 
-static char *dxil_record_to_string(const struct dxil_record *record, unsigned int offset)
+static char *dxil_record_to_string(const struct dxil_record *record, unsigned int offset, struct sm6_parser *sm6)
 {
     unsigned int i;
     char *str;
 
     assert(offset <= record->operand_count);
     if (!(str = vkd3d_calloc(record->operand_count - offset + 1, 1)))
+    {
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Out of memory allocating a string of length %u.", record->operand_count - offset);
         return NULL;
+    }
 
     for (i = offset; i < record->operand_count; ++i)
         str[i - offset] = record->operands[i];
@@ -1147,6 +1434,8 @@ static enum vkd3d_result sm6_parser_type_table_init(struct sm6_parser *sm6)
                 switch ((width = record->operands[0]))
                 {
                     case 1:
+                        sm6->bool_type = type;
+                        break;
                     case 8:
                     case 16:
                     case 32:
@@ -1166,6 +1455,7 @@ static enum vkd3d_result sm6_parser_type_table_init(struct sm6_parser *sm6)
 
             case TYPE_CODE_METADATA:
                 type->class = TYPE_CLASS_METADATA;
+                sm6->metadata_type = type;
                 break;
 
             case TYPE_CODE_NUMENTRY:
@@ -1188,7 +1478,7 @@ static enum vkd3d_result sm6_parser_type_table_init(struct sm6_parser *sm6)
 
             case TYPE_CODE_STRUCT_ANON:
             case TYPE_CODE_STRUCT_NAMED:
-                if (!dxil_record_validate_operand_min_count(record, 2, sm6))
+                if (!dxil_record_validate_operand_min_count(record, 1, sm6))
                     return VKD3D_ERROR_INVALID_SHADER;
                 if (record->code == TYPE_CODE_STRUCT_NAMED && !struct_name)
                 {
@@ -1227,12 +1517,15 @@ static enum vkd3d_result sm6_parser_type_table_init(struct sm6_parser *sm6)
                     break;
                 }
 
+                if (!ascii_strcasecmp(struct_name, "dx.types.Handle"))
+                    sm6->handle_type = type;
+
                 type->u.struc->name = struct_name;
                 struct_name = NULL;
                 break;
 
             case TYPE_CODE_STRUCT_NAME:
-                if (!(struct_name = dxil_record_to_string(record, 0)))
+                if (!(struct_name = dxil_record_to_string(record, 0, sm6)))
                 {
                     ERR("Failed to allocate struct name.\n");
                     return VKD3D_ERROR_OUT_OF_MEMORY;
@@ -1274,6 +1567,16 @@ static inline bool sm6_type_is_integer(const struct sm6_type *type)
     return type->class == TYPE_CLASS_INTEGER;
 }
 
+static bool sm6_type_is_bool_i16_i32_i64(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_INTEGER && (type->u.width == 1 || type->u.width >= 16);
+}
+
+static bool sm6_type_is_bool(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_INTEGER && type->u.width == 1;
+}
+
 static inline bool sm6_type_is_i8(const struct sm6_type *type)
 {
     return type->class == TYPE_CLASS_INTEGER && type->u.width == 8;
@@ -1289,6 +1592,11 @@ static inline bool sm6_type_is_floating_point(const struct sm6_type *type)
     return type->class == TYPE_CLASS_FLOAT;
 }
 
+static bool sm6_type_is_scalar(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_INTEGER || type->class == TYPE_CLASS_FLOAT || type->class == TYPE_CLASS_POINTER;
+}
+
 static inline bool sm6_type_is_numeric(const struct sm6_type *type)
 {
     return type->class == TYPE_CLASS_INTEGER || type->class == TYPE_CLASS_FLOAT;
@@ -1299,6 +1607,11 @@ static inline bool sm6_type_is_pointer(const struct sm6_type *type)
     return type->class == TYPE_CLASS_POINTER;
 }
 
+static bool sm6_type_is_aggregate(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_STRUCT || type->class == TYPE_CLASS_VECTOR || type->class == TYPE_CLASS_ARRAY;
+}
+
 static bool sm6_type_is_numeric_aggregate(const struct sm6_type *type)
 {
     unsigned int i;
@@ -1321,6 +1634,11 @@ static bool sm6_type_is_numeric_aggregate(const struct sm6_type *type)
     }
 }
 
+static bool sm6_type_is_array(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_ARRAY;
+}
+
 static inline bool sm6_type_is_struct(const struct sm6_type *type)
 {
     return type->class == TYPE_CLASS_STRUCT;
@@ -1364,6 +1682,27 @@ static const struct sm6_type *sm6_type_get_pointer_to_type(const struct sm6_type
     return NULL;
 }
 
+/* Call for aggregate types only. */
+static const struct sm6_type *sm6_type_get_element_type_at_index(const struct sm6_type *type, uint64_t elem_idx)
+{
+    switch (type->class)
+    {
+        case TYPE_CLASS_ARRAY:
+        case TYPE_CLASS_VECTOR:
+            if (elem_idx >= type->u.array.count)
+                return NULL;
+            return type->u.array.elem_type;
+
+        case TYPE_CLASS_STRUCT:
+            if (elem_idx >= type->u.struc->elem_count)
+                return NULL;
+            return type->u.struc->elem_types[elem_idx];
+
+        default:
+            vkd3d_unreachable();
+    }
+}
+
 /* Never returns null for elem_idx 0. */
 static const struct sm6_type *sm6_type_get_scalar_type(const struct sm6_type *type, unsigned int elem_idx)
 {
@@ -1388,6 +1727,11 @@ static const struct sm6_type *sm6_type_get_scalar_type(const struct sm6_type *ty
     }
 }
 
+static unsigned int sm6_type_max_vector_size(const struct sm6_type *type)
+{
+    return min((VKD3D_VEC4_SIZE * sizeof(uint32_t) * CHAR_BIT) / type->u.width, VKD3D_VEC4_SIZE);
+}
+
 static const struct sm6_type *sm6_parser_get_type(struct sm6_parser *sm6, uint64_t type_id)
 {
     if (type_id >= sm6->type_count)
@@ -1451,7 +1795,7 @@ static enum vkd3d_result sm6_parser_symtab_init(struct sm6_parser *sm6)
 
         symbol = &sm6->global_symbols[sm6->global_symbol_count];
         symbol->id = record->operands[0];
-        if (!(symbol->name = dxil_record_to_string(record, 1)))
+        if (!(symbol->name = dxil_record_to_string(record, 1, sm6)))
         {
             ERR("Failed to allocate symbol name.\n");
             return VKD3D_ERROR_OUT_OF_MEMORY;
@@ -1492,10 +1836,10 @@ static const char *sm6_parser_get_global_symbol_name(const struct sm6_parser *sm
 
 static unsigned int register_get_uint_value(const struct vkd3d_shader_register *reg)
 {
-    if (!register_is_constant(reg) || !data_type_is_integer(reg->data_type))
+    if (!register_is_constant(reg) || (!data_type_is_integer(reg->data_type) && !data_type_is_bool(reg->data_type)))
         return UINT_MAX;
 
-    if (reg->immconst_type == VKD3D_IMMCONST_VEC4)
+    if (reg->dimension == VSIR_DIMENSION_VEC4)
         WARN("Returning vec4.x.\n");
 
     if (reg->type == VKD3DSPR_IMMCONST64)
@@ -1508,6 +1852,17 @@ static unsigned int register_get_uint_value(const struct vkd3d_shader_register *
     return reg->u.immconst_uint[0];
 }
 
+static uint64_t register_get_uint64_value(const struct vkd3d_shader_register *reg)
+{
+    if (!register_is_constant(reg) || !data_type_is_integer(reg->data_type))
+        return UINT64_MAX;
+
+    if (reg->dimension == VSIR_DIMENSION_VEC4)
+        WARN("Returning vec4.x.\n");
+
+    return (reg->type == VKD3DSPR_IMMCONST64) ? reg->u.immconst_uint64[0] : reg->u.immconst_uint[0];
+}
+
 static inline bool sm6_value_is_function_dcl(const struct sm6_value *value)
 {
     return value->value_type == VALUE_TYPE_FUNCTION;
@@ -1530,6 +1885,11 @@ static inline bool sm6_value_is_register(const struct sm6_value *value)
     return value->value_type == VALUE_TYPE_REG;
 }
 
+static bool sm6_value_is_handle(const struct sm6_value *value)
+{
+    return value->value_type == VALUE_TYPE_HANDLE;
+}
+
 static inline bool sm6_value_is_constant(const struct sm6_value *value)
 {
     return sm6_value_is_register(value) && register_is_constant(&value->u.reg);
@@ -1540,6 +1900,11 @@ static inline bool sm6_value_is_undef(const struct sm6_value *value)
     return sm6_value_is_register(value) && value->u.reg.type == VKD3DSPR_UNDEF;
 }
 
+static bool sm6_value_is_icb(const struct sm6_value *value)
+{
+    return value->value_type == VALUE_TYPE_ICB;
+}
+
 static inline unsigned int sm6_value_get_constant_uint(const struct sm6_value *value)
 {
     if (!sm6_value_is_constant(value))
@@ -1547,6 +1912,11 @@ static inline unsigned int sm6_value_get_constant_uint(const struct sm6_value *v
     return register_get_uint_value(&value->u.reg);
 }
 
+static unsigned int sm6_parser_alloc_ssa_id(struct sm6_parser *sm6)
+{
+    return sm6->ssa_next_id++;
+}
+
 static struct vkd3d_shader_src_param *instruction_src_params_alloc(struct vkd3d_shader_instruction *ins,
         unsigned int count, struct sm6_parser *sm6)
 {
@@ -1555,7 +1925,7 @@ static struct vkd3d_shader_src_param *instruction_src_params_alloc(struct vkd3d_
     {
         ERR("Failed to allocate src params.\n");
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
-                "Out of memory allocating instruction src paramaters.");
+                "Out of memory allocating instruction src parameters.");
         return NULL;
     }
     ins->src = params;
@@ -1571,7 +1941,7 @@ static struct vkd3d_shader_dst_param *instruction_dst_params_alloc(struct vkd3d_
     {
         ERR("Failed to allocate dst params.\n");
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
-                "Out of memory allocating instruction dst paramaters.");
+                "Out of memory allocating instruction dst parameters.");
         return NULL;
     }
     ins->dst = params;
@@ -1579,16 +1949,27 @@ static struct vkd3d_shader_dst_param *instruction_dst_params_alloc(struct vkd3d_
     return params;
 }
 
+static void register_init_with_id(struct vkd3d_shader_register *reg,
+        enum vkd3d_shader_register_type reg_type, enum vkd3d_data_type data_type, unsigned int id)
+{
+    vsir_register_init(reg, reg_type, data_type, 1);
+    reg->idx[0].offset = id;
+}
+
 static enum vkd3d_data_type vkd3d_data_type_from_sm6_type(const struct sm6_type *type)
 {
     if (type->class == TYPE_CLASS_INTEGER)
     {
         switch (type->u.width)
         {
+            case 1:
+                return VKD3D_DATA_BOOL;
             case 8:
                 return VKD3D_DATA_UINT8;
             case 32:
                 return VKD3D_DATA_UINT;
+            case 64:
+                return VKD3D_DATA_UINT64;
             default:
                 FIXME("Unhandled width %u.\n", type->u.width);
                 return VKD3D_DATA_UINT;
@@ -1612,6 +1993,31 @@ static enum vkd3d_data_type vkd3d_data_type_from_sm6_type(const struct sm6_type
     return VKD3D_DATA_UINT;
 }
 
+static void register_init_ssa_vector(struct vkd3d_shader_register *reg, const struct sm6_type *type,
+        unsigned int component_count, struct sm6_parser *sm6)
+{
+    enum vkd3d_data_type data_type;
+    unsigned int id;
+
+    id = sm6_parser_alloc_ssa_id(sm6);
+    data_type = vkd3d_data_type_from_sm6_type(sm6_type_get_scalar_type(type, 0));
+    register_init_with_id(reg, VKD3DSPR_SSA, data_type, id);
+    reg->dimension = component_count > 1 ? VSIR_DIMENSION_VEC4 : VSIR_DIMENSION_SCALAR;
+}
+
+static void register_init_ssa_scalar(struct vkd3d_shader_register *reg, const struct sm6_type *type,
+        struct sm6_parser *sm6)
+{
+    register_init_ssa_vector(reg, type, 1, sm6);
+}
+
+static void dst_param_init(struct vkd3d_shader_dst_param *param)
+{
+    param->write_mask = VKD3DSP_WRITEMASK_0;
+    param->modifiers = 0;
+    param->shift = 0;
+}
+
 static inline void dst_param_init_scalar(struct vkd3d_shader_dst_param *param, unsigned int component_idx)
 {
     param->write_mask = 1u << component_idx;
@@ -1619,40 +2025,88 @@ static inline void dst_param_init_scalar(struct vkd3d_shader_dst_param *param, u
     param->shift = 0;
 }
 
+static void dst_param_init_vector(struct vkd3d_shader_dst_param *param, unsigned int component_count)
+{
+    param->write_mask = (1u << component_count) - 1;
+    param->modifiers = 0;
+    param->shift = 0;
+}
+
+static void dst_param_init_ssa_scalar(struct vkd3d_shader_dst_param *param, const struct sm6_type *type,
+        struct sm6_parser *sm6)
+{
+    dst_param_init(param);
+    register_init_ssa_scalar(&param->reg, type, sm6);
+}
+
 static inline void src_param_init(struct vkd3d_shader_src_param *param)
 {
     param->swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
     param->modifiers = VKD3DSPSM_NONE;
 }
 
+static void src_param_init_scalar(struct vkd3d_shader_src_param *param, unsigned int component_idx)
+{
+    param->swizzle = vkd3d_shader_create_swizzle(component_idx, component_idx, component_idx, component_idx);
+    param->modifiers = VKD3DSPSM_NONE;
+}
+
 static void src_param_init_from_value(struct vkd3d_shader_src_param *param, const struct sm6_value *src)
 {
     src_param_init(param);
     param->reg = src->u.reg;
 }
 
-static void register_address_init(struct vkd3d_shader_register *reg, const struct sm6_value *address,
-        unsigned int idx, struct sm6_parser *sm6)
+static void src_param_init_vector_from_reg(struct vkd3d_shader_src_param *param,
+        const struct vkd3d_shader_register *reg)
+{
+    param->swizzle = VKD3D_SHADER_NO_SWIZZLE;
+    param->modifiers = VKD3DSPSM_NONE;
+    param->reg = *reg;
+}
+
+static void register_index_address_init(struct vkd3d_shader_register_index *idx, const struct sm6_value *address,
+        struct sm6_parser *sm6)
 {
-    assert(idx < ARRAY_SIZE(reg->idx));
     if (sm6_value_is_constant(address))
     {
-        reg->idx[idx].offset = sm6_value_get_constant_uint(address);
+        idx->offset = sm6_value_get_constant_uint(address);
     }
     else if (sm6_value_is_undef(address))
     {
-        reg->idx[idx].offset = 0;
+        idx->offset = 0;
     }
     else
     {
         struct vkd3d_shader_src_param *rel_addr = shader_parser_get_src_params(&sm6->p, 1);
         if (rel_addr)
             src_param_init_from_value(rel_addr, address);
-        reg->idx[idx].offset = 0;
-        reg->idx[idx].rel_addr = rel_addr;
+        idx->offset = 0;
+        idx->rel_addr = rel_addr;
     }
 }
 
+static void instruction_dst_param_init_ssa_scalar(struct vkd3d_shader_instruction *ins, struct sm6_parser *sm6)
+{
+    struct vkd3d_shader_dst_param *param = instruction_dst_params_alloc(ins, 1, sm6);
+    struct sm6_value *dst = sm6_parser_get_current_value(sm6);
+
+    dst_param_init_ssa_scalar(param, dst->type, sm6);
+    param->write_mask = VKD3DSP_WRITEMASK_0;
+    dst->u.reg = param->reg;
+}
+
+static void instruction_dst_param_init_ssa_vector(struct vkd3d_shader_instruction *ins,
+        unsigned int component_count, struct sm6_parser *sm6)
+{
+    struct vkd3d_shader_dst_param *param = instruction_dst_params_alloc(ins, 1, sm6);
+    struct sm6_value *dst = sm6_parser_get_current_value(sm6);
+
+    dst_param_init_vector(param, component_count);
+    register_init_ssa_vector(&param->reg, sm6_type_get_scalar_type(dst->type, 0), component_count, sm6);
+    dst->u.reg = param->reg;
+}
+
 /* Recurse through the block tree while maintaining a current value count. The current
  * count is the sum of the global count plus all declarations within the current function.
  * Store into value_capacity the highest count seen. */
@@ -1699,7 +2153,7 @@ static size_t sm6_parser_get_value_index(struct sm6_parser *sm6, uint64_t idx)
         WARN("Ignoring upper 32 bits of relative index.\n");
     i = (uint32_t)sm6->value_count - (uint32_t)idx;
 
-    /* This may underflow to produce a forward reference, but it must not exceeed the final value count. */
+    /* This may underflow to produce a forward reference, but it must not exceed the final value count. */
     if (i >= sm6->cur_max_value)
     {
         WARN("Invalid value index %"PRIx64" at %zu.\n", idx, sm6->value_count);
@@ -1717,6 +2171,78 @@ static size_t sm6_parser_get_value_index(struct sm6_parser *sm6, uint64_t idx)
     return i;
 }
 
+static bool sm6_value_validate_is_register(const struct sm6_value *value, struct sm6_parser *sm6)
+{
+    if (!sm6_value_is_register(value))
+    {
+        WARN("Operand of type %u is not a register.\n", value->value_type);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "A register operand passed to a DXIL instruction is not a register.");
+        return false;
+    }
+    return true;
+}
+
+static bool sm6_value_validate_is_handle(const struct sm6_value *value, struct sm6_parser *sm6)
+{
+    if (!sm6_value_is_handle(value))
+    {
+        WARN("Handle parameter of type %u is not a handle.\n", value->value_type);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCE_HANDLE,
+                "A handle parameter passed to a DX intrinsic function is not a handle.");
+        return false;
+    }
+    return true;
+}
+
+static bool sm6_value_validate_is_pointer(const struct sm6_value *value, struct sm6_parser *sm6)
+{
+    if (!sm6_type_is_pointer(value->type))
+    {
+        WARN("Operand result type class %u is not a pointer.\n", value->type->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "A pointer operand passed to a DXIL instruction is not a pointer.");
+        return false;
+    }
+    return true;
+}
+
+static bool sm6_value_validate_is_numeric(const struct sm6_value *value, struct sm6_parser *sm6)
+{
+    if (!sm6_type_is_numeric(value->type))
+    {
+        WARN("Operand result type class %u is not numeric.\n", value->type->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "A numeric operand passed to a DXIL instruction is not numeric.");
+        return false;
+    }
+    return true;
+}
+
+static bool sm6_value_validate_is_bool(const struct sm6_value *value, struct sm6_parser *sm6)
+{
+    const struct sm6_type *type = value->type;
+    if (!sm6_type_is_bool(type))
+    {
+        WARN("Operand of type class %u is not bool.\n", type->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "A bool operand of type class %u passed to a DXIL instruction is not a bool.", type->class);
+        return false;
+    }
+    return true;
+}
+
+static const struct sm6_value *sm6_parser_get_value_safe(struct sm6_parser *sm6, unsigned int idx)
+{
+    if (idx < sm6->value_count)
+        return &sm6->values[idx];
+
+    WARN("Invalid value index %u.\n", idx);
+    vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+            "Invalid value index %u.", idx);
+    return NULL;
+}
+
 static size_t sm6_parser_get_value_idx_by_ref(struct sm6_parser *sm6, const struct dxil_record *record,
         const struct sm6_type *fwd_type, unsigned int *rec_idx)
 {
@@ -1860,12 +2386,80 @@ static inline double bitcast_uint64_to_double(uint64_t value)
     return u.double_value;
 }
 
+static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, const struct sm6_type *type,
+        const uint64_t *operands, struct sm6_parser *sm6)
+{
+    struct vkd3d_shader_immediate_constant_buffer *icb;
+    const struct sm6_type *elem_type;
+    unsigned int i, size, count;
+
+    elem_type = type->u.array.elem_type;
+    /* Multidimensional arrays are emitted in flattened form. */
+    if (elem_type->class != TYPE_CLASS_INTEGER && elem_type->class != TYPE_CLASS_FLOAT)
+    {
+        FIXME("Unhandled element type %u for data array.\n", elem_type->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "The element data type for an immediate constant buffer is not scalar integer or floating point.");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    /* Arrays of bool are not used in DXIL. dxc will emit an array of int32 instead if necessary. */
+    if (!(size = elem_type->u.width / CHAR_BIT))
+    {
+        WARN("Invalid data type width %u.\n", elem_type->u.width);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "An immediate constant buffer is declared with boolean elements.");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+    size = max(size, sizeof(icb->data[0]));
+    count = type->u.array.count * size / sizeof(icb->data[0]);
+
+    if (!(icb = vkd3d_malloc(offsetof(struct vkd3d_shader_immediate_constant_buffer, data[count]))))
+    {
+        ERR("Failed to allocate buffer, count %u.\n", count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Out of memory allocating an immediate constant buffer of count %u.", count);
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    }
+    if (!shader_instruction_array_add_icb(&sm6->p.instructions, icb))
+    {
+        ERR("Failed to store icb object.\n");
+        vkd3d_free(icb);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Out of memory storing an immediate constant buffer object.");
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    }
+
+    dst->value_type = VALUE_TYPE_ICB;
+    dst->u.icb = icb;
+
+    icb->data_type = vkd3d_data_type_from_sm6_type(elem_type);
+    icb->element_count = type->u.array.count;
+    icb->component_count = 1;
+
+    count = type->u.array.count;
+    if (size > sizeof(icb->data[0]))
+    {
+        uint64_t *data = (uint64_t *)icb->data;
+        for (i = 0; i < count; ++i)
+            data[i] = operands[i];
+    }
+    else
+    {
+        for (i = 0; i < count; ++i)
+            icb->data[i] = operands[i];
+    }
+
+    return VKD3D_OK;
+}
+
 static enum vkd3d_result sm6_parser_constants_init(struct sm6_parser *sm6, const struct dxil_block *block)
 {
     enum vkd3d_shader_register_type reg_type = VKD3DSPR_INVALID;
     const struct sm6_type *type, *elem_type;
     enum vkd3d_data_type reg_data_type;
     const struct dxil_record *record;
+    enum vkd3d_result ret;
     struct sm6_value *dst;
     size_t i, value_idx;
     uint64_t value;
@@ -1911,14 +2505,19 @@ static enum vkd3d_result sm6_parser_constants_init(struct sm6_parser *sm6, const
         dst = sm6_parser_get_current_value(sm6);
         dst->type = type;
         dst->value_type = VALUE_TYPE_REG;
-        dst->u.reg.type = reg_type;
-        dst->u.reg.immconst_type = VKD3D_IMMCONST_SCALAR;
-        dst->u.reg.data_type = reg_data_type;
+        vsir_register_init(&dst->u.reg, reg_type, reg_data_type, 0);
 
         switch (record->code)
         {
             case CST_CODE_NULL:
-                /* Register constant data is already zero-filled. */
+                if (sm6_type_is_array(type))
+                {
+                    FIXME("Constant null arrays are not supported.\n");
+                    vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                            "Constant null arrays are not supported.");
+                    return VKD3D_ERROR_INVALID_SHADER;
+                }
+                /* For non-aggregates, register constant data is already zero-filled. */
                 break;
 
             case CST_CODE_INTEGER:
@@ -1961,7 +2560,19 @@ static enum vkd3d_result sm6_parser_constants_init(struct sm6_parser *sm6, const
                 break;
 
             case CST_CODE_DATA:
-                WARN("Unhandled constant array.\n");
+                if (!sm6_type_is_array(type))
+                {
+                    WARN("Invalid type %u for data constant idx %zu.\n", type->class, value_idx);
+                    vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                            "The type of a constant array is not an array type.");
+                    return VKD3D_ERROR_INVALID_SHADER;
+                }
+                if (!dxil_record_validate_operand_count(record, type->u.array.count, type->u.array.count, sm6))
+                    return VKD3D_ERROR_INVALID_SHADER;
+
+                if ((ret = value_allocate_constant_array(dst, type, record->operands, sm6)) < 0)
+                    return ret;
+
                 break;
 
             case CST_CODE_UNDEF:
@@ -1983,7 +2594,18 @@ static enum vkd3d_result sm6_parser_constants_init(struct sm6_parser *sm6, const
     return VKD3D_OK;
 }
 
-static struct vkd3d_shader_instruction *sm6_parser_require_space(struct sm6_parser *sm6, size_t extra)
+static bool bitcode_parse_alignment(uint64_t encoded_alignment, unsigned int *alignment)
+{
+    if (encoded_alignment > MAX_ALIGNMENT_EXPONENT + 1)
+    {
+        *alignment = 0;
+        return false;
+    }
+    *alignment = (1u << encoded_alignment) >> 1;
+    return true;
+}
+
+static struct vkd3d_shader_instruction *sm6_parser_require_space(struct sm6_parser *sm6, size_t extra)
 {
     if (!shader_instruction_array_reserve(&sm6->p.instructions, sm6->p.instructions.count + extra))
     {
@@ -1999,15 +2621,194 @@ static struct vkd3d_shader_instruction *sm6_parser_add_instruction(struct sm6_pa
 {
     struct vkd3d_shader_instruction *ins = sm6_parser_require_space(sm6, 1);
     assert(ins);
-    shader_instruction_init(ins, handler_idx);
+    vsir_instruction_init(ins, &sm6->p.location, handler_idx);
     ++sm6->p.instructions.count;
     return ins;
 }
 
+static void sm6_parser_declare_indexable_temp(struct sm6_parser *sm6, const struct sm6_type *elem_type,
+        unsigned int count, unsigned int alignment, unsigned int init, struct sm6_value *dst)
+{
+    enum vkd3d_data_type data_type = vkd3d_data_type_from_sm6_type(elem_type);
+    struct vkd3d_shader_instruction *ins;
+
+    ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_INDEXABLE_TEMP);
+    ins->declaration.indexable_temp.register_idx = sm6->indexable_temp_count++;
+    ins->declaration.indexable_temp.register_size = count;
+    ins->declaration.indexable_temp.alignment = alignment;
+    ins->declaration.indexable_temp.data_type = data_type;
+    ins->declaration.indexable_temp.component_count = 1;
+    /* The initialiser value index will be resolved later so forward references can be handled. */
+    ins->declaration.indexable_temp.initialiser = (void *)(uintptr_t)init;
+
+    register_init_with_id(&dst->u.reg, VKD3DSPR_IDXTEMP, data_type, ins->declaration.indexable_temp.register_idx);
+}
+
+static bool sm6_parser_declare_global(struct sm6_parser *sm6, const struct dxil_record *record)
+{
+    const struct sm6_type *type, *scalar_type;
+    unsigned int alignment, count;
+    uint64_t address_space, init;
+    struct sm6_value *dst;
+    bool is_constant;
+
+    if (!dxil_record_validate_operand_min_count(record, 6, sm6))
+        return false;
+
+    if (!(type = sm6_parser_get_type(sm6, record->operands[0])))
+        return false;
+    if (sm6_type_is_array(type))
+    {
+        if (!sm6_type_is_scalar(type->u.array.elem_type))
+        {
+            FIXME("Unsupported nested type class %u.\n", type->u.array.elem_type->class);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "Global array variables with nested type class %u are not supported.",
+                    type->u.array.elem_type->class);
+            return false;
+        }
+        count = type->u.array.count;
+        scalar_type = type->u.array.elem_type;
+    }
+    else if (sm6_type_is_scalar(type))
+    {
+        count = 1;
+        scalar_type = type;
+    }
+    else
+    {
+        FIXME("Unsupported type class %u.\n", type->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Global variables of type class %u are not supported.", type->class);
+        return false;
+    }
+
+    is_constant = record->operands[1] & GLOBALVAR_FLAG_IS_CONSTANT;
+
+    if (record->operands[1] & GLOBALVAR_FLAG_EXPLICIT_TYPE)
+    {
+        address_space = record->operands[1] >> GLOBALVAR_ADDRESS_SPACE_SHIFT;
+
+        if (!(type = sm6_type_get_pointer_to_type(type, address_space, sm6)))
+        {
+            WARN("Failed to get pointer type for type class %u, address space %"PRIu64".\n",
+                    type->class, address_space);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
+                    "Module does not define a pointer type for a global variable.");
+            return false;
+        }
+    }
+    else
+    {
+        if (!sm6_type_is_pointer(type))
+        {
+            WARN("Type is not a pointer.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "The type of a global variable is not a pointer.");
+            return false;
+        }
+        address_space = type->u.pointer.addr_space;
+    }
+
+    if ((init = record->operands[2]))
+    {
+        if (init - 1 >= sm6->value_capacity)
+        {
+            WARN("Invalid value index %"PRIu64" for initialiser.", init - 1);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "Global variable initialiser value index %"PRIu64" is invalid.", init - 1);
+            return false;
+        }
+    }
+
+    /* LINKAGE_EXTERNAL is common but not relevant here. */
+    if (record->operands[3] != LINKAGE_EXTERNAL && record->operands[3] != LINKAGE_INTERNAL)
+        WARN("Ignoring linkage %"PRIu64".\n", record->operands[3]);
+
+    if (!bitcode_parse_alignment(record->operands[4], &alignment))
+        WARN("Invalid alignment %"PRIu64".\n", record->operands[4]);
+
+    if (record->operands[5])
+        WARN("Ignoring section code %"PRIu64".\n", record->operands[5]);
+
+    if (!sm6_parser_get_global_symbol_name(sm6, sm6->value_count))
+        WARN("Missing symbol name for global variable at index %zu.\n", sm6->value_count);
+    /* TODO: store global symbol names in struct vkd3d_shader_desc? */
+
+    if (record->operand_count > 6 && record->operands[6])
+        WARN("Ignoring visibility %"PRIu64".\n", record->operands[6]);
+    if (record->operand_count > 7 && record->operands[7])
+        WARN("Ignoring thread local mode %"PRIu64".\n", record->operands[7]);
+    /* record->operands[8] contains unnamed_addr, a flag indicating the address
+     * is not important, only the content is. This info is not relevant. */
+    if (record->operand_count > 9 && record->operands[9])
+        WARN("Ignoring external_init %"PRIu64".\n", record->operands[9]);
+    if (record->operand_count > 10 && record->operands[10])
+        WARN("Ignoring dll storage class %"PRIu64".\n", record->operands[10]);
+    if (record->operand_count > 11 && record->operands[11])
+        WARN("Ignoring comdat %"PRIu64".\n", record->operands[11]);
+
+    dst = sm6_parser_get_current_value(sm6);
+    dst->type = type;
+    dst->value_type = VALUE_TYPE_REG;
+
+    if (is_constant && !init)
+    {
+        WARN("Constant array has no initialiser.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "A constant global variable has no initialiser.");
+        return false;
+    }
+
+    if (address_space == ADDRESS_SPACE_DEFAULT)
+    {
+        sm6_parser_declare_indexable_temp(sm6, scalar_type, count, alignment, init, dst);
+    }
+    else if (address_space == ADDRESS_SPACE_GROUPSHARED)
+    {
+        FIXME("Unsupported TGSM.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "TGSM global variables are not supported.");
+        return false;
+    }
+    else
+    {
+        FIXME("Unhandled address space %"PRIu64".\n", address_space);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Global variables with address space %"PRIu64" are not supported.", address_space);
+        return false;
+    }
+
+    ++sm6->value_count;
+    return true;
+}
+
+static const struct vkd3d_shader_immediate_constant_buffer *resolve_forward_initialiser(
+        size_t index, struct sm6_parser *sm6)
+{
+    const struct sm6_value *value;
+
+    assert(index);
+    --index;
+    if (!(value = sm6_parser_get_value_safe(sm6, index)) || !sm6_value_is_icb(value))
+    {
+        WARN("Invalid initialiser index %zu.\n", index);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Global variable initialiser value index %zu is invalid.", index);
+        return NULL;
+    }
+    else
+    {
+        return value->u.icb;
+    }
+}
+
 static enum vkd3d_result sm6_parser_globals_init(struct sm6_parser *sm6)
 {
     const struct dxil_block *block = &sm6->root_block;
+    struct vkd3d_shader_instruction *ins;
     const struct dxil_record *record;
+    enum vkd3d_result ret;
     uint64_t version;
     size_t i;
 
@@ -2030,7 +2831,8 @@ static enum vkd3d_result sm6_parser_globals_init(struct sm6_parser *sm6)
                 break;
 
             case MODULE_CODE_GLOBALVAR:
-                FIXME("Global variables are not implemented yet.\n");
+                if (!sm6_parser_declare_global(sm6, record))
+                    return VKD3D_ERROR_INVALID_SHADER;
                 break;
 
             case MODULE_CODE_VERSION:
@@ -2050,6 +2852,24 @@ static enum vkd3d_result sm6_parser_globals_init(struct sm6_parser *sm6)
         }
     }
 
+    for (i = 0; i < block->child_block_count; ++i)
+    {
+        if (block->child_blocks[i]->id == CONSTANTS_BLOCK
+                && (ret = sm6_parser_constants_init(sm6, block->child_blocks[i])) < 0)
+            return ret;
+    }
+
+    /* Resolve initialiser forward references. */
+    for (i = 0; i < sm6->p.instructions.count; ++i)
+    {
+        ins = &sm6->p.instructions.elements[i];
+        if (ins->handler_idx == VKD3DSIH_DCL_INDEXABLE_TEMP && ins->declaration.indexable_temp.initialiser)
+        {
+            ins->declaration.indexable_temp.initialiser = resolve_forward_initialiser(
+                    (uintptr_t)ins->declaration.indexable_temp.initialiser, sm6);
+        }
+    }
+
     return VKD3D_OK;
 }
 
@@ -2063,7 +2883,7 @@ static void dst_param_io_init(struct vkd3d_shader_dst_param *param,
     param->shift = 0;
     /* DXIL types do not have signedness. Load signed elements as unsigned. */
     component_type = e->component_type == VKD3D_SHADER_COMPONENT_INT ? VKD3D_SHADER_COMPONENT_UINT : e->component_type;
-    shader_register_init(&param->reg, reg_type, vkd3d_data_type_from_component_type(component_type), 0);
+    vsir_register_init(&param->reg, reg_type, vkd3d_data_type_from_component_type(component_type), 0);
 }
 
 static void sm6_parser_init_signature(struct sm6_parser *sm6, const struct shader_signature *s,
@@ -2071,7 +2891,7 @@ static void sm6_parser_init_signature(struct sm6_parser *sm6, const struct shade
 {
     struct vkd3d_shader_dst_param *param;
     const struct signature_element *e;
-    unsigned int i;
+    unsigned int i, count;
 
     for (i = 0; i < s->element_count; ++i)
     {
@@ -2079,8 +2899,11 @@ static void sm6_parser_init_signature(struct sm6_parser *sm6, const struct shade
 
         param = &params[i];
         dst_param_io_init(param, e, reg_type);
-        param->reg.idx[0].offset = i;
-        param->reg.idx_count = 1;
+        count = 0;
+        if (e->register_count > 1)
+            param->reg.idx[count++].offset = 0;
+        param->reg.idx[count++].offset = i;
+        param->reg.idx_count = count;
     }
 }
 
@@ -2112,15 +2935,25 @@ static void sm6_parser_emit_signature(struct sm6_parser *sm6, const struct shade
             param = &ins->declaration.dst;
         }
 
+        ins->flags = e->interpolation_mode;
         *param = params[i];
+
+        if (e->register_count > 1)
+        {
+            param->reg.idx[0].rel_addr = NULL;
+            param->reg.idx[0].offset = e->register_count;
+        }
     }
 }
 
 static void sm6_parser_init_output_signature(struct sm6_parser *sm6, const struct shader_signature *output_signature)
 {
-    sm6_parser_init_signature(sm6, output_signature,
-            (sm6->p.shader_version.type == VKD3D_SHADER_TYPE_PIXEL) ? VKD3DSPR_COLOROUT : VKD3DSPR_OUTPUT,
-            sm6->output_params);
+    sm6_parser_init_signature(sm6, output_signature, VKD3DSPR_OUTPUT, sm6->output_params);
+}
+
+static void sm6_parser_init_input_signature(struct sm6_parser *sm6, const struct shader_signature *input_signature)
+{
+    sm6_parser_init_signature(sm6, input_signature, VKD3DSPR_INPUT, sm6->input_params);
 }
 
 static void sm6_parser_emit_output_signature(struct sm6_parser *sm6, const struct shader_signature *output_signature)
@@ -2128,6 +2961,14 @@ static void sm6_parser_emit_output_signature(struct sm6_parser *sm6, const struc
     sm6_parser_emit_signature(sm6, output_signature, VKD3DSIH_DCL_OUTPUT, VKD3DSIH_DCL_OUTPUT_SIV, sm6->output_params);
 }
 
+static void sm6_parser_emit_input_signature(struct sm6_parser *sm6, const struct shader_signature *input_signature)
+{
+    sm6_parser_emit_signature(sm6, input_signature,
+            (sm6->p.shader_version.type == VKD3D_SHADER_TYPE_PIXEL) ? VKD3DSIH_DCL_INPUT_PS : VKD3DSIH_DCL_INPUT,
+            (sm6->p.shader_version.type == VKD3D_SHADER_TYPE_PIXEL) ? VKD3DSIH_DCL_INPUT_PS_SIV : VKD3DSIH_DCL_INPUT_SIV,
+            sm6->input_params);
+}
+
 static const struct sm6_value *sm6_parser_next_function_definition(struct sm6_parser *sm6)
 {
     size_t i, count = sm6->function_count;
@@ -2150,6 +2991,303 @@ static struct sm6_block *sm6_block_create()
     return block;
 }
 
+static enum vkd3d_shader_opcode map_binary_op(uint64_t code, const struct sm6_type *type_a,
+        const struct sm6_type *type_b, struct sm6_parser *sm6)
+{
+    bool is_int = sm6_type_is_bool_i16_i32_i64(type_a);
+    bool is_bool = sm6_type_is_bool(type_a);
+    enum vkd3d_shader_opcode op;
+    bool is_valid;
+
+    if (!is_int && !sm6_type_is_floating_point(type_a))
+    {
+        WARN("Argument type %u is not bool, int16/32/64 or floating point.\n", type_a->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "An argument to a binary operation is not bool, int16/32/64 or floating point.");
+        return VKD3DSIH_INVALID;
+    }
+    if (type_a != type_b)
+    {
+        WARN("Type mismatch, type %u width %u vs type %u width %u.\n", type_a->class,
+                type_a->u.width, type_b->class, type_b->u.width);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                "Type mismatch in binary operation arguments.");
+    }
+
+    switch (code)
+    {
+        case BINOP_ADD:
+        case BINOP_SUB:
+            /* NEG is applied later for subtraction. */
+            op = is_int ? VKD3DSIH_IADD : VKD3DSIH_ADD;
+            is_valid = !is_bool;
+            break;
+        case BINOP_AND:
+            op = VKD3DSIH_AND;
+            is_valid = is_int;
+            break;
+        case BINOP_ASHR:
+            op = VKD3DSIH_ISHR;
+            is_valid = is_int && !is_bool;
+            break;
+        case BINOP_LSHR:
+            op = VKD3DSIH_USHR;
+            is_valid = is_int && !is_bool;
+            break;
+        case BINOP_MUL:
+            op = is_int ? VKD3DSIH_UMUL : VKD3DSIH_MUL;
+            is_valid = !is_bool;
+            break;
+        case BINOP_OR:
+            op = VKD3DSIH_OR;
+            is_valid = is_int;
+            break;
+        case BINOP_SDIV:
+            op = is_int ? VKD3DSIH_IDIV : VKD3DSIH_DIV;
+            is_valid = !is_bool;
+            break;
+        case BINOP_SREM:
+            op = is_int ? VKD3DSIH_IDIV : VKD3DSIH_FREM;
+            is_valid = !is_bool;
+            break;
+        case BINOP_SHL:
+            op = VKD3DSIH_ISHL;
+            is_valid = is_int && !is_bool;
+            break;
+        case BINOP_UDIV:
+        case BINOP_UREM:
+            op = VKD3DSIH_UDIV;
+            is_valid = is_int && !is_bool;
+            break;
+        case BINOP_XOR:
+            op = VKD3DSIH_XOR;
+            is_valid = is_int;
+            break;
+        default:
+            FIXME("Unhandled binary op %#"PRIx64".\n", code);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "Binary operation %#"PRIx64" is unhandled.", code);
+            return VKD3DSIH_INVALID;
+    }
+
+    if (!is_valid)
+    {
+        WARN("Invalid operation %u for type %u, width %u.\n", op, type_a->class, type_a->u.width);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_INVALID_OPERATION,
+                "Binary operation %u is invalid on type class %u, width %u.", op, type_a->class, type_a->u.width);
+    }
+
+    return op;
+}
+
+static void sm6_parser_emit_binop(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+{
+    struct vkd3d_shader_src_param *src_params;
+    enum vkd3d_shader_opcode handler_idx;
+    const struct sm6_value *a, *b;
+    uint64_t code, flags;
+    bool silence_warning;
+    unsigned int i = 0;
+
+    a = sm6_parser_get_value_by_ref(sm6, record, NULL, &i);
+    b = sm6_parser_get_value_by_ref(sm6, record, a->type, &i);
+    if (!a || !b)
+        return;
+
+    if (!dxil_record_validate_operand_count(record, i + 1, i + 2, sm6))
+        return;
+
+    code = record->operands[i++];
+    if ((handler_idx = map_binary_op(code, a->type, b->type, sm6)) == VKD3DSIH_INVALID)
+        return;
+
+    vsir_instruction_init(ins, &sm6->p.location, handler_idx);
+
+    flags = (record->operand_count > i) ? record->operands[i] : 0;
+    silence_warning = false;
+
+    switch (handler_idx)
+    {
+        case VKD3DSIH_ADD:
+        case VKD3DSIH_MUL:
+        case VKD3DSIH_DIV:
+        case VKD3DSIH_FREM:
+            if (!(flags & FP_ALLOW_UNSAFE_ALGEBRA))
+                ins->flags |= VKD3DSI_PRECISE_X;
+            flags &= ~FP_ALLOW_UNSAFE_ALGEBRA;
+            /* SPIR-V FPFastMathMode is only available in the Kernel executon model. */
+            silence_warning = !(flags & ~(FP_NO_NAN | FP_NO_INF | FP_NO_SIGNED_ZEROS | FP_ALLOW_RECIPROCAL));
+            break;
+        case VKD3DSIH_IADD:
+        case VKD3DSIH_UMUL:
+        case VKD3DSIH_ISHL:
+            silence_warning = !(flags & ~(OB_NO_UNSIGNED_WRAP | OB_NO_SIGNED_WRAP));
+            break;
+        case VKD3DSIH_ISHR:
+        case VKD3DSIH_USHR:
+        case VKD3DSIH_IDIV:
+        case VKD3DSIH_UDIV:
+            silence_warning = !(flags & ~PEB_EXACT);
+            break;
+        default:
+            break;
+    }
+    /* The above flags are very common and cause warning spam. */
+    if (flags && silence_warning)
+    {
+        TRACE("Ignoring flags %#"PRIx64".\n", flags);
+    }
+    else if (flags)
+    {
+        WARN("Ignoring flags %#"PRIx64".\n", flags);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                "Ignoring flags %#"PRIx64" for a binary operation.", flags);
+    }
+
+    src_params = instruction_src_params_alloc(ins, 2, sm6);
+    src_param_init_from_value(&src_params[0], a);
+    src_param_init_from_value(&src_params[1], b);
+    if (code == BINOP_SUB)
+        src_params[1].modifiers = VKD3DSPSM_NEG;
+
+    dst->type = a->type;
+
+    if (handler_idx == VKD3DSIH_UMUL || handler_idx == VKD3DSIH_UDIV || handler_idx == VKD3DSIH_IDIV)
+    {
+        struct vkd3d_shader_dst_param *dst_params = instruction_dst_params_alloc(ins, 2, sm6);
+        unsigned int index = code != BINOP_UDIV && code != BINOP_SDIV;
+
+        dst_param_init(&dst_params[0]);
+        dst_param_init(&dst_params[1]);
+        register_init_ssa_scalar(&dst_params[index].reg, a->type, sm6);
+        vsir_register_init(&dst_params[index ^ 1].reg, VKD3DSPR_NULL, VKD3D_DATA_UNUSED, 0);
+        dst->u.reg = dst_params[index].reg;
+    }
+    else
+    {
+        instruction_dst_param_init_ssa_scalar(ins, sm6);
+    }
+}
+
+static void sm6_parser_emit_dx_cbuffer_load(struct sm6_parser *sm6, struct sm6_block *code_block,
+        enum dx_intrinsic_opcode op, const struct sm6_value **operands, struct vkd3d_shader_instruction *ins)
+{
+    struct sm6_value *dst = sm6_parser_get_current_value(sm6);
+    struct vkd3d_shader_src_param *src_param;
+    const struct sm6_value *buffer;
+    const struct sm6_type *type;
+
+    buffer = operands[0];
+    if (!sm6_value_validate_is_handle(buffer, sm6))
+        return;
+
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_MOV);
+
+    src_param = instruction_src_params_alloc(ins, 1, sm6);
+    src_param_init_vector_from_reg(src_param, &buffer->u.handle.reg);
+    register_index_address_init(&src_param->reg.idx[2], operands[1], sm6);
+    assert(src_param->reg.idx_count == 3);
+
+    type = sm6_type_get_scalar_type(dst->type, 0);
+    assert(type);
+    src_param->reg.data_type = vkd3d_data_type_from_sm6_type(type);
+
+    instruction_dst_param_init_ssa_vector(ins, sm6_type_max_vector_size(type), sm6);
+}
+
+static const struct sm6_descriptor_info *sm6_parser_get_descriptor(struct sm6_parser *sm6,
+        enum vkd3d_shader_descriptor_type type, unsigned int id, const struct sm6_value *address)
+{
+    const struct sm6_descriptor_info *d;
+    unsigned int register_index;
+    size_t i;
+
+    for (i = 0; i < sm6->descriptor_count; ++i)
+    {
+        d = &sm6->descriptors[i];
+
+        if (d->type != type || d->id != id)
+            continue;
+
+        if (!sm6_value_is_constant(address))
+            return d;
+
+        register_index = sm6_value_get_constant_uint(address);
+        if (register_index >= d->range.first && register_index <= d->range.last)
+            return d;
+    }
+
+    return NULL;
+}
+
+static void sm6_parser_emit_dx_create_handle(struct sm6_parser *sm6, struct sm6_block *code_block,
+        enum dx_intrinsic_opcode op, const struct sm6_value **operands, struct vkd3d_shader_instruction *ins)
+{
+    enum vkd3d_shader_descriptor_type type;
+    const struct sm6_descriptor_info *d;
+    struct vkd3d_shader_register *reg;
+    struct sm6_value *dst;
+    unsigned int id;
+
+    type = sm6_value_get_constant_uint(operands[0]);
+    id = sm6_value_get_constant_uint(operands[1]);
+    if (!(d = sm6_parser_get_descriptor(sm6, type, id, operands[2])))
+    {
+        WARN("Failed to find resource type %#x, id %#x.\n", type, id);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Descriptor for resource type %#x, id %#x was not found.", type, id);
+        return;
+    }
+
+    dst = sm6_parser_get_current_value(sm6);
+    dst->value_type = VALUE_TYPE_HANDLE;
+    dst->u.handle.d = d;
+
+    reg = &dst->u.handle.reg;
+    /* Set idx_count to 3 for use with load instructions.
+     * TODO: set register type from resource type when other types are supported. */
+    vsir_register_init(reg, VKD3DSPR_CONSTBUFFER, VKD3D_DATA_FLOAT, 3);
+    reg->idx[0].offset = id;
+    register_index_address_init(&reg->idx[1], operands[2], sm6);
+    reg->non_uniform = !!sm6_value_get_constant_uint(operands[3]);
+
+    /* NOP is used to flag no instruction emitted. */
+    ins->handler_idx = VKD3DSIH_NOP;
+}
+
+static void sm6_parser_emit_dx_load_input(struct sm6_parser *sm6, struct sm6_block *code_block,
+        enum dx_intrinsic_opcode op, const struct sm6_value **operands, struct vkd3d_shader_instruction *ins)
+{
+    struct vkd3d_shader_src_param *src_param;
+    const struct shader_signature *signature;
+    unsigned int row_index, column_index;
+    const struct signature_element *e;
+
+    row_index = sm6_value_get_constant_uint(operands[0]);
+    column_index = sm6_value_get_constant_uint(operands[2]);
+
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_MOV);
+
+    signature = &sm6->p.shader_desc.input_signature;
+    if (row_index >= signature->element_count)
+    {
+        WARN("Invalid row index %u.\n", row_index);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Invalid input row index %u.", row_index);
+        return;
+    }
+    e = &signature->elements[row_index];
+
+    src_param = instruction_src_params_alloc(ins, 1, sm6);
+    src_param->reg = sm6->input_params[row_index].reg;
+    src_param_init_scalar(src_param, column_index);
+    if (e->register_count > 1)
+        register_index_address_init(&src_param->reg.idx[0], operands[1], sm6);
+
+    instruction_dst_param_init_ssa_scalar(ins, sm6);
+}
+
 static void sm6_parser_emit_dx_store_output(struct sm6_parser *sm6, struct sm6_block *code_block,
         enum dx_intrinsic_opcode op, const struct sm6_value **operands, struct vkd3d_shader_instruction *ins)
 {
@@ -2190,14 +3328,14 @@ static void sm6_parser_emit_dx_store_output(struct sm6_parser *sm6, struct sm6_b
         return;
     }
 
-    shader_instruction_init(ins, VKD3DSIH_MOV);
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_MOV);
 
     if (!(dst_param = instruction_dst_params_alloc(ins, 1, sm6)))
         return;
     dst_param_init_scalar(dst_param, column_index);
     dst_param->reg = sm6->output_params[row_index].reg;
     if (e->register_count > 1)
-        register_address_init(&dst_param->reg, operands[1], 0, sm6);
+        register_index_address_init(&dst_param->reg.idx[0], operands[1], sm6);
 
     if ((src_param = instruction_src_params_alloc(ins, 1, sm6)))
         src_param_init_from_value(src_param, value);
@@ -2213,17 +3351,29 @@ struct sm6_dx_opcode_info
 
 /*
     8 -> int8
+    b -> constant int1
+    c -> constant int8/16/32
     i -> int32
+    H -> handle
     v -> void
     o -> overloaded
  */
 static const struct sm6_dx_opcode_info sm6_dx_op_table[] =
 {
+    [DX_CBUFFER_LOAD_LEGACY           ] = {'o', "Hi",   sm6_parser_emit_dx_cbuffer_load},
+    [DX_CREATE_HANDLE                 ] = {'H', "ccib", sm6_parser_emit_dx_create_handle},
+    [DX_LOAD_INPUT                    ] = {'o', "ii8i", sm6_parser_emit_dx_load_input},
     [DX_STORE_OUTPUT                  ] = {'v', "ii8o", sm6_parser_emit_dx_store_output},
 };
 
-static bool sm6_parser_validate_operand_type(struct sm6_parser *sm6, const struct sm6_type *type, char info_type)
+static bool sm6_parser_validate_operand_type(struct sm6_parser *sm6, const struct sm6_value *value, char info_type,
+        bool is_return)
 {
+    const struct sm6_type *type = value->type;
+
+    if (info_type != 'H' && !sm6_value_is_register(value))
+        return false;
+
     switch (info_type)
     {
         case 0:
@@ -2231,8 +3381,15 @@ static bool sm6_parser_validate_operand_type(struct sm6_parser *sm6, const struc
             return false;
         case '8':
             return sm6_type_is_i8(type);
+        case 'b':
+            return sm6_value_is_constant(value) && sm6_type_is_bool(type);
+        case 'c':
+            return sm6_value_is_constant(value) && sm6_type_is_integer(type) && type->u.width >= 8
+                    && type->u.width <= 32;
         case 'i':
             return sm6_type_is_i32(type);
+        case 'H':
+            return (is_return || sm6_value_is_handle(value)) && type == sm6->handle_type;
         case 'v':
             return !type;
         case 'o':
@@ -2252,7 +3409,7 @@ static bool sm6_parser_validate_dx_op(struct sm6_parser *sm6, enum dx_intrinsic_
 
     info = &sm6_dx_op_table[op];
 
-    if (!sm6_parser_validate_operand_type(sm6, dst->type, info->ret_type))
+    if (!sm6_parser_validate_operand_type(sm6, dst, info->ret_type, true))
     {
         WARN("Failed to validate return type for dx intrinsic id %u, '%s'.\n", op, name);
         /* Return type validation failure is not so critical. We only need to set
@@ -2262,7 +3419,7 @@ static bool sm6_parser_validate_dx_op(struct sm6_parser *sm6, enum dx_intrinsic_
     for (i = 0; i < operand_count; ++i)
     {
         const struct sm6_value *value = operands[i];
-        if (!sm6_value_is_register(value) || !sm6_parser_validate_operand_type(sm6, value->type, info->operand_info[i]))
+        if (!sm6_parser_validate_operand_type(sm6, value, info->operand_info[i], false))
         {
             WARN("Failed to validate operand %u for dx intrinsic id %u, '%s'.\n", i + 1, op, name);
             vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
@@ -2292,7 +3449,7 @@ static void sm6_parser_emit_unhandled(struct sm6_parser *sm6, struct vkd3d_shade
         return;
 
     type = sm6_type_get_scalar_type(dst->type, 0);
-    shader_register_init(&dst->u.reg, VKD3DSPR_UNDEF, vkd3d_data_type_from_sm6_type(type), 0);
+    vsir_register_init(&dst->u.reg, VKD3DSPR_UNDEF, vkd3d_data_type_from_sm6_type(type), 0);
     /* dst->is_undefined is not set here because it flags only explicitly undefined values. */
 }
 
@@ -2303,7 +3460,7 @@ static void sm6_parser_decode_dx_op(struct sm6_parser *sm6, struct sm6_block *co
     if (op >= ARRAY_SIZE(sm6_dx_op_table) || !sm6_dx_op_table[op].operand_info)
     {
         FIXME("Unhandled dx intrinsic function id %u, '%s'.\n", op, name);
-        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_UNHANDLED_INTRINSIC,
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_UNHANDLED_INTRINSIC,
                 "Call to intrinsic function %s is unhandled.", name);
         sm6_parser_emit_unhandled(sm6, ins, dst);
         return;
@@ -2372,238 +3529,1860 @@ static void sm6_parser_emit_call(struct sm6_parser *sm6, const struct dxil_recor
                 "Ignoring %u function call operands beyond the parameter list.", j);
     }
 
-    if (!fn_value->u.function.is_prototype)
+    if (!fn_value->u.function.is_prototype)
+    {
+        FIXME("Unhandled call to local function.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Call to a local function is unsupported.");
+        return;
+    }
+    if (!sm6_value_is_dx_intrinsic_dcl(fn_value))
+        WARN("External function is not a dx intrinsic.\n");
+
+    if (!operand_count)
+    {
+        WARN("Missing dx intrinsic function id.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "The id for a dx intrinsic function is missing.");
+        return;
+    }
+
+    op_value = operands[0];
+    if (!sm6_value_is_constant(op_value) || !sm6_type_is_integer(op_value->type))
+    {
+        WARN("dx intrinsic function id is not a constant int.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Expected a constant integer dx intrinsic function id.");
+        return;
+    }
+    sm6_parser_decode_dx_op(sm6, code_block, register_get_uint_value(&op_value->u.reg),
+            fn_value->u.function.name, &operands[1], operand_count - 1, ins, dst);
+}
+
+static enum vkd3d_shader_opcode sm6_map_cast_op(uint64_t code, const struct sm6_type *from,
+        const struct sm6_type *to, struct sm6_parser *sm6)
+{
+    enum vkd3d_shader_opcode op = VKD3DSIH_INVALID;
+    bool from_int, to_int, from_fp, to_fp;
+    bool is_valid = false;
+
+    from_int = sm6_type_is_integer(from);
+    to_int = sm6_type_is_integer(to);
+    from_fp = sm6_type_is_floating_point(from);
+    to_fp = sm6_type_is_floating_point(to);
+
+    /* NOTE: DXIL currently doesn't use vectors here. */
+    if ((!from_int && !from_fp) || (!to_int && !to_fp))
+    {
+        FIXME("Unhandled cast of type class %u to type class %u.\n", from->class, to->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Cast of type class %u to type class %u is not implemented.", from->class, to->class);
+        return VKD3DSIH_INVALID;
+    }
+    if (to->u.width == 8 || from->u.width == 8)
+    {
+        FIXME("Unhandled 8-bit value.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Cast to/from an 8-bit type is not implemented.");
+        return VKD3DSIH_INVALID;
+    }
+
+    /* DXC emits minimum precision types as 16-bit. These must be emitted
+     * as 32-bit in VSIR, so all width extensions to 32 bits are no-ops. */
+    switch (code)
+    {
+        case CAST_TRUNC:
+            /* nop or min precision. TODO: native 16-bit */
+            if (to->u.width == from->u.width || (to->u.width == 16 && from->u.width == 32))
+                op = VKD3DSIH_NOP;
+            else
+                op = VKD3DSIH_UTOU;
+            is_valid = from_int && to_int && to->u.width <= from->u.width;
+            break;
+        case CAST_ZEXT:
+        case CAST_SEXT:
+            /* nop or min precision. TODO: native 16-bit */
+            if (to->u.width == from->u.width || (to->u.width == 32 && from->u.width == 16))
+            {
+                op = VKD3DSIH_NOP;
+                is_valid = from_int && to_int;
+            }
+            else if (to->u.width > from->u.width)
+            {
+                op = (code == CAST_ZEXT) ? VKD3DSIH_UTOU : VKD3DSIH_ITOI;
+                assert(from->u.width == 1 || to->u.width == 64);
+                is_valid = from_int && to_int;
+            }
+            break;
+        case CAST_FPTOUI:
+            op = VKD3DSIH_FTOU;
+            is_valid = from_fp && to_int && to->u.width > 1;
+            break;
+        case CAST_FPTOSI:
+            op = VKD3DSIH_FTOI;
+            is_valid = from_fp && to_int && to->u.width > 1;
+            break;
+        case CAST_UITOFP:
+            op = VKD3DSIH_UTOF;
+            is_valid = from_int && to_fp;
+            break;
+        case CAST_SITOFP:
+            op = VKD3DSIH_ITOF;
+            is_valid = from_int && to_fp;
+            break;
+        case CAST_FPTRUNC:
+            /* TODO: native 16-bit */
+            op = (from->u.width == 64) ? VKD3DSIH_DTOF : VKD3DSIH_NOP;
+            is_valid = from_fp && to_fp;
+            break;
+        case CAST_FPEXT:
+            /* TODO: native 16-bit */
+            op = (to->u.width == 64) ? VKD3DSIH_FTOD : VKD3DSIH_NOP;
+            is_valid = from_fp && to_fp;
+            break;
+        case CAST_BITCAST:
+            op = VKD3DSIH_MOV;
+            is_valid = to->u.width == from->u.width;
+            break;
+        default:
+            FIXME("Unhandled cast op %"PRIu64".\n", code);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "Cast operation %"PRIu64" is unhandled.\n", code);
+            return VKD3DSIH_INVALID;
+    }
+
+    if (!is_valid)
+    {
+        FIXME("Invalid types %u and/or %u for op %"PRIu64".\n", from->class, to->class, code);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Cast operation %"PRIu64" from type class %u, width %u to type class %u, width %u is invalid.\n",
+                code, from->class, from->u.width, to->class, to->u.width);
+        return VKD3DSIH_INVALID;
+    }
+
+    return op;
+}
+
+static void sm6_parser_emit_cast(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+{
+    struct vkd3d_shader_src_param *src_param;
+    enum vkd3d_shader_opcode handler_idx;
+    const struct sm6_value *value;
+    const struct sm6_type *type;
+    unsigned int i = 0;
+
+    if (!(value = sm6_parser_get_value_by_ref(sm6, record, NULL, &i)))
+        return;
+
+    if (!dxil_record_validate_operand_count(record, i + 2, i + 2, sm6))
+        return;
+
+    if (!(type = sm6_parser_get_type(sm6, record->operands[i++])))
+        return;
+
+    dst->type = type;
+
+    if (sm6_type_is_pointer(type))
+    {
+        *dst = *value;
+        dst->type = type;
+        ins->handler_idx = VKD3DSIH_NOP;
+        return;
+    }
+
+    if ((handler_idx = sm6_map_cast_op(record->operands[i], value->type, type, sm6)) == VKD3DSIH_INVALID)
+        return;
+
+    vsir_instruction_init(ins, &sm6->p.location, handler_idx);
+
+    if (handler_idx == VKD3DSIH_NOP)
+    {
+        dst->u.reg = value->u.reg;
+        return;
+    }
+
+    src_param = instruction_src_params_alloc(ins, 1, sm6);
+    src_param_init_from_value(src_param, value);
+
+    instruction_dst_param_init_ssa_scalar(ins, sm6);
+
+    /* bitcast */
+    if (handler_idx == VKD3DSIH_MOV)
+        src_param->reg.data_type = dst->u.reg.data_type;
+}
+
+struct sm6_cmp_info
+{
+    enum vkd3d_shader_opcode handler_idx;
+    bool src_swap;
+};
+
+static const struct sm6_cmp_info *sm6_map_cmp2_op(uint64_t code)
+{
+    static const struct sm6_cmp_info cmp_op_table[] =
+    {
+        [FCMP_FALSE] = {VKD3DSIH_INVALID},
+        [FCMP_OEQ]   = {VKD3DSIH_EQO},
+        [FCMP_OGT]   = {VKD3DSIH_LTO, true},
+        [FCMP_OGE]   = {VKD3DSIH_GEO},
+        [FCMP_OLT]   = {VKD3DSIH_LTO},
+        [FCMP_OLE]   = {VKD3DSIH_GEO, true},
+        [FCMP_ONE]   = {VKD3DSIH_NEO},
+        [FCMP_ORD]   = {VKD3DSIH_INVALID},
+        [FCMP_UNO]   = {VKD3DSIH_INVALID},
+        [FCMP_UEQ]   = {VKD3DSIH_EQU},
+        [FCMP_UGT]   = {VKD3DSIH_LTU, true},
+        [FCMP_UGE]   = {VKD3DSIH_GEU},
+        [FCMP_ULT]   = {VKD3DSIH_LTU},
+        [FCMP_ULE]   = {VKD3DSIH_GEU, true},
+        [FCMP_UNE]   = {VKD3DSIH_NEU},
+        [FCMP_TRUE]  = {VKD3DSIH_INVALID},
+
+        [ICMP_EQ]    = {VKD3DSIH_IEQ},
+        [ICMP_NE]    = {VKD3DSIH_INE},
+        [ICMP_UGT]   = {VKD3DSIH_ULT, true},
+        [ICMP_UGE]   = {VKD3DSIH_UGE},
+        [ICMP_ULT]   = {VKD3DSIH_ULT},
+        [ICMP_ULE]   = {VKD3DSIH_UGE, true},
+        [ICMP_SGT]   = {VKD3DSIH_ILT, true},
+        [ICMP_SGE]   = {VKD3DSIH_IGE},
+        [ICMP_SLT]   = {VKD3DSIH_ILT},
+        [ICMP_SLE]   = {VKD3DSIH_IGE, true},
+    };
+
+    return (code < ARRAY_SIZE(cmp_op_table)) ? &cmp_op_table[code] : NULL;
+}
+
+static void sm6_parser_emit_cmp2(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+{
+    struct vkd3d_shader_src_param *src_params;
+    const struct sm6_type *type_a, *type_b;
+    bool is_int, is_fp, silence_warning;
+    const struct sm6_cmp_info *cmp;
+    const struct sm6_value *a, *b;
+    uint64_t code, flags;
+    unsigned int i = 0;
+
+    if (!(dst->type = sm6->bool_type))
+    {
+        WARN("Bool type not found.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
+                "Module does not define a boolean type for comparison results.");
+        return;
+    }
+
+    a = sm6_parser_get_value_by_ref(sm6, record, NULL, &i);
+    b = sm6_parser_get_value_by_ref(sm6, record, a->type, &i);
+    if (!a || !b)
+        return;
+
+    if (!dxil_record_validate_operand_count(record, i + 1, i + 2, sm6))
+        return;
+
+    type_a = a->type;
+    type_b = b->type;
+    is_int = sm6_type_is_bool_i16_i32_i64(type_a);
+    is_fp = sm6_type_is_floating_point(type_a);
+
+    code = record->operands[i++];
+
+    if ((!is_int && !is_fp) || is_int != (code >= ICMP_EQ))
+    {
+        FIXME("Invalid operation %"PRIu64" on type class %u.\n", code, type_a->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Comparison operation %"PRIu64" on type class %u is invalid.", code, type_a->class);
+        return;
+    }
+
+    if (type_a != type_b)
+    {
+        WARN("Type mismatch, type %u width %u vs type %u width %u.\n", type_a->class,
+                type_a->u.width, type_b->class, type_b->u.width);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                "Type mismatch in comparison operation arguments.");
+    }
+
+    if (!(cmp = sm6_map_cmp2_op(code)) || !cmp->handler_idx || cmp->handler_idx == VKD3DSIH_INVALID)
+    {
+        FIXME("Unhandled operation %"PRIu64".\n", code);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Comparison operation %"PRIu64" is unhandled.", code);
+        return;
+    }
+
+    vsir_instruction_init(ins, &sm6->p.location, cmp->handler_idx);
+
+    flags = (record->operand_count > i) ? record->operands[i] : 0;
+    silence_warning = false;
+
+    if (is_fp)
+    {
+        if (!(flags & FP_ALLOW_UNSAFE_ALGEBRA))
+            ins->flags |= VKD3DSI_PRECISE_X;
+        flags &= ~FP_ALLOW_UNSAFE_ALGEBRA;
+        /* SPIR-V FPFastMathMode is only available in the Kernel execution model. */
+        silence_warning = !(flags & ~(FP_NO_NAN | FP_NO_INF | FP_NO_SIGNED_ZEROS | FP_ALLOW_RECIPROCAL));
+    }
+    if (flags && silence_warning)
+    {
+        TRACE("Ignoring fast FP modifier %#"PRIx64".\n", flags);
+    }
+    else if (flags)
+    {
+        WARN("Ignoring flags %#"PRIx64".\n", flags);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                "Ignoring flags %#"PRIx64" for a comparison operation.", flags);
+    }
+
+    src_params = instruction_src_params_alloc(ins, 2, sm6);
+    src_param_init_from_value(&src_params[0 ^ cmp->src_swap], a);
+    src_param_init_from_value(&src_params[1 ^ cmp->src_swap], b);
+
+    instruction_dst_param_init_ssa_scalar(ins, sm6);
+}
+
+static void sm6_parser_emit_extractval(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+{
+    struct vkd3d_shader_src_param *src_param;
+    const struct sm6_type *type;
+    const struct sm6_value *src;
+    unsigned int i = 0;
+    uint64_t elem_idx;
+
+    if (!(src = sm6_parser_get_value_by_ref(sm6, record, NULL, &i)))
+        return;
+
+    if (!dxil_record_validate_operand_min_count(record, i + 1, sm6))
+        return;
+
+    if (record->operand_count > i + 1)
+    {
+        FIXME("Unhandled multiple indices.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Multiple extractval indices are not supported.");
+        return;
+    }
+
+    type = src->type;
+    if (!sm6_type_is_aggregate(type))
+    {
+        WARN("Invalid extraction from non-aggregate.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Source type of an extractval instruction is not an aggregate.");
+        return;
+    }
+
+    elem_idx = record->operands[i];
+    if (!(type = sm6_type_get_element_type_at_index(type, elem_idx)))
+    {
+        WARN("Invalid element index %"PRIu64".\n", elem_idx);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Element index %"PRIu64" for an extractval instruction is out of bounds.", elem_idx);
+        return;
+    }
+    if (!sm6_type_is_scalar(type))
+    {
+        FIXME("Nested extraction is not supported.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Extraction from nested aggregates is not supported.");
+        return;
+    }
+    dst->type = type;
+
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_MOV);
+
+    src_param = instruction_src_params_alloc(ins, 1, sm6);
+    src_param_init_from_value(src_param, src);
+    src_param->swizzle = vkd3d_shader_create_swizzle(elem_idx, elem_idx, elem_idx, elem_idx);
+
+    instruction_dst_param_init_ssa_scalar(ins, sm6);
+}
+
+static void sm6_parser_emit_gep(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+{
+    const struct sm6_type *type, *pointee_type;
+    unsigned int elem_idx, operand_idx = 2;
+    enum bitcode_address_space addr_space;
+    const struct sm6_value *elem_value;
+    struct vkd3d_shader_register *reg;
+    const struct sm6_value *src;
+    bool is_in_bounds;
+
+    if (!dxil_record_validate_operand_min_count(record, 5, sm6)
+            || !(type = sm6_parser_get_type(sm6, record->operands[1]))
+            || !(src = sm6_parser_get_value_by_ref(sm6, record, NULL, &operand_idx))
+            || !sm6_value_validate_is_register(src, sm6)
+            || !sm6_value_validate_is_pointer(src, sm6)
+            || !dxil_record_validate_operand_min_count(record, operand_idx + 2, sm6))
+    {
+        return;
+    }
+
+    if (src->u.reg.idx_count > 1)
+    {
+        WARN("Unsupported stacked GEP.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "A GEP instruction on the result of a previous GEP is unsupported.");
+        return;
+    }
+
+    is_in_bounds = record->operands[0];
+
+    if ((pointee_type = src->type->u.pointer.type) != type)
+    {
+        WARN("Type mismatch, type %u width %u vs type %u width %u.\n", type->class,
+                type->u.width, pointee_type->class, pointee_type->u.width);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                "Type mismatch in GEP operation arguments.");
+    }
+    addr_space = src->type->u.pointer.addr_space;
+
+    if (!(elem_value = sm6_parser_get_value_by_ref(sm6, record, NULL, &operand_idx)))
+        return;
+
+    /* The first index is always zero, to form a simple pointer dereference. */
+    if (sm6_value_get_constant_uint(elem_value))
+    {
+        WARN("Expected constant zero.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "The pointer dereference index for a GEP instruction is not constant zero.");
+        return;
+    }
+
+    if (!sm6_type_is_array(pointee_type))
+    {
+        WARN("Invalid GEP on type class %u.\n", pointee_type->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Source type for index 1 of a GEP instruction is not an array.");
+        return;
+    }
+
+    if (!(elem_value = sm6_parser_get_value_by_ref(sm6, record, NULL, &operand_idx)))
+        return;
+
+    /* If indexing is dynamic, just get the type at offset zero. */
+    elem_idx = sm6_value_is_constant(elem_value) ? sm6_value_get_constant_uint(elem_value) : 0;
+    type = sm6_type_get_element_type_at_index(pointee_type, elem_idx);
+    if (!type)
+    {
+        WARN("Invalid element index %u.\n", elem_idx);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Element index %u for a GEP instruction is out of bounds.", elem_idx);
+        return;
+    }
+
+    if (operand_idx < record->operand_count)
+    {
+        FIXME("Multiple element indices are not implemented.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Multi-dimensional addressing in GEP instructions is not supported.");
+        return;
+    }
+
+    if (!(dst->type = sm6_type_get_pointer_to_type(type, addr_space, sm6)))
+    {
+        WARN("Failed to get pointer type for type %u.\n", type->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
+                "Module does not define a pointer type for a GEP instruction.");
+        return;
+    }
+
+    reg = &dst->u.reg;
+    *reg = src->u.reg;
+    reg->idx[1].offset = 0;
+    register_index_address_init(&reg->idx[1], elem_value, sm6);
+    reg->idx[1].is_in_bounds = is_in_bounds;
+    reg->idx_count = 2;
+
+    ins->handler_idx = VKD3DSIH_NOP;
+}
+
+static void sm6_parser_emit_load(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+{
+    const struct sm6_type *elem_type = NULL, *pointee_type;
+    struct vkd3d_shader_src_param *src_param;
+    unsigned int alignment, i = 0;
+    const struct sm6_value *ptr;
+    uint64_t alignment_code;
+
+    if (!(ptr = sm6_parser_get_value_by_ref(sm6, record, NULL, &i)))
+        return;
+    if (!sm6_value_validate_is_register(ptr, sm6)
+            || !sm6_value_validate_is_pointer(ptr, sm6)
+            || !dxil_record_validate_operand_count(record, i + 2, i + 3, sm6))
+        return;
+
+    if (record->operand_count > i + 2 && !(elem_type = sm6_parser_get_type(sm6, record->operands[i++])))
+        return;
+
+    if (!elem_type)
+    {
+        elem_type = ptr->type->u.pointer.type;
+    }
+    else if (elem_type != (pointee_type = ptr->type->u.pointer.type))
+    {
+        WARN("Type mismatch.\n");
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                "Type mismatch in pointer load arguments.");
+    }
+
+    dst->type = elem_type;
+
+    if (!sm6_value_validate_is_numeric(dst, sm6))
+        return;
+
+    alignment_code = record->operands[i++];
+    if (!bitcode_parse_alignment(alignment_code, &alignment))
+        WARN("Invalid alignment %"PRIu64".\n", alignment_code);
+
+    if (record->operands[i])
+        WARN("Ignoring volatile modifier.\n");
+
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_MOV);
+
+    src_param = instruction_src_params_alloc(ins, 1, sm6);
+    src_param_init_from_value(&src_param[0], ptr);
+    src_param->reg.alignment = alignment;
+
+    instruction_dst_param_init_ssa_scalar(ins, sm6);
+}
+
+static void sm6_parser_emit_ret(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct sm6_block *code_block, struct vkd3d_shader_instruction *ins)
+{
+    if (!dxil_record_validate_operand_count(record, 0, 1, sm6))
+        return;
+
+    if (record->operand_count)
+        FIXME("Non-void return is not implemented.\n");
+
+    ins->handler_idx = VKD3DSIH_NOP;
+}
+
+static void sm6_parser_emit_vselect(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+{
+    struct vkd3d_shader_src_param *src_params;
+    const struct sm6_value *src[3];
+    unsigned int i = 0;
+
+    if (!(src[1] = sm6_parser_get_value_by_ref(sm6, record, NULL, &i))
+            || !(src[2] = sm6_parser_get_value_by_ref(sm6, record, src[1]->type, &i))
+            || !(src[0] = sm6_parser_get_value_by_ref(sm6, record, NULL, &i)))
+    {
+        return;
+    }
+    dxil_record_validate_operand_max_count(record, i, sm6);
+
+    for (i = 0; i < 3; ++i)
+    {
+        if (!sm6_value_validate_is_register(src[i], sm6))
+            return;
+    }
+
+    dst->type = src[1]->type;
+
+    if (!sm6_value_validate_is_bool(src[0], sm6))
+        return;
+
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_MOVC);
+
+    src_params = instruction_src_params_alloc(ins, 3, sm6);
+    for (i = 0; i < 3; ++i)
+        src_param_init_from_value(&src_params[i], src[i]);
+
+    instruction_dst_param_init_ssa_scalar(ins, sm6);
+}
+
+static bool sm6_metadata_value_is_node(const struct sm6_metadata_value *m)
+{
+    return m && m->type == VKD3D_METADATA_NODE;
+}
+
+static bool sm6_metadata_value_is_value(const struct sm6_metadata_value *m)
+{
+    return m && m->type == VKD3D_METADATA_VALUE;
+}
+
+static bool sm6_metadata_value_is_string(const struct sm6_metadata_value *m)
+{
+    return m && m->type == VKD3D_METADATA_STRING;
+}
+
+static bool sm6_metadata_get_uint_value(const struct sm6_parser *sm6,
+        const struct sm6_metadata_value *m, unsigned int *u)
+{
+    const struct sm6_value *value;
+
+    if (!m || m->type != VKD3D_METADATA_VALUE)
+        return false;
+
+    value = m->u.value;
+    if (!sm6_value_is_constant(value))
+        return false;
+    if (!sm6_type_is_integer(value->type))
+        return false;
+
+    *u = register_get_uint_value(&value->u.reg);
+
+    return true;
+}
+
+static bool sm6_metadata_get_uint64_value(const struct sm6_parser *sm6,
+        const struct sm6_metadata_value *m, uint64_t *u)
+{
+    const struct sm6_value *value;
+
+    if (!m || m->type != VKD3D_METADATA_VALUE)
+        return false;
+
+    value = m->u.value;
+    if (!sm6_value_is_constant(value))
+        return false;
+    if (!sm6_type_is_integer(value->type))
+        return false;
+
+    *u = register_get_uint64_value(&value->u.reg);
+
+    return true;
+}
+
+static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6, const struct dxil_block *block,
+        struct sm6_function *function)
+{
+    struct vkd3d_shader_instruction *ins;
+    size_t i, block_idx, block_count;
+    const struct dxil_record *record;
+    bool ret_found, is_terminator;
+    struct sm6_block *code_block;
+    struct sm6_value *dst;
+
+    if (sm6->function_count)
+    {
+        FIXME("Multiple functions are not supported yet.\n");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+    if (!(function->declaration = sm6_parser_next_function_definition(sm6)))
+    {
+        WARN("Failed to find definition to match function body.\n");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    if (block->record_count < 2)
+    {
+        /* It should contain at least a block count and a RET instruction. */
+        WARN("Invalid function block record count %zu.\n", block->record_count);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+    if (block->records[0]->code != FUNC_CODE_DECLAREBLOCKS || !block->records[0]->operand_count
+            || block->records[0]->operands[0] > UINT_MAX)
+    {
+        WARN("Block count declaration not found or invalid.\n");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    if (!(block_count = block->records[0]->operands[0]))
+    {
+        WARN("Function contains no blocks.\n");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+    if (block_count > 1)
+    {
+        FIXME("Branched shaders are not supported yet.\n");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    if (!(function->blocks[0] = sm6_block_create()))
+    {
+        ERR("Failed to allocate code block.\n");
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    }
+    function->block_count = block_count;
+    code_block = function->blocks[0];
+
+    sm6->cur_max_value = function->value_count;
+
+    for (i = 1, block_idx = 0, ret_found = false; i < block->record_count; ++i)
+    {
+        sm6->p.location.column = i;
+
+        if (!code_block)
+        {
+            WARN("Invalid block count %zu.\n", function->block_count);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "Invalid block count %zu.", function->block_count);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        /* block->record_count - 1 is the instruction count, but some instructions
+         * can emit >1 IR instruction, so extra may be used. */
+        if (!vkd3d_array_reserve((void **)&code_block->instructions, &code_block->instruction_capacity,
+                max(code_block->instruction_count + 1, block->record_count), sizeof(*code_block->instructions)))
+        {
+            ERR("Failed to allocate instructions.\n");
+            return VKD3D_ERROR_OUT_OF_MEMORY;
+        }
+
+        ins = &code_block->instructions[code_block->instruction_count];
+        ins->handler_idx = VKD3DSIH_INVALID;
+
+        dst = sm6_parser_get_current_value(sm6);
+        dst->type = NULL;
+        dst->value_type = VALUE_TYPE_REG;
+        is_terminator = false;
+
+        record = block->records[i];
+        switch (record->code)
+        {
+            case FUNC_CODE_INST_BINOP:
+                sm6_parser_emit_binop(sm6, record, ins, dst);
+                break;
+            case FUNC_CODE_INST_CALL:
+                sm6_parser_emit_call(sm6, record, code_block, ins, dst);
+                break;
+            case FUNC_CODE_INST_CAST:
+                sm6_parser_emit_cast(sm6, record, ins, dst);
+                break;
+            case FUNC_CODE_INST_CMP2:
+                sm6_parser_emit_cmp2(sm6, record, ins, dst);
+                break;
+            case FUNC_CODE_INST_EXTRACTVAL:
+                sm6_parser_emit_extractval(sm6, record, ins, dst);
+                break;
+            case FUNC_CODE_INST_GEP:
+                sm6_parser_emit_gep(sm6, record, ins, dst);
+                break;
+            case FUNC_CODE_INST_LOAD:
+                sm6_parser_emit_load(sm6, record, ins, dst);
+                break;
+            case FUNC_CODE_INST_RET:
+                sm6_parser_emit_ret(sm6, record, code_block, ins);
+                is_terminator = true;
+                ret_found = true;
+                break;
+            case FUNC_CODE_INST_VSELECT:
+                sm6_parser_emit_vselect(sm6, record, ins, dst);
+                break;
+            default:
+                FIXME("Unhandled dxil instruction %u.\n", record->code);
+                return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        if (sm6->p.failed)
+            return VKD3D_ERROR;
+        assert(ins->handler_idx != VKD3DSIH_INVALID);
+
+        if (is_terminator)
+        {
+            ++block_idx;
+            code_block = (block_idx < function->block_count) ? function->blocks[block_idx] : NULL;
+        }
+        if (code_block)
+            code_block->instruction_count += ins->handler_idx != VKD3DSIH_NOP;
+        else
+            assert(ins->handler_idx == VKD3DSIH_NOP);
+
+        sm6->value_count += !!dst->type;
+    }
+
+    if (!ret_found)
+    {
+        WARN("Function contains no RET instruction.\n");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    return VKD3D_OK;
+}
+
+static bool sm6_block_emit_instructions(struct sm6_block *block, struct sm6_parser *sm6)
+{
+    struct vkd3d_shader_instruction *ins = sm6_parser_require_space(sm6, block->instruction_count + 1);
+
+    if (!ins)
+        return false;
+
+    memcpy(ins, block->instructions, block->instruction_count * sizeof(*block->instructions));
+    sm6->p.instructions.count += block->instruction_count;
+
+    sm6_parser_add_instruction(sm6, VKD3DSIH_RET);
+
+    return true;
+}
+
+static enum vkd3d_result sm6_parser_module_init(struct sm6_parser *sm6, const struct dxil_block *block,
+        unsigned int level)
+{
+    size_t i, old_value_count = sm6->value_count;
+    struct sm6_function *function;
+    enum vkd3d_result ret;
+
+    for (i = 0; i < block->child_block_count; ++i)
+    {
+        if ((ret = sm6_parser_module_init(sm6, block->child_blocks[i], level + 1)) < 0)
+            return ret;
+    }
+
+    sm6->p.location.line = block->id;
+    sm6->p.location.column = 0;
+
+    switch (block->id)
+    {
+        case CONSTANTS_BLOCK:
+            /* Level 1 (global) constants are already done in sm6_parser_globals_init(). */
+            if (level < 2)
+                break;
+            function = &sm6->functions[sm6->function_count];
+            sm6->cur_max_value = function->value_count;
+            return sm6_parser_constants_init(sm6, block);
+
+        case FUNCTION_BLOCK:
+            function = &sm6->functions[sm6->function_count];
+            if ((ret = sm6_parser_function_init(sm6, block, function)) < 0)
+                return ret;
+            /* The value index returns to its previous value after handling a function. It's usually nonzero
+             * at the start because of global constants/variables/function declarations. Function constants
+             * occur in a child block, so value_count is already saved before they are emitted. */
+            memset(&sm6->values[old_value_count], 0, (sm6->value_count - old_value_count) * sizeof(*sm6->values));
+            sm6->value_count = old_value_count;
+            break;
+
+        case BLOCKINFO_BLOCK:
+        case MODULE_BLOCK:
+        case PARAMATTR_BLOCK:
+        case PARAMATTR_GROUP_BLOCK:
+        case VALUE_SYMTAB_BLOCK:
+        case METADATA_BLOCK:
+        case METADATA_ATTACHMENT_BLOCK:
+        case TYPE_BLOCK:
+            break;
+
+        default:
+            FIXME("Unhandled block id %u.\n", block->id);
+            break;
+    }
+
+    return VKD3D_OK;
+}
+
+static bool sm6_parser_allocate_named_metadata(struct sm6_parser *sm6)
+{
+    struct dxil_block *block;
+    unsigned int i, j, count;
+
+    for (i = 0, count = 0; i < sm6->root_block.child_block_count; ++i)
+    {
+        block = sm6->root_block.child_blocks[i];
+        if (block->id != METADATA_BLOCK)
+            continue;
+        for (j = 0; j < block->record_count; ++j)
+            count += block->records[j]->code == METADATA_NAMED_NODE;
+    }
+
+    if (!count)
+        return true;
+
+    return !!(sm6->named_metadata = vkd3d_calloc(count, sizeof(*sm6->named_metadata)));
+}
+
+static enum vkd3d_result metadata_value_create_node(struct sm6_metadata_value *m, struct sm6_metadata_table *table,
+        unsigned int dst_idx, unsigned int end_count, const struct dxil_record *record, struct sm6_parser *sm6)
+{
+    struct sm6_metadata_node *node;
+    unsigned int i, offset;
+
+    m->type = VKD3D_METADATA_NODE;
+    if (!(m->value_type = sm6->metadata_type))
+    {
+        WARN("Metadata type not found.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
+                "The type for metadata values was not found.");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+    if (!(node = vkd3d_malloc(offsetof(struct sm6_metadata_node, operands[record->operand_count]))))
+    {
+        ERR("Failed to allocate metadata node with %u operands.\n", record->operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Out of memory allocating a metadata node with %u operands.", record->operand_count);
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    }
+    m->u.node = node;
+
+    node->is_distinct = record->code == METADATA_DISTINCT_NODE;
+
+    offset = record->code != METADATA_NAMED_NODE;
+
+    for (i = 0; i < record->operand_count; ++i)
+    {
+        uint64_t ref;
+
+        ref = record->operands[i] - offset;
+        if (record->operands[i] >= offset && ref >= end_count)
+        {
+            WARN("Invalid metadata index %"PRIu64".\n", ref);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
+                    "Metadata index %"PRIu64" is invalid.", ref);
+            vkd3d_free(node);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        if (!node->is_distinct && ref == dst_idx)
+        {
+            WARN("Metadata self-reference at index %u.\n", dst_idx);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
+                    "Metadata index %u is self-referencing.", dst_idx);
+            vkd3d_free(node);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        node->operands[i] = (record->operands[i] >= offset) ? &table->values[ref] : NULL;
+        if (record->code == METADATA_NAMED_NODE && !sm6_metadata_value_is_node(node->operands[i]))
+        {
+            WARN("Named node operand is not a node.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
+                    "The operand of a metadata named node is not a node.");
+            vkd3d_free(node);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+    }
+
+    node->operand_count = record->operand_count;
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result sm6_parser_metadata_init(struct sm6_parser *sm6, const struct dxil_block *block,
+        struct sm6_metadata_table *table)
+{
+    unsigned int i, count, table_idx, value_idx;
+    struct sm6_metadata_value *values, *m;
+    const struct dxil_record *record;
+    const struct sm6_value *value;
+    enum vkd3d_result ret;
+    char *name;
+
+    for (i = 0, count = 0; i < block->record_count; ++i)
+        count += block->records[i]->code != METADATA_NAME;
+
+    if (!(values = vkd3d_calloc(count, sizeof(*values))))
+    {
+        ERR("Failed to allocate metadata tables.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Out of memory allocating metadata tables.");
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    }
+    table->values = values;
+
+    for (i = 0, name = NULL; i < block->record_count; ++i)
+    {
+        record = block->records[i];
+
+        table_idx = table->count;
+        m = &values[table_idx];
+
+        switch (record->code)
+        {
+            case METADATA_NAMED_NODE:
+                if (!name)
+                {
+                    WARN("Named node has no name.\n");
+                    vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
+                            "A metadata named node has no name.");
+                    return VKD3D_ERROR_INVALID_SHADER;
+                }
+
+                /* When DXC emits metadata value array reference indices it assumes named nodes
+                 * are not included in the array. Store named nodes separately. */
+                m = &sm6->named_metadata[sm6->named_metadata_count].value;
+                sm6->named_metadata[sm6->named_metadata_count].name = name;
+                name = NULL;
+
+                if ((ret = metadata_value_create_node(m, table, UINT_MAX, count, record, sm6)) < 0)
+                    return ret;
+                ++sm6->named_metadata_count;
+                /* Skip incrementing the table count. */
+                continue;
+
+            case METADATA_DISTINCT_NODE:
+            case METADATA_NODE:
+                if ((ret = metadata_value_create_node(m, table, table_idx, count, record, sm6)) < 0)
+                    return ret;
+                break;
+
+            case METADATA_KIND:
+                if (!dxil_record_validate_operand_min_count(record, 2, sm6))
+                    return VKD3D_ERROR_INVALID_SHADER;
+
+                m->type = VKD3D_METADATA_KIND;
+                m->u.kind.id = record->operands[0];
+                if (!(m->u.kind.name = dxil_record_to_string(record, 1, sm6)))
+                {
+                    ERR("Failed to allocate name of a kind.\n");
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+                }
+                break;
+
+            case METADATA_NAME:
+                /* Check the next record to avoid freeing 'name' in all exit paths. */
+                if (i + 1 == block->record_count || block->records[i + 1]->code != METADATA_NAMED_NODE)
+                {
+                    WARN("Name is not followed by a named node.\n");
+                    vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
+                            "A metadata node name is not followed by a named node.");
+                    return VKD3D_ERROR_INVALID_SHADER;
+                }
+                /* LLVM allows an empty string here. */
+                if (!(name = dxil_record_to_string(record, 0, sm6)))
+                {
+                    ERR("Failed to allocate name.\n");
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+                }
+                continue;
+
+            case METADATA_STRING:
+                /* LLVM allows an empty string here. */
+                m->type = VKD3D_METADATA_STRING;
+                if (!(m->u.string_value = dxil_record_to_string(record, 0, sm6)))
+                {
+                    ERR("Failed to allocate string.\n");
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+                }
+                break;
+
+            case METADATA_VALUE:
+                if (!dxil_record_validate_operand_count(record, 2, 2, sm6))
+                    return VKD3D_ERROR_INVALID_SHADER;
+
+                m->type = VKD3D_METADATA_VALUE;
+                if (!(m->value_type = sm6_parser_get_type(sm6, record->operands[0])))
+                    return VKD3D_ERROR_INVALID_SHADER;
+
+                if (record->operands[1] > UINT_MAX)
+                    WARN("Truncating value index %"PRIu64".\n", record->operands[1]);
+                value_idx = record->operands[1];
+                if (!(value = sm6_parser_get_value_safe(sm6, value_idx)))
+                    return VKD3D_ERROR_INVALID_SHADER;
+
+                if (!sm6_value_is_constant(value) && !sm6_value_is_undef(value) && !sm6_value_is_icb(value)
+                        && !sm6_value_is_function_dcl(value))
+                {
+                    WARN("Value at index %u is not a constant or a function declaration.\n", value_idx);
+                    vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
+                            "Metadata value at index %u is not a constant or a function declaration.", value_idx);
+                    return VKD3D_ERROR_INVALID_SHADER;
+                }
+                m->u.value = value;
+
+                if (value->type != m->value_type)
+                {
+                    WARN("Type mismatch.\n");
+                    vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                            "The type of a metadata value does not match its referenced value at index %u.", value_idx);
+                }
+
+                break;
+
+            default:
+                FIXME("Unhandled metadata type %u.\n", record->code);
+                vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
+                        "Metadata type %u is unhandled.", record->code);
+                return VKD3D_ERROR_INVALID_SHADER;
+        }
+        ++table->count;
+    }
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_shader_component_type vkd3d_component_type_from_dxil_component_type(enum dxil_component_type type)
+{
+    switch (type)
+    {
+        case COMPONENT_TYPE_I1:
+            return VKD3D_SHADER_COMPONENT_BOOL;
+        case COMPONENT_TYPE_I16:
+        case COMPONENT_TYPE_I32:
+            return VKD3D_SHADER_COMPONENT_INT;
+        case COMPONENT_TYPE_U16:
+        case COMPONENT_TYPE_U32:
+            return VKD3D_SHADER_COMPONENT_UINT;
+        case COMPONENT_TYPE_F16:
+        case COMPONENT_TYPE_F32:
+        case COMPONENT_TYPE_SNORMF32:
+        case COMPONENT_TYPE_UNORMF32:
+            return VKD3D_SHADER_COMPONENT_FLOAT;
+        case COMPONENT_TYPE_F64:
+        case COMPONENT_TYPE_SNORMF64:
+        case COMPONENT_TYPE_UNORMF64:
+            return VKD3D_SHADER_COMPONENT_DOUBLE;
+        default:
+            FIXME("Unhandled component type %u.\n", type);
+            return VKD3D_SHADER_COMPONENT_UINT;
+    }
+}
+
+static enum vkd3d_shader_minimum_precision minimum_precision_from_dxil_component_type(enum dxil_component_type type)
+{
+    switch (type)
+    {
+        case COMPONENT_TYPE_F16:
+            return VKD3D_SHADER_MINIMUM_PRECISION_FLOAT_16;
+        case COMPONENT_TYPE_I16:
+            return VKD3D_SHADER_MINIMUM_PRECISION_INT_16;
+        case COMPONENT_TYPE_U16:
+            return VKD3D_SHADER_MINIMUM_PRECISION_UINT_16;
+        default:
+            return VKD3D_SHADER_MINIMUM_PRECISION_NONE;
+    }
+}
+
+static const enum vkd3d_shader_sysval_semantic sysval_semantic_table[] =
+{
+    [SEMANTIC_KIND_ARBITRARY]            = VKD3D_SHADER_SV_NONE,
+    [SEMANTIC_KIND_POSITION]             = VKD3D_SHADER_SV_POSITION,
+    [SEMANTIC_KIND_TARGET]               = VKD3D_SHADER_SV_NONE,
+};
+
+static enum vkd3d_shader_sysval_semantic sysval_semantic_from_dxil_semantic_kind(enum dxil_semantic_kind kind)
+{
+    if (kind < ARRAY_SIZE(sysval_semantic_table))
+    {
+        return sysval_semantic_table[kind];
+    }
+    else
+    {
+        return VKD3D_SHADER_SV_NONE;
+    }
+}
+
+static const struct sm6_metadata_value *sm6_parser_find_named_metadata(struct sm6_parser *sm6, const char *name)
+{
+    const struct sm6_metadata_node *node;
+    unsigned int i;
+
+    for (i = 0; i < sm6->named_metadata_count; ++i)
+    {
+        if (strcmp(sm6->named_metadata[i].name, name))
+            continue;
+
+        node = sm6->named_metadata[i].value.u.node;
+        if (!node->operand_count)
+            return NULL;
+        if (node->operand_count > 1)
+        {
+            FIXME("Ignoring %u extra operands for %s.\n", node->operand_count - 1, name);
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                    "Ignoring %u extra operands for metadata node %s.", node->operand_count - 1, name);
+        }
+        return node->operands[0];
+    }
+
+    return NULL;
+}
+
+static bool sm6_parser_resources_load_register_range(struct sm6_parser *sm6,
+        const struct sm6_metadata_node *node, struct vkd3d_shader_register_range *range)
+{
+    unsigned int size;
+
+    if (!sm6_metadata_value_is_value(node->operands[1]))
+    {
+        WARN("Resource data type is not a value.\n");
+        return false;
+    }
+    if (!sm6_type_is_pointer(node->operands[1]->value_type))
+    {
+        WARN("Resource type is not a pointer.\n");
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                "Resource metadata value type is not a pointer.");
+    }
+
+    if (!sm6_metadata_get_uint_value(sm6, node->operands[3], &range->space))
+    {
+        WARN("Failed to load register space.\n");
+        return false;
+    }
+    if (!sm6_metadata_get_uint_value(sm6, node->operands[4], &range->first))
+    {
+        WARN("Failed to load register first.\n");
+        return false;
+    }
+    if (!sm6_metadata_get_uint_value(sm6, node->operands[5], &size))
+    {
+        WARN("Failed to load register range size.\n");
+        return false;
+    }
+    if (!size || (size != UINT_MAX && !vkd3d_bound_range(range->first, size, UINT_MAX)))
+    {
+        WARN("Invalid register range, first %u, size %u.\n", range->first, size);
+        return false;
+    }
+    range->last = (size == UINT_MAX) ? UINT_MAX : range->first + size - 1;
+
+    return true;
+}
+
+static enum vkd3d_result sm6_parser_resources_load_cbv(struct sm6_parser *sm6,
+        const struct sm6_metadata_node *node, struct sm6_descriptor_info *d, struct vkd3d_shader_instruction *ins)
+{
+    struct vkd3d_shader_register *reg;
+    unsigned int buffer_size;
+
+    if (node->operand_count < 7)
+    {
+        WARN("Invalid operand count %u.\n", node->operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "Invalid operand count %u for a CBV descriptor.", node->operand_count);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+    if (node->operand_count > 7 && node->operands[7])
+    {
+        WARN("Ignoring %u extra operands.\n", node->operand_count - 7);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                "Ignoring %u extra operands for a CBV descriptor.", node->operand_count - 7);
+    }
+
+    if (!sm6_metadata_get_uint_value(sm6, node->operands[6], &buffer_size))
+    {
+        WARN("Failed to load buffer size.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                "Constant buffer size metadata value is not an integer.");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_DCL_CONSTANT_BUFFER);
+    ins->resource_type = VKD3D_SHADER_RESOURCE_BUFFER;
+    ins->declaration.cb.size = buffer_size;
+    ins->declaration.cb.src.swizzle = VKD3D_SHADER_NO_SWIZZLE;
+    ins->declaration.cb.src.modifiers = VKD3DSPSM_NONE;
+
+    reg = &ins->declaration.cb.src.reg;
+    vsir_register_init(reg, VKD3DSPR_CONSTBUFFER, VKD3D_DATA_FLOAT, 3);
+    reg->idx[0].offset = d->id;
+    reg->idx[1].offset = d->range.first;
+    reg->idx[2].offset = d->range.last;
+
+    ins->declaration.cb.range = d->range;
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result sm6_parser_descriptor_type_init(struct sm6_parser *sm6,
+        enum vkd3d_shader_descriptor_type type, const struct sm6_metadata_node *descriptor_node)
+{
+    struct vkd3d_shader_instruction *ins;
+    const struct sm6_metadata_node *node;
+    const struct sm6_metadata_value *m;
+    struct sm6_descriptor_info *d;
+    enum vkd3d_result ret;
+    unsigned int i;
+
+    for (i = 0; i < descriptor_node->operand_count; ++i)
+    {
+        m = descriptor_node->operands[i];
+        if (!sm6_metadata_value_is_node(m))
+        {
+            WARN("Resource descriptor is not a node.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                    "Resource descriptor is not a metadata node.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        node = m->u.node;
+        if (node->operand_count < 6)
+        {
+            WARN("Invalid operand count %u.\n", node->operand_count);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                    "Invalid operand count %u for a descriptor.", node->operand_count);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        if (!vkd3d_array_reserve((void **)&sm6->descriptors, &sm6->descriptor_capacity,
+                sm6->descriptor_count + 1, sizeof(*sm6->descriptors)))
+        {
+            ERR("Failed to allocate descriptor array.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                    "Out of memory allocating the descriptor array.");
+            return VKD3D_ERROR_OUT_OF_MEMORY;
+        }
+        d = &sm6->descriptors[sm6->descriptor_count];
+        d->type = type;
+
+        if (!sm6_metadata_get_uint_value(sm6, node->operands[0], &d->id))
+        {
+            WARN("Failed to load resource id.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                    "Resource id metadata value is not an integer.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        if (!sm6_parser_resources_load_register_range(sm6, node, &d->range))
+        {
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                    "Resource register range is invalid.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        if (!(ins = sm6_parser_require_space(sm6, 1)))
+        {
+            ERR("Failed to allocate instruction.\n");
+            return VKD3D_ERROR_OUT_OF_MEMORY;
+        }
+
+        switch (type)
+        {
+            case VKD3D_SHADER_DESCRIPTOR_TYPE_CBV:
+                if ((ret = sm6_parser_resources_load_cbv(sm6, node, d, ins)) < 0)
+                    return ret;
+                break;
+            default:
+                FIXME("Unsupported descriptor type %u.\n", type);
+                vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                        "Resource descriptor type %u is unsupported.", type);
+                return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        ++sm6->descriptor_count;
+        ++sm6->p.instructions.count;
+    }
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result sm6_parser_resources_init(struct sm6_parser *sm6)
+{
+    const struct sm6_metadata_value *m = sm6_parser_find_named_metadata(sm6, "dx.resources");
+    enum vkd3d_shader_descriptor_type type;
+    const struct sm6_metadata_node *node;
+    enum vkd3d_result ret;
+
+    if (!m)
+        return VKD3D_OK;
+
+    node = m->u.node;
+    if (node->operand_count != SHADER_DESCRIPTOR_TYPE_COUNT)
+    {
+        WARN("Unexpected descriptor type count %u.\n", node->operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                "Descriptor type count %u is invalid.", node->operand_count);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    for (type = 0; type < SHADER_DESCRIPTOR_TYPE_COUNT; ++type)
+    {
+        if (!(m = node->operands[type]))
+            continue;
+
+        if (!sm6_metadata_value_is_node(m))
+        {
+            WARN("Resource list is not a node.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                    "Resource list is not a metadata node.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        if ((ret = sm6_parser_descriptor_type_init(sm6, type, m->u.node)) < 0)
+            return ret;
+    }
+
+    return VKD3D_OK;
+}
+
+static void signature_element_read_additional_element_values(struct signature_element *e,
+        const struct sm6_metadata_node *node, struct sm6_parser *sm6)
+{
+    unsigned int i, operand_count, value;
+    enum dxil_element_additional_tag tag;
+
+    if (node->operand_count < 11 || !node->operands[10])
+        return;
+
+    if (!sm6_metadata_value_is_node(node->operands[10]))
+    {
+        WARN("Additional values list is not a node.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                "Signature element additional values list is not a metadata node.");
+        return;
+    }
+
+    node = node->operands[10]->u.node;
+    if (node->operand_count & 1)
+    {
+        WARN("Operand count is not even.\n");
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                "Operand count for signature element additional tag/value pairs is not even.");
+    }
+    operand_count = node->operand_count & ~1u;
+
+    for (i = 0; i < operand_count; i += 2)
+    {
+        if (!sm6_metadata_get_uint_value(sm6, node->operands[i], &tag)
+                || !sm6_metadata_get_uint_value(sm6, node->operands[i + 1], &value))
+        {
+            WARN("Failed to extract tag/value pair.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                    "Signature element tag/value pair at index %u is not an integer pair.", i);
+            continue;
+        }
+
+        switch (tag)
+        {
+            case ADDITIONAL_TAG_STREAM_INDEX:
+                e->stream_index = value;
+                break;
+            case ADDITIONAL_TAG_RELADDR_MASK:
+                /* A mask of components accessed via relative addressing. Seems to replace TPF 'dcl_index_range'. */
+                if (value > VKD3DSP_WRITEMASK_ALL)
+                {
+                    WARN("Invalid relative addressed mask %#x.\n", value);
+                    vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_INVALID_MASK,
+                            "Mask %#x of relative-addressed components is invalid.", value);
+                }
+                break;
+            case ADDITIONAL_TAG_USED_MASK:
+                if (value > VKD3DSP_WRITEMASK_ALL)
+                {
+                    WARN("Invalid used mask %#x.\n", value);
+                    vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_INVALID_MASK,
+                            "Mask %#x of used components is invalid.", value);
+                    value &= VKD3DSP_WRITEMASK_ALL;
+                }
+                e->used_mask = value;
+                break;
+            default:
+                FIXME("Unhandled tag %u, value %u.\n", tag, value);
+                vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                        "Tag %#x for signature element additional value %#x is unhandled.", tag, value);
+                break;
+        }
+    }
+}
+
+static enum vkd3d_result sm6_parser_read_signature(struct sm6_parser *sm6, const struct sm6_metadata_value *m,
+        struct shader_signature *s)
+{
+    unsigned int i, j, column_count, operand_count, index;
+    const struct sm6_metadata_node *node, *element_node;
+    struct signature_element *elements, *e;
+    unsigned int values[10];
+
+    if (!m)
+        return VKD3D_OK;
+
+    if (!sm6_metadata_value_is_node(m))
+    {
+        WARN("Signature element list is not a node.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                "Signature element list is not a metadata node.");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    node = m->u.node;
+    operand_count = node->operand_count;
+
+    if (!(elements = vkd3d_calloc(operand_count, sizeof(*elements))))
+    {
+        ERR("Failed to allocate %u signature elements.\n", operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Out of memory allocating %u signature elements.", operand_count);
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    }
+
+    for (i = 0; i < operand_count; ++i)
+    {
+        m = node->operands[i];
+
+        if (!sm6_metadata_value_is_node(m))
+        {
+            WARN("Signature element is not a node.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                    "Signature element is not a metadata node.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        element_node = m->u.node;
+        if (element_node->operand_count < 10)
+        {
+            WARN("Invalid operand count %u.\n", element_node->operand_count);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                    "Invalid signature element operand count %u.", element_node->operand_count);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+        if (element_node->operand_count > 11)
+        {
+            WARN("Ignoring %u extra operands.\n", element_node->operand_count - 11);
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                    "Ignoring %u extra operands for a signature element.", element_node->operand_count - 11);
+        }
+
+        for (j = 0; j < 10; ++j)
+        {
+            /* 1 is the semantic name, 4 is semantic index metadata. */
+            if (j == 1 || j == 4)
+                continue;
+            if (!sm6_metadata_get_uint_value(sm6, element_node->operands[j], &values[j]))
+            {
+                WARN("Failed to load uint value at index %u.\n", j);
+                vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                        "Signature element value at index %u is not an integer.", j);
+                return VKD3D_ERROR_INVALID_SHADER;
+            }
+        }
+
+        e = &elements[i];
+
+        if (values[0] != i)
+        {
+            FIXME("Unsupported element id %u not equal to its index %u.\n", values[0], i);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                    "A non-sequential and non-zero-based element id is not supported.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        if (!sm6_metadata_value_is_string(element_node->operands[1]))
+        {
+            WARN("Element name is not a string.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                    "Signature element name is not a metadata string.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+        e->semantic_name = element_node->operands[1]->u.string_value;
+
+        e->component_type = vkd3d_component_type_from_dxil_component_type(values[2]);
+        e->min_precision = minimum_precision_from_dxil_component_type(values[2]);
+
+        j = values[3];
+        e->sysval_semantic = sysval_semantic_from_dxil_semantic_kind(j);
+        if (j != SEMANTIC_KIND_ARBITRARY && j != SEMANTIC_KIND_TARGET && e->sysval_semantic == VKD3D_SHADER_SV_NONE)
+        {
+            WARN("Unhandled semantic kind %u.\n", j);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                    "DXIL semantic kind %u is unhandled.", j);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        if ((e->interpolation_mode = values[5]) >= VKD3DSIM_COUNT)
+        {
+            WARN("Unhandled interpolation mode %u.\n", e->interpolation_mode);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                    "Interpolation mode %u is unhandled.", e->interpolation_mode);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        e->register_count = values[6];
+        column_count = values[7];
+        e->register_index = values[8];
+        e->target_location = e->register_index;
+        if (e->register_index > MAX_REG_OUTPUT || e->register_count > MAX_REG_OUTPUT - e->register_index)
+        {
+            WARN("Invalid row start %u with row count %u.\n", e->register_index, e->register_count);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                    "A signature element starting row of %u with count %u is invalid.",
+                    e->register_index, e->register_count);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+        index = values[9];
+        if (index >= VKD3D_VEC4_SIZE || column_count > VKD3D_VEC4_SIZE - index)
+        {
+            WARN("Invalid column start %u with count %u.\n", index, column_count);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                    "A signature element starting column %u with count %u is invalid.", index, column_count);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        e->mask = vkd3d_write_mask_from_component_count(column_count);
+        e->used_mask = e->mask;
+        e->mask <<= index;
+
+        signature_element_read_additional_element_values(e, element_node, sm6);
+        e->used_mask <<= index;
+
+        m = element_node->operands[4];
+        if (!sm6_metadata_value_is_node(m))
+        {
+            WARN("Semantic index list is not a node.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                    "Signature element semantic index list is not a metadata node.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        element_node = m->u.node;
+        for (j = 0; j < element_node->operand_count; ++j)
+        {
+            if (!sm6_metadata_get_uint_value(sm6, element_node->operands[j], &index))
+            {
+                WARN("Failed to get semantic index for row %u.\n", j);
+                vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                        "Signature element semantic index for row %u is not an integer.", j);
+            }
+            else if (!j)
+            {
+                e->semantic_index = index;
+            }
+            else if (index != e->semantic_index + j)
+            {
+                WARN("Semantic index %u for row %u is not of an incrementing sequence.\n", index, j);
+                vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                        "Signature element semantic index %u for row %u is not of an incrementing sequence.", index, j);
+            }
+        }
+    }
+
+    vkd3d_free(s->elements);
+    s->elements = elements;
+    s->element_count = operand_count;
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result sm6_parser_signatures_init(struct sm6_parser *sm6, const struct sm6_metadata_value *m)
+{
+    enum vkd3d_result ret;
+
+    if (!sm6_metadata_value_is_node(m))
     {
-        FIXME("Unhandled call to local function.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
-                "Call to a local function is unsupported.");
-        return;
+        WARN("Signature table is not a node.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
+                "Signature table is not a metadata node.");
+        return VKD3D_ERROR_INVALID_SHADER;
     }
-    if (!sm6_value_is_dx_intrinsic_dcl(fn_value))
-        WARN("External function is not a dx intrinsic.\n");
 
-    if (!operand_count)
+    if (m->u.node->operand_count && (ret = sm6_parser_read_signature(sm6, m->u.node->operands[0],
+            &sm6->p.shader_desc.input_signature)) < 0)
     {
-        WARN("Missing dx intrinsic function id.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
-                "The id for a dx intrinsic function is missing.");
-        return;
+        return ret;
     }
-
-    op_value = operands[0];
-    if (!sm6_value_is_constant(op_value) || !sm6_type_is_integer(op_value->type))
+    if (m->u.node->operand_count > 1 && (ret = sm6_parser_read_signature(sm6, m->u.node->operands[1],
+            &sm6->p.shader_desc.output_signature)) < 0)
     {
-        WARN("dx intrinsic function id is not a constant int.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
-                "Expected a constant integer dx intrinsic function id.");
-        return;
+        return ret;
     }
-    sm6_parser_decode_dx_op(sm6, code_block, register_get_uint_value(&op_value->u.reg),
-            fn_value->u.function.name, &operands[1], operand_count - 1, ins, dst);
+    /* TODO: patch constant signature in operand 2. */
+
+    sm6_parser_init_input_signature(sm6, &sm6->p.shader_desc.input_signature);
+    sm6_parser_init_output_signature(sm6, &sm6->p.shader_desc.output_signature);
+
+    return VKD3D_OK;
 }
 
-static void sm6_parser_emit_ret(struct sm6_parser *sm6, const struct dxil_record *record,
-        struct sm6_block *code_block, struct vkd3d_shader_instruction *ins)
+static void sm6_parser_emit_global_flags(struct sm6_parser *sm6, const struct sm6_metadata_value *m)
 {
-    if (!dxil_record_validate_operand_count(record, 0, 1, sm6))
-        return;
-
-    if (record->operand_count)
-        FIXME("Non-void return is not implemented.\n");
+    enum vkd3d_shader_global_flags global_flags, mask, rotated_flags;
+    struct vkd3d_shader_instruction *ins;
 
-    ins->handler_idx = VKD3DSIH_NOP;
+    if (!sm6_metadata_get_uint64_value(sm6, m, (uint64_t*)&global_flags))
+    {
+        WARN("Failed to load global flags.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES,
+                "Global flags metadata value is not an integer.");
+        return;
+    }
+    /* Rotate SKIP_OPTIMIZATION from bit 0 to bit 4 to match vkd3d_shader_global_flags. */
+    mask = (VKD3DSGF_SKIP_OPTIMIZATION << 1) - 1;
+    rotated_flags = global_flags & mask;
+    rotated_flags = (rotated_flags >> 1) | ((rotated_flags & 1) << 4);
+    global_flags = (global_flags & ~mask) | rotated_flags;
+
+    ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_GLOBAL_FLAGS);
+    ins->declaration.global_flags = global_flags;
 }
 
-static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6, const struct dxil_block *block,
-        struct sm6_function *function)
+static enum vkd3d_result sm6_parser_emit_thread_group(struct sm6_parser *sm6, const struct sm6_metadata_value *m)
 {
+    const struct sm6_metadata_node *node;
     struct vkd3d_shader_instruction *ins;
-    const struct dxil_record *record;
-    bool ret_found, is_terminator;
-    struct sm6_block *code_block;
-    struct sm6_value *dst;
-    size_t i, block_idx;
+    unsigned int group_sizes[3];
+    unsigned int i;
 
-    if (sm6->function_count)
+    if (sm6->p.shader_version.type != VKD3D_SHADER_TYPE_COMPUTE)
     {
-        FIXME("Multiple functions are not supported yet.\n");
+        WARN("Shader of type %#x has thread group dimensions.\n", sm6->p.shader_version.type);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES,
+                "Shader has thread group dimensions but is not a compute shader.");
         return VKD3D_ERROR_INVALID_SHADER;
     }
-    if (!(function->declaration = sm6_parser_next_function_definition(sm6)))
+
+    if (!m || !sm6_metadata_value_is_node(m))
     {
-        WARN("Failed to find definition to match function body.\n");
+        WARN("Thread group dimension value is not a node.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES,
+                "Thread group dimension metadata value is not a node.");
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
-    if (block->record_count < 2)
+    node = m->u.node;
+    if (node->operand_count != 3)
     {
-        /* It should contain at least a block count and a RET instruction. */
-        WARN("Invalid function block record count %zu.\n", block->record_count);
+        WARN("Invalid operand count %u.\n", node->operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "Thread group dimension operand count %u is invalid.", node->operand_count);
         return VKD3D_ERROR_INVALID_SHADER;
     }
-    if (block->records[0]->code != FUNC_CODE_DECLAREBLOCKS || !block->records[0]->operand_count
-            || block->records[0]->operands[0] > UINT_MAX)
+
+    for (i = 0; i < 3; ++i)
     {
-        WARN("Block count declaration not found or invalid.\n");
-        return VKD3D_ERROR_INVALID_SHADER;
+        if (!sm6_metadata_get_uint_value(sm6, node->operands[i], &group_sizes[i]))
+        {
+            WARN("Thread group dimension is not an integer value.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES,
+                    "Thread group dimension metadata value is not an integer.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+        if (!group_sizes[i] || group_sizes[i] > dx_max_thread_group_size[i])
+        {
+            char dim = "XYZ"[i];
+            WARN("Invalid thread group %c dimension %u.\n", dim, group_sizes[i]);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES,
+                    "Thread group %c dimension %u is invalid.", dim, group_sizes[i]);
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
     }
 
-    if (!(function->block_count = block->records[0]->operands[0]))
+    ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_THREAD_GROUP);
+    ins->declaration.thread_group_size.x = group_sizes[0];
+    ins->declaration.thread_group_size.y = group_sizes[1];
+    ins->declaration.thread_group_size.z = group_sizes[2];
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result sm6_parser_entry_point_init(struct sm6_parser *sm6)
+{
+    const struct sm6_metadata_value *m = sm6_parser_find_named_metadata(sm6, "dx.entryPoints");
+    const struct sm6_metadata_node *node, *entry_node = m ? m->u.node : NULL;
+    enum dxil_shader_properties_tag tag;
+    unsigned int i, operand_count;
+    const struct sm6_value *value;
+    enum vkd3d_result ret;
+
+    if (!entry_node || entry_node->operand_count < 2 || !(m = entry_node->operands[0]))
     {
-        WARN("Function contains no blocks.\n");
+        WARN("No entry point definition found.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_ENTRY_POINT,
+                "No entry point definition found in the metadata.");
         return VKD3D_ERROR_INVALID_SHADER;
     }
-    if (function->block_count > 1)
+
+    if (m->type != VKD3D_METADATA_VALUE)
     {
-        FIXME("Branched shaders are not supported yet.\n");
+        WARN("Entry point definition is not a value.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_ENTRY_POINT,
+                "Entry point definition is not a metadata value.");
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
-    if (!(function->blocks[0] = sm6_block_create()))
+    value = m->u.value;
+    if (!sm6_value_is_function_dcl(value))
     {
-        ERR("Failed to allocate code block.\n");
-        return VKD3D_ERROR_OUT_OF_MEMORY;
+        WARN("Entry point value is not a function definition.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_ENTRY_POINT,
+                "Entry point metadata value does not contain a function definition.");
+        return VKD3D_ERROR_INVALID_SHADER;
     }
-    code_block = function->blocks[0];
 
-    sm6->cur_max_value = function->value_count;
+    sm6->entry_point = value->u.function.name;
+    if (!sm6_metadata_value_is_string(entry_node->operands[1])
+            || ascii_strcasecmp(sm6->entry_point, entry_node->operands[1]->u.string_value))
+    {
+        WARN("Entry point function name %s mismatch.\n", sm6->entry_point);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_ENTRY_POINT_MISMATCH,
+                "Entry point function name %s does not match the name in metadata.", sm6->entry_point);
+    }
 
-    for (i = 1, block_idx = 0, ret_found = false; i < block->record_count; ++i)
+    if (entry_node->operand_count >= 3 && (m = entry_node->operands[2])
+            && (ret = sm6_parser_signatures_init(sm6, m)) < 0)
     {
-        sm6->p.location.column = i;
+        return ret;
+    }
 
-        if (!code_block)
+    if (entry_node->operand_count >= 5 && (m = entry_node->operands[4]))
+    {
+        if (!sm6_metadata_value_is_node(m))
         {
-            WARN("Invalid block count %zu.\n", function->block_count);
-            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
-                    "Invalid block count %zu.", function->block_count);
+            WARN("Shader properties list is not a node.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES,
+                    "Shader properties tag/value list is not a metadata node.");
             return VKD3D_ERROR_INVALID_SHADER;
         }
 
-        /* block->record_count - 1 is the instruction count, but some instructions
-         * can emit >1 IR instruction, so extra may be used. */
-        if (!vkd3d_array_reserve((void **)&code_block->instructions, &code_block->instruction_capacity,
-                max(code_block->instruction_count + 1, block->record_count), sizeof(*code_block->instructions)))
+        node = m->u.node;
+        if (node->operand_count & 1)
         {
-            ERR("Failed to allocate instructions.\n");
-            return VKD3D_ERROR_OUT_OF_MEMORY;
+            WARN("Operand count is not even.\n");
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                    "Operand count for shader properties tag/value pairs is not even.");
         }
+        operand_count = node->operand_count & ~1u;
 
-        ins = &code_block->instructions[code_block->instruction_count];
-        ins->handler_idx = VKD3DSIH_INVALID;
-
-        dst = sm6_parser_get_current_value(sm6);
-        dst->type = NULL;
-        dst->value_type = VALUE_TYPE_REG;
-        is_terminator = false;
-
-        record = block->records[i];
-        switch (record->code)
+        for (i = 0; i < operand_count; i += 2)
         {
-            case FUNC_CODE_INST_CALL:
-                sm6_parser_emit_call(sm6, record, code_block, ins, dst);
-                break;
-            case FUNC_CODE_INST_RET:
-                sm6_parser_emit_ret(sm6, record, code_block, ins);
-                is_terminator = true;
-                ret_found = true;
-                break;
-            default:
-                FIXME("Unhandled dxil instruction %u.\n", record->code);
+            if (!sm6_metadata_get_uint_value(sm6, node->operands[i], &tag))
+            {
+                WARN("Tag is not an integer value.\n");
+                vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES,
+                        "Shader properties tag at index %u is not an integer.", i);
                 return VKD3D_ERROR_INVALID_SHADER;
-        }
-
-        if (sm6->p.failed)
-            return VKD3D_ERROR;
-        assert(ins->handler_idx != VKD3DSIH_INVALID);
+            }
 
-        if (is_terminator)
-        {
-            ++block_idx;
-            code_block = (block_idx < function->block_count) ? function->blocks[block_idx] : NULL;
+            switch (tag)
+            {
+                case SHADER_PROPERTIES_FLAGS:
+                    sm6_parser_emit_global_flags(sm6, node->operands[i + 1]);
+                    break;
+               case SHADER_PROPERTIES_COMPUTE:
+                    if ((ret = sm6_parser_emit_thread_group(sm6, node->operands[i + 1])) < 0)
+                        return ret;
+                    break;
+                default:
+                    FIXME("Unhandled tag %#x.\n", tag);
+                    vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES,
+                            "Shader properties tag %#x is unhandled.", tag);
+                    break;
+            }
         }
-        if (code_block)
-            code_block->instruction_count += ins->handler_idx != VKD3DSIH_NOP;
-        else
-            assert(ins->handler_idx == VKD3DSIH_NOP);
-
-        sm6->value_count += !!dst->type;
-    }
-
-    if (!ret_found)
-    {
-        WARN("Function contains no RET instruction.\n");
-        return VKD3D_ERROR_INVALID_SHADER;
     }
 
     return VKD3D_OK;
 }
 
-static bool sm6_block_emit_instructions(struct sm6_block *block, struct sm6_parser *sm6)
+static void sm6_metadata_value_destroy(struct sm6_metadata_value *m)
 {
-    struct vkd3d_shader_instruction *ins = sm6_parser_require_space(sm6, block->instruction_count + 1);
-
-    if (!ins)
-        return false;
-
-    memcpy(ins, block->instructions, block->instruction_count * sizeof(*block->instructions));
-    sm6->p.instructions.count += block->instruction_count;
-
-    sm6_parser_add_instruction(sm6, VKD3DSIH_RET);
-
-    return true;
+    switch (m->type)
+    {
+        case VKD3D_METADATA_NODE:
+            vkd3d_free(m->u.node);
+            break;
+        case VKD3D_METADATA_KIND:
+            vkd3d_free(m->u.kind.name);
+            break;
+        case VKD3D_METADATA_STRING:
+            vkd3d_free(m->u.string_value);
+            break;
+        default:
+            break;
+    }
 }
 
-static enum vkd3d_result sm6_parser_module_init(struct sm6_parser *sm6, const struct dxil_block *block,
-        unsigned int level)
+static void sm6_parser_metadata_cleanup(struct sm6_parser *sm6)
 {
-    size_t i, old_value_count = sm6->value_count;
-    struct sm6_function *function;
-    enum vkd3d_result ret;
+    unsigned int i, j;
 
-    for (i = 0; i < block->child_block_count; ++i)
+    for (i = 0; i < ARRAY_SIZE(sm6->metadata_tables); ++i)
     {
-        if ((ret = sm6_parser_module_init(sm6, block->child_blocks[i], level + 1)) < 0)
-            return ret;
+        for (j = 0; j < sm6->metadata_tables[i].count; ++j)
+            sm6_metadata_value_destroy(&sm6->metadata_tables[i].values[j]);
+        vkd3d_free(sm6->metadata_tables[i].values);
     }
-
-    sm6->p.location.line = block->id;
-    sm6->p.location.column = 0;
-
-    switch (block->id)
+    for (i = 0; i < sm6->named_metadata_count; ++i)
     {
-        case CONSTANTS_BLOCK:
-            function = &sm6->functions[sm6->function_count];
-            sm6->cur_max_value = function->value_count;
-            return sm6_parser_constants_init(sm6, block);
-
-        case FUNCTION_BLOCK:
-            function = &sm6->functions[sm6->function_count];
-            if ((ret = sm6_parser_function_init(sm6, block, function)) < 0)
-                return ret;
-            /* The value index returns to its previous value after handling a function. It's usually nonzero
-             * at the start because of global constants/variables/function declarations. Function constants
-             * occur in a child block, so value_count is already saved before they are emitted. */
-            memset(&sm6->values[old_value_count], 0, (sm6->value_count - old_value_count) * sizeof(*sm6->values));
-            sm6->value_count = old_value_count;
-            break;
-
-        case BLOCKINFO_BLOCK:
-        case MODULE_BLOCK:
-        case PARAMATTR_BLOCK:
-        case PARAMATTR_GROUP_BLOCK:
-        case VALUE_SYMTAB_BLOCK:
-        case METADATA_BLOCK:
-        case METADATA_ATTACHMENT_BLOCK:
-        case TYPE_BLOCK:
-            break;
-
-        default:
-            FIXME("Unhandled block id %u.\n", block->id);
-            break;
+        sm6_metadata_value_destroy(&sm6->named_metadata[i].value);
+        vkd3d_free(sm6->named_metadata[i].name);
     }
-
-    return VKD3D_OK;
+    vkd3d_free(sm6->named_metadata);
 }
 
 static void sm6_type_table_cleanup(struct sm6_type *types, size_t count)
@@ -2669,6 +5448,8 @@ static void sm6_parser_destroy(struct vkd3d_shader_parser *parser)
     sm6_type_table_cleanup(sm6->types, sm6->type_count);
     sm6_symtab_cleanup(sm6->global_symbols, sm6->global_symbol_count);
     sm6_functions_cleanup(sm6->functions, sm6->function_count);
+    sm6_parser_metadata_cleanup(sm6);
+    vkd3d_free(sm6->descriptors);
     vkd3d_free(sm6->values);
     free_shader_desc(&parser->shader_desc);
     vkd3d_free(sm6);
@@ -2679,10 +5460,20 @@ static const struct vkd3d_shader_parser_ops sm6_parser_ops =
     .parser_destroy = sm6_parser_destroy,
 };
 
+static struct sm6_function *sm6_parser_get_function(const struct sm6_parser *sm6, const char *name)
+{
+    size_t i;
+    for (i = 0; i < sm6->function_count; ++i)
+        if (!ascii_strcasecmp(sm6->functions[i].declaration->u.function.name, name))
+            return &sm6->functions[i];
+    return NULL;
+}
+
 static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t *byte_code, size_t byte_code_size,
         const char *source_name, struct vkd3d_shader_message_context *message_context)
 {
     const struct shader_signature *output_signature = &sm6->p.shader_desc.output_signature;
+    const struct shader_signature *input_signature = &sm6->p.shader_desc.input_signature;
     const struct vkd3d_shader_location location = {.source_name = source_name};
     uint32_t version_token, dxil_version, token_count, magic;
     unsigned int chunk_offset, chunk_size;
@@ -2690,8 +5481,9 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
     enum bitcode_block_abbreviation abbr;
     struct vkd3d_shader_version version;
     struct dxil_block *block;
+    struct sm6_function *fn;
     enum vkd3d_result ret;
-    unsigned int i;
+    unsigned int i, j;
 
     count = byte_code_size / sizeof(*byte_code);
     if (count < 6)
@@ -2838,11 +5630,12 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
         return ret;
     }
 
-    if (!(sm6->output_params = shader_parser_get_dst_params(&sm6->p, output_signature->element_count)))
+    if (!(sm6->output_params = shader_parser_get_dst_params(&sm6->p, output_signature->element_count))
+            || !(sm6->input_params = shader_parser_get_dst_params(&sm6->p, input_signature->element_count)))
     {
-        ERR("Failed to allocate output parameters.\n");
+        ERR("Failed to allocate input/output parameters.\n");
         vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
-                "Out of memory allocating output parameters.");
+                "Out of memory allocating input/output parameters.");
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
 
@@ -2869,6 +5662,7 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
                 "Out of memory allocating DXIL value array.");
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
+    sm6->ssa_next_id = 1;
 
     if ((ret = sm6_parser_globals_init(sm6)) < 0)
     {
@@ -2876,7 +5670,35 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
         return ret;
     }
 
-    sm6_parser_init_output_signature(sm6, output_signature);
+    if (!sm6_parser_allocate_named_metadata(sm6))
+    {
+        ERR("Failed to allocate named metadata array.\n");
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    }
+
+    for (i = 0, j = 0; i < sm6->root_block.child_block_count; ++i)
+    {
+        block = sm6->root_block.child_blocks[i];
+        if (block->id != METADATA_BLOCK)
+            continue;
+
+        if (j == ARRAY_SIZE(sm6->metadata_tables))
+        {
+            FIXME("Too many metadata tables.\n");
+            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
+                    "A metadata table count greater than %zu is unsupported.", ARRAY_SIZE(sm6->metadata_tables));
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+
+        if ((ret = sm6_parser_metadata_init(sm6, block, &sm6->metadata_tables[j++])) < 0)
+            return ret;
+    }
+
+    if ((ret = sm6_parser_entry_point_init(sm6)) < 0)
+        return ret;
+
+    if ((ret = sm6_parser_resources_init(sm6)) < 0)
+        return ret;
 
     if ((ret = sm6_parser_module_init(sm6, &sm6->root_block, 0)) < 0)
     {
@@ -2889,22 +5711,31 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
         return ret;
     }
 
-    if (!sm6_parser_require_space(sm6, output_signature->element_count))
+    if (!sm6_parser_require_space(sm6, output_signature->element_count + input_signature->element_count))
     {
         vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
                 "Out of memory emitting shader signature declarations.");
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
     sm6_parser_emit_output_signature(sm6, output_signature);
+    sm6_parser_emit_input_signature(sm6, input_signature);
 
-    for (i = 0; i < sm6->function_count; ++i)
+    sm6->p.shader_desc.ssa_count = sm6->ssa_next_id;
+
+    if (!(fn = sm6_parser_get_function(sm6, sm6->entry_point)))
     {
-        if (!sm6_block_emit_instructions(sm6->functions[i].blocks[0], sm6))
-        {
-            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
-                    "Out of memory emitting shader instructions.");
-            return VKD3D_ERROR_OUT_OF_MEMORY;
-        }
+        WARN("Failed to find entry point %s.\n", sm6->entry_point);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_ENTRY_POINT,
+                "The definition of the entry point function '%s' was not found.", sm6->entry_point);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    assert(sm6->function_count == 1);
+    if (!sm6_block_emit_instructions(fn->blocks[0], sm6))
+    {
+        vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Out of memory emitting shader instructions.");
+        return VKD3D_ERROR_OUT_OF_MEMORY;
     }
 
     dxil_block_destroy(&sm6->root_block);
@@ -2955,6 +5786,12 @@ int vkd3d_shader_sm6_parser_create(const struct vkd3d_shader_compile_info *compi
             compile_info->source_name, message_context);
     vkd3d_free(byte_code);
 
+    if (!sm6->p.failed && ret >= 0)
+        vsir_validate(&sm6->p);
+
+    if (sm6->p.failed && ret >= 0)
+        ret = VKD3D_ERROR_INVALID_SHADER;
+
     if (ret < 0)
     {
         WARN("Failed to initialise shader parser.\n");
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 5fe9047bf25..501bff8cfb8 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -216,13 +216,15 @@ bool hlsl_type_is_resource(const struct hlsl_type *type)
     return false;
 }
 
-enum hlsl_regset hlsl_type_get_regset(const struct hlsl_type *type)
+/* Only intended to be used for derefs (after copies have been lowered to components or vectors) or
+ * resources, since for both their data types span across a single regset. */
+static enum hlsl_regset type_get_regset(const struct hlsl_type *type)
 {
-    if (type->class <= HLSL_CLASS_LAST_NUMERIC)
+    if (hlsl_is_numeric_type(type))
         return HLSL_REGSET_NUMERIC;
 
     if (type->class == HLSL_CLASS_ARRAY)
-        return hlsl_type_get_regset(type->e.array.type);
+        return type_get_regset(type->e.array.type);
 
     if (type->class == HLSL_CLASS_OBJECT)
     {
@@ -245,6 +247,11 @@ enum hlsl_regset hlsl_type_get_regset(const struct hlsl_type *type)
     vkd3d_unreachable();
 }
 
+enum hlsl_regset hlsl_deref_get_regset(struct hlsl_ctx *ctx, const struct hlsl_deref *deref)
+{
+    return type_get_regset(hlsl_deref_get_type(ctx, deref));
+}
+
 unsigned int hlsl_type_get_sm4_offset(const struct hlsl_type *type, unsigned int offset)
 {
     /* Align to the next vec4 boundary if:
@@ -324,7 +331,7 @@ static void hlsl_type_calculate_reg_size(struct hlsl_ctx *ctx, struct hlsl_type
         {
             if (hlsl_type_is_resource(type))
             {
-                enum hlsl_regset regset = hlsl_type_get_regset(type);
+                enum hlsl_regset regset = type_get_regset(type);
 
                 type->reg_size[regset] = 1;
             }
@@ -452,11 +459,11 @@ struct hlsl_type *hlsl_type_get_component_type(struct hlsl_ctx *ctx, struct hlsl
 }
 
 unsigned int hlsl_type_get_component_offset(struct hlsl_ctx *ctx, struct hlsl_type *type,
-        enum hlsl_regset regset, unsigned int index)
+        unsigned int index, enum hlsl_regset *regset)
 {
+    unsigned int offset[HLSL_REGSET_LAST + 1] = {0};
     struct hlsl_type *next_type;
-    unsigned int offset = 0;
-    unsigned int idx;
+    unsigned int idx, r;
 
     while (!type_is_single_component(type))
     {
@@ -468,19 +475,22 @@ unsigned int hlsl_type_get_component_offset(struct hlsl_ctx *ctx, struct hlsl_ty
             case HLSL_CLASS_SCALAR:
             case HLSL_CLASS_VECTOR:
             case HLSL_CLASS_MATRIX:
-                if (regset == HLSL_REGSET_NUMERIC)
-                    offset += idx;
+                offset[HLSL_REGSET_NUMERIC] += idx;
                 break;
 
             case HLSL_CLASS_STRUCT:
-                offset += type->e.record.fields[idx].reg_offset[regset];
+                for (r = 0; r <= HLSL_REGSET_LAST; ++r)
+                    offset[r] += type->e.record.fields[idx].reg_offset[r];
                 break;
 
             case HLSL_CLASS_ARRAY:
-                if (regset == HLSL_REGSET_NUMERIC)
-                    offset += idx * align(type->e.array.type->reg_size[regset], 4);
-                else
-                    offset += idx * type->e.array.type->reg_size[regset];
+                for (r = 0; r <= HLSL_REGSET_LAST; ++r)
+                {
+                    if (r == HLSL_REGSET_NUMERIC)
+                        offset[r] += idx * align(type->e.array.type->reg_size[r], 4);
+                    else
+                        offset[r] += idx * type->e.array.type->reg_size[r];
+                }
                 break;
 
             case HLSL_CLASS_OBJECT:
@@ -493,7 +503,8 @@ unsigned int hlsl_type_get_component_offset(struct hlsl_ctx *ctx, struct hlsl_ty
         type = next_type;
     }
 
-    return offset;
+    *regset = type_get_regset(type);
+    return offset[*regset];
 }
 
 static bool init_deref(struct hlsl_ctx *ctx, struct hlsl_deref *deref, struct hlsl_ir_var *var,
@@ -501,7 +512,9 @@ static bool init_deref(struct hlsl_ctx *ctx, struct hlsl_deref *deref, struct hl
 {
     deref->var = var;
     deref->path_len = path_len;
-    deref->offset.node = NULL;
+    deref->rel_offset.node = NULL;
+    deref->const_offset = 0;
+    deref->data_type = NULL;
 
     if (path_len == 0)
     {
@@ -528,7 +541,8 @@ bool hlsl_init_deref_from_index_chain(struct hlsl_ctx *ctx, struct hlsl_deref *d
 
     deref->path = NULL;
     deref->path_len = 0;
-    deref->offset.node = NULL;
+    deref->rel_offset.node = NULL;
+    deref->const_offset = 0;
 
     assert(chain);
     if (chain->type == HLSL_IR_INDEX)
@@ -591,7 +605,7 @@ struct hlsl_type *hlsl_deref_get_type(struct hlsl_ctx *ctx, const struct hlsl_de
 
     assert(deref);
 
-    if (deref->offset.node)
+    if (hlsl_deref_is_lowered(deref))
         return deref->data_type;
 
     type = deref->var->data_type;
@@ -745,7 +759,7 @@ struct hlsl_type *hlsl_new_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim
 {
     struct hlsl_type *type;
 
-    if (!(type = vkd3d_calloc(1, sizeof(*type))))
+    if (!(type = hlsl_alloc(ctx, sizeof(*type))))
         return NULL;
     type->class = HLSL_CLASS_OBJECT;
     type->base_type = HLSL_TYPE_UAV;
@@ -811,17 +825,15 @@ struct hlsl_ir_function *hlsl_get_function(struct hlsl_ctx *ctx, const char *nam
     return NULL;
 }
 
-struct hlsl_ir_function_decl *hlsl_get_func_decl(struct hlsl_ctx *ctx, const char *name)
+struct hlsl_ir_function_decl *hlsl_get_first_func_decl(struct hlsl_ctx *ctx, const char *name)
 {
-    struct hlsl_ir_function_decl *decl;
     struct hlsl_ir_function *func;
     struct rb_entry *entry;
 
     if ((entry = rb_get(&ctx->functions, name)))
     {
         func = RB_ENTRY_VALUE(entry, struct hlsl_ir_function, entry);
-        RB_FOR_EACH_ENTRY(decl, &func->overloads, struct hlsl_ir_function_decl, entry)
-            return decl;
+        return LIST_ENTRY(list_head(&func->overloads), struct hlsl_ir_function_decl, entry);
     }
 
     return NULL;
@@ -1102,7 +1114,7 @@ bool hlsl_copy_deref(struct hlsl_ctx *ctx, struct hlsl_deref *deref, const struc
     if (!other)
         return true;
 
-    assert(!other->offset.node);
+    assert(!hlsl_deref_is_lowered(other));
 
     if (!init_deref(ctx, deref, other->var, other->path_len))
         return false;
@@ -1124,7 +1136,8 @@ void hlsl_cleanup_deref(struct hlsl_deref *deref)
     deref->path = NULL;
     deref->path_len = 0;
 
-    hlsl_src_remove(&deref->offset);
+    hlsl_src_remove(&deref->rel_offset);
+    deref->const_offset = 0;
 }
 
 /* Initializes a simple variable dereference, so that it can be passed to load/store functions. */
@@ -1159,7 +1172,7 @@ struct hlsl_ir_node *hlsl_new_store_index(struct hlsl_ctx *ctx, const struct hls
     unsigned int i;
 
     assert(lhs);
-    assert(!lhs->offset.node);
+    assert(!hlsl_deref_is_lowered(lhs));
 
     if (!(store = hlsl_alloc(ctx, sizeof(*store))))
         return NULL;
@@ -1325,6 +1338,40 @@ struct hlsl_ir_node *hlsl_new_if(struct hlsl_ctx *ctx, struct hlsl_ir_node *cond
     return &iff->node;
 }
 
+struct hlsl_ir_switch_case *hlsl_new_switch_case(struct hlsl_ctx *ctx, unsigned int value,
+        bool is_default, struct hlsl_block *body, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_switch_case *c;
+
+    if (!(c = hlsl_alloc(ctx, sizeof(*c))))
+        return NULL;
+
+    c->value = value;
+    c->is_default = is_default;
+    hlsl_block_init(&c->body);
+    if (body)
+        hlsl_block_add_block(&c->body, body);
+    c->loc = *loc;
+
+    return c;
+}
+
+struct hlsl_ir_node *hlsl_new_switch(struct hlsl_ctx *ctx, struct hlsl_ir_node *selector,
+        struct list *cases, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_switch *s;
+
+    if (!(s = hlsl_alloc(ctx, sizeof(*s))))
+        return NULL;
+    init_node(&s->node, HLSL_IR_SWITCH, NULL, loc);
+    hlsl_src_from_node(&s->selector, selector);
+    list_init(&s->cases);
+    if (cases)
+        list_move_head(&s->cases, cases);
+
+    return &s->node;
+}
+
 struct hlsl_ir_load *hlsl_new_load_index(struct hlsl_ctx *ctx, const struct hlsl_deref *deref,
         struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc)
 {
@@ -1332,7 +1379,7 @@ struct hlsl_ir_load *hlsl_new_load_index(struct hlsl_ctx *ctx, const struct hlsl
     struct hlsl_type *type;
     unsigned int i;
 
-    assert(!deref->offset.node);
+    assert(!hlsl_deref_is_lowered(deref));
 
     type = hlsl_deref_get_type(ctx, deref);
     if (idx)
@@ -1568,7 +1615,7 @@ static bool clone_block(struct hlsl_ctx *ctx, struct hlsl_block *dst_block,
 
         if (!list_empty(&src->uses))
         {
-            if (!vkd3d_array_reserve((void **)&map->instrs, &map->capacity, map->count + 1, sizeof(*map->instrs)))
+            if (!hlsl_array_reserve(ctx, (void **)&map->instrs, &map->capacity, map->count + 1, sizeof(*map->instrs)))
             {
                 hlsl_block_cleanup(dst_block);
                 return false;
@@ -1605,7 +1652,7 @@ static bool clone_deref(struct hlsl_ctx *ctx, struct clone_instr_map *map,
 {
     unsigned int i;
 
-    assert(!src->offset.node);
+    assert(!hlsl_deref_is_lowered(src));
 
     if (!init_deref(ctx, dst, src->var, src->path_len))
         return false;
@@ -1787,6 +1834,58 @@ static struct hlsl_ir_node *clone_index(struct hlsl_ctx *ctx, struct clone_instr
     return dst;
 }
 
+void hlsl_free_ir_switch_case(struct hlsl_ir_switch_case *c)
+{
+    hlsl_block_cleanup(&c->body);
+    list_remove(&c->entry);
+    vkd3d_free(c);
+}
+
+void hlsl_cleanup_ir_switch_cases(struct list *cases)
+{
+    struct hlsl_ir_switch_case *c, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE(c, next, cases, struct hlsl_ir_switch_case, entry)
+    {
+        hlsl_free_ir_switch_case(c);
+    }
+}
+
+static struct hlsl_ir_node *clone_switch(struct hlsl_ctx *ctx,
+        struct clone_instr_map *map, struct hlsl_ir_switch *s)
+{
+    struct hlsl_ir_switch_case *c, *d;
+    struct hlsl_ir_node *ret;
+    struct hlsl_block body;
+    struct list cases;
+
+    list_init(&cases);
+
+    LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+    {
+        if (!(clone_block(ctx, &body, &c->body, map)))
+        {
+            hlsl_cleanup_ir_switch_cases(&cases);
+            return NULL;
+        }
+
+        d = hlsl_new_switch_case(ctx, c->value, c->is_default, &body, &c->loc);
+        hlsl_block_cleanup(&body);
+        if (!d)
+        {
+            hlsl_cleanup_ir_switch_cases(&cases);
+            return NULL;
+        }
+
+        list_add_tail(&cases, &d->entry);
+    }
+
+    ret = hlsl_new_switch(ctx, map_instr(map, s->selector.node), &cases, &s->node.loc);
+    hlsl_cleanup_ir_switch_cases(&cases);
+
+    return ret;
+}
+
 static struct hlsl_ir_node *clone_instr(struct hlsl_ctx *ctx,
         struct clone_instr_map *map, const struct hlsl_ir_node *instr)
 {
@@ -1825,6 +1924,9 @@ static struct hlsl_ir_node *clone_instr(struct hlsl_ctx *ctx,
         case HLSL_IR_STORE:
             return clone_store(ctx, map, hlsl_ir_store(instr));
 
+        case HLSL_IR_SWITCH:
+            return clone_switch(ctx, map, hlsl_ir_switch(instr));
+
         case HLSL_IR_SWIZZLE:
             return clone_swizzle(ctx, map, hlsl_ir_swizzle(instr));
     }
@@ -1946,76 +2048,38 @@ void hlsl_pop_scope(struct hlsl_ctx *ctx)
     ctx->cur_scope = prev_scope;
 }
 
-static int compare_param_hlsl_types(const struct hlsl_type *t1, const struct hlsl_type *t2)
+static bool func_decl_matches(const struct hlsl_ir_function_decl *decl,
+        const struct hlsl_func_parameters *parameters)
 {
-    int r;
-
-    if ((r = vkd3d_u32_compare(t1->class, t2->class)))
-    {
-        if (!((t1->class == HLSL_CLASS_SCALAR && t2->class == HLSL_CLASS_VECTOR)
-                || (t1->class == HLSL_CLASS_VECTOR && t2->class == HLSL_CLASS_SCALAR)))
-            return r;
-    }
-    if ((r = vkd3d_u32_compare(t1->base_type, t2->base_type)))
-        return r;
-    if (t1->base_type == HLSL_TYPE_SAMPLER || t1->base_type == HLSL_TYPE_TEXTURE)
-    {
-        if ((r = vkd3d_u32_compare(t1->sampler_dim, t2->sampler_dim)))
-            return r;
-        if (t1->base_type == HLSL_TYPE_TEXTURE && t1->sampler_dim != HLSL_SAMPLER_DIM_GENERIC
-                && (r = compare_param_hlsl_types(t1->e.resource_format, t2->e.resource_format)))
-            return r;
-    }
-    if ((r = vkd3d_u32_compare(t1->dimx, t2->dimx)))
-        return r;
-    if ((r = vkd3d_u32_compare(t1->dimy, t2->dimy)))
-        return r;
-    if (t1->class == HLSL_CLASS_STRUCT)
-    {
-        size_t i;
-
-        if (t1->e.record.field_count != t2->e.record.field_count)
-            return t1->e.record.field_count - t2->e.record.field_count;
-
-        for (i = 0; i < t1->e.record.field_count; ++i)
-        {
-            const struct hlsl_struct_field *field1 = &t1->e.record.fields[i];
-            const struct hlsl_struct_field *field2 = &t2->e.record.fields[i];
+    size_t i;
 
-            if ((r = compare_param_hlsl_types(field1->type, field2->type)))
-                return r;
+    if (parameters->count != decl->parameters.count)
+        return false;
 
-            if ((r = strcmp(field1->name, field2->name)))
-                return r;
-        }
-        return 0;
-    }
-    if (t1->class == HLSL_CLASS_ARRAY)
+    for (i = 0; i < parameters->count; ++i)
     {
-        if ((r = vkd3d_u32_compare(t1->e.array.elements_count, t2->e.array.elements_count)))
-            return r;
-        return compare_param_hlsl_types(t1->e.array.type, t2->e.array.type);
+        if (!hlsl_types_are_equal(parameters->vars[i]->data_type, decl->parameters.vars[i]->data_type))
+            return false;
     }
-
-    return 0;
+    return true;
 }
 
-static int compare_function_decl_rb(const void *key, const struct rb_entry *entry)
+struct hlsl_ir_function_decl *hlsl_get_func_decl(struct hlsl_ctx *ctx, const char *name,
+        const struct hlsl_func_parameters *parameters)
 {
-    const struct hlsl_ir_function_decl *decl = RB_ENTRY_VALUE(entry, const struct hlsl_ir_function_decl, entry);
-    const struct hlsl_func_parameters *parameters = key;
-    size_t i;
-    int r;
+    struct hlsl_ir_function_decl *decl;
+    struct hlsl_ir_function *func;
 
-    if ((r = vkd3d_u32_compare(parameters->count, decl->parameters.count)))
-        return r;
+    if (!(func = hlsl_get_function(ctx, name)))
+        return NULL;
 
-    for (i = 0; i < parameters->count; ++i)
+    LIST_FOR_EACH_ENTRY(decl, &func->overloads, struct hlsl_ir_function_decl, entry)
     {
-        if ((r = compare_param_hlsl_types(parameters->vars[i]->data_type, decl->parameters.vars[i]->data_type)))
-            return r;
+        if (func_decl_matches(decl, parameters))
+            return decl;
     }
-    return 0;
+
+    return NULL;
 }
 
 struct vkd3d_string_buffer *hlsl_type_to_string(struct hlsl_ctx *ctx, const struct hlsl_type *type)
@@ -2193,6 +2257,10 @@ struct vkd3d_string_buffer *hlsl_modifiers_to_string(struct hlsl_ctx *ctx, unsig
         vkd3d_string_buffer_printf(string, "extern ");
     if (modifiers & HLSL_STORAGE_NOINTERPOLATION)
         vkd3d_string_buffer_printf(string, "nointerpolation ");
+    if (modifiers & HLSL_STORAGE_CENTROID)
+        vkd3d_string_buffer_printf(string, "centroid ");
+    if (modifiers & HLSL_STORAGE_NOPERSPECTIVE)
+        vkd3d_string_buffer_printf(string, "noperspective ");
     if (modifiers & HLSL_MODIFIER_PRECISE)
         vkd3d_string_buffer_printf(string, "precise ");
     if (modifiers & HLSL_STORAGE_SHARED)
@@ -2239,6 +2307,7 @@ const char *hlsl_node_type_to_string(enum hlsl_ir_node_type type)
         [HLSL_IR_RESOURCE_LOAD ] = "HLSL_IR_RESOURCE_LOAD",
         [HLSL_IR_RESOURCE_STORE] = "HLSL_IR_RESOURCE_STORE",
         [HLSL_IR_STORE         ] = "HLSL_IR_STORE",
+        [HLSL_IR_SWITCH        ] = "HLSL_IR_SWITCH",
         [HLSL_IR_SWIZZLE       ] = "HLSL_IR_SWIZZLE",
     };
 
@@ -2305,21 +2374,34 @@ static void dump_deref(struct vkd3d_string_buffer *buffer, const struct hlsl_der
     if (deref->var)
     {
         vkd3d_string_buffer_printf(buffer, "%s", deref->var->name);
-        if (deref->path_len)
+        if (!hlsl_deref_is_lowered(deref))
         {
-            vkd3d_string_buffer_printf(buffer, "[");
-            for (i = 0; i < deref->path_len; ++i)
+            if (deref->path_len)
             {
                 vkd3d_string_buffer_printf(buffer, "[");
-                dump_src(buffer, &deref->path[i]);
+                for (i = 0; i < deref->path_len; ++i)
+                {
+                    vkd3d_string_buffer_printf(buffer, "[");
+                    dump_src(buffer, &deref->path[i]);
+                    vkd3d_string_buffer_printf(buffer, "]");
+                }
                 vkd3d_string_buffer_printf(buffer, "]");
             }
-            vkd3d_string_buffer_printf(buffer, "]");
         }
-        else if (deref->offset.node)
+        else
         {
+            bool show_rel, show_const;
+
+            show_rel = deref->rel_offset.node;
+            show_const = deref->const_offset != 0 || !show_rel;
+
             vkd3d_string_buffer_printf(buffer, "[");
-            dump_src(buffer, &deref->offset);
+            if (show_rel)
+                dump_src(buffer, &deref->rel_offset);
+            if (show_rel && show_const)
+                vkd3d_string_buffer_printf(buffer, " + ");
+            if (show_const)
+                vkd3d_string_buffer_printf(buffer, "%uc", deref->const_offset);
             vkd3d_string_buffer_printf(buffer, "]");
         }
     }
@@ -2440,6 +2522,7 @@ const char *debug_hlsl_expr_op(enum hlsl_ir_expr_op op)
         [HLSL_OP1_ABS]          = "abs",
         [HLSL_OP1_BIT_NOT]      = "~",
         [HLSL_OP1_CAST]         = "cast",
+        [HLSL_OP1_CEIL]         = "ceil",
         [HLSL_OP1_COS]          = "cos",
         [HLSL_OP1_COS_REDUCED]  = "cos_reduced",
         [HLSL_OP1_DSX]          = "dsx",
@@ -2449,6 +2532,7 @@ const char *debug_hlsl_expr_op(enum hlsl_ir_expr_op op)
         [HLSL_OP1_DSY_COARSE]   = "dsy_coarse",
         [HLSL_OP1_DSY_FINE]     = "dsy_fine",
         [HLSL_OP1_EXP2]         = "exp2",
+        [HLSL_OP1_FLOOR]        = "floor",
         [HLSL_OP1_FRACT]        = "fract",
         [HLSL_OP1_LOG2]         = "log2",
         [HLSL_OP1_LOGIC_NOT]    = "!",
@@ -2485,6 +2569,7 @@ const char *debug_hlsl_expr_op(enum hlsl_ir_expr_op op)
         [HLSL_OP2_NEQUAL]      = "!=",
         [HLSL_OP2_RSHIFT]      = ">>",
 
+        [HLSL_OP3_CMP]         = "cmp",
         [HLSL_OP3_DP2ADD]      = "dp2add",
         [HLSL_OP3_MOVC]        = "movc",
         [HLSL_OP3_TERNARY]     = "ternary",
@@ -2540,6 +2625,10 @@ static void dump_ir_jump(struct vkd3d_string_buffer *buffer, const struct hlsl_i
         case HLSL_IR_JUMP_RETURN:
             vkd3d_string_buffer_printf(buffer, "return");
             break;
+
+        case HLSL_IR_JUMP_UNRESOLVED_CONTINUE:
+            vkd3d_string_buffer_printf(buffer, "unresolved_continue");
+            break;
     }
 }
 
@@ -2659,6 +2748,32 @@ static void dump_ir_index(struct vkd3d_string_buffer *buffer, const struct hlsl_
     vkd3d_string_buffer_printf(buffer, "]");
 }
 
+static void dump_ir_switch(struct hlsl_ctx *ctx, struct vkd3d_string_buffer *buffer, const struct hlsl_ir_switch *s)
+{
+    struct hlsl_ir_switch_case *c;
+
+    vkd3d_string_buffer_printf(buffer, "switch (");
+    dump_src(buffer, &s->selector);
+    vkd3d_string_buffer_printf(buffer, ") {\n");
+
+    LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+    {
+        if (c->is_default)
+        {
+            vkd3d_string_buffer_printf(buffer, "      %10s   default: {\n", "");
+        }
+        else
+        {
+            vkd3d_string_buffer_printf(buffer, "      %10s   case %u : {\n", "", c->value);
+        }
+
+        dump_block(ctx, buffer, &c->body);
+        vkd3d_string_buffer_printf(buffer, "      %10s   }\n", "");
+    }
+
+    vkd3d_string_buffer_printf(buffer, "      %10s   }", "");
+}
+
 static void dump_instr(struct hlsl_ctx *ctx, struct vkd3d_string_buffer *buffer, const struct hlsl_ir_node *instr)
 {
     if (instr->index)
@@ -2714,6 +2829,10 @@ static void dump_instr(struct hlsl_ctx *ctx, struct vkd3d_string_buffer *buffer,
             dump_ir_store(buffer, hlsl_ir_store(instr));
             break;
 
+        case HLSL_IR_SWITCH:
+            dump_ir_switch(ctx, buffer, hlsl_ir_switch(instr));
+            break;
+
         case HLSL_IR_SWIZZLE:
             dump_ir_swizzle(buffer, hlsl_ir_swizzle(instr));
             break;
@@ -2855,7 +2974,7 @@ static void free_ir_resource_load(struct hlsl_ir_resource_load *load)
 
 static void free_ir_resource_store(struct hlsl_ir_resource_store *store)
 {
-    hlsl_src_remove(&store->resource.offset);
+    hlsl_src_remove(&store->resource.rel_offset);
     hlsl_src_remove(&store->coords);
     hlsl_src_remove(&store->value);
     vkd3d_free(store);
@@ -2874,6 +2993,14 @@ static void free_ir_swizzle(struct hlsl_ir_swizzle *swizzle)
     vkd3d_free(swizzle);
 }
 
+static void free_ir_switch(struct hlsl_ir_switch *s)
+{
+    hlsl_src_remove(&s->selector);
+    hlsl_cleanup_ir_switch_cases(&s->cases);
+
+    vkd3d_free(s);
+}
+
 static void free_ir_index(struct hlsl_ir_index *index)
 {
     hlsl_src_remove(&index->val);
@@ -2934,6 +3061,10 @@ void hlsl_free_instr(struct hlsl_ir_node *node)
         case HLSL_IR_SWIZZLE:
             free_ir_swizzle(hlsl_ir_swizzle(node));
             break;
+
+        case HLSL_IR_SWITCH:
+            free_ir_switch(hlsl_ir_switch(node));
+            break;
     }
 }
 
@@ -2967,14 +3098,12 @@ static void free_function_decl(struct hlsl_ir_function_decl *decl)
     vkd3d_free(decl);
 }
 
-static void free_function_decl_rb(struct rb_entry *entry, void *context)
-{
-    free_function_decl(RB_ENTRY_VALUE(entry, struct hlsl_ir_function_decl, entry));
-}
-
 static void free_function(struct hlsl_ir_function *func)
 {
-    rb_destroy(&func->overloads, free_function_decl_rb, NULL);
+    struct hlsl_ir_function_decl *decl, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE(decl, next, &func->overloads, struct hlsl_ir_function_decl, entry)
+        free_function_decl(decl);
     vkd3d_free((void *)func->name);
     vkd3d_free(func);
 }
@@ -3004,17 +3133,15 @@ void hlsl_add_function(struct hlsl_ctx *ctx, char *name, struct hlsl_ir_function
     {
         func = RB_ENTRY_VALUE(func_entry, struct hlsl_ir_function, entry);
         decl->func = func;
-
-        if (rb_put(&func->overloads, &decl->parameters, &decl->entry) == -1)
-            ERR("Failed to insert function overload.\n");
+        list_add_tail(&func->overloads, &decl->entry);
         vkd3d_free(name);
         return;
     }
     func = hlsl_alloc(ctx, sizeof(*func));
     func->name = name;
-    rb_init(&func->overloads, compare_function_decl_rb);
+    list_init(&func->overloads);
     decl->func = func;
-    rb_put(&func->overloads, &decl->parameters, &decl->entry);
+    list_add_tail(&func->overloads, &decl->entry);
     rb_put(&ctx->functions, func->name, &func->entry);
 }
 
@@ -3092,7 +3219,7 @@ unsigned int hlsl_combine_swizzles(unsigned int first, unsigned int second, unsi
     return ret;
 }
 
-static const struct hlsl_profile_info *get_target_info(const char *target)
+const struct hlsl_profile_info *hlsl_get_target_info(const char *target)
 {
     unsigned int i;
 
@@ -3395,6 +3522,10 @@ static bool hlsl_ctx_init(struct hlsl_ctx *ctx, const struct vkd3d_shader_compil
             else if (option->value == VKD3D_SHADER_COMPILE_OPTION_PACK_MATRIX_COLUMN_MAJOR)
                 ctx->matrix_majority = HLSL_MODIFIER_COLUMN_MAJOR;
         }
+        else if (option->name == VKD3D_SHADER_COMPILE_OPTION_BACKWARD_COMPATIBILITY)
+        {
+            ctx->semantic_compat_mapping = option->value & VKD3D_SHADER_COMPILE_OPTION_BACKCOMPAT_MAP_SEMANTIC_NAMES;
+        }
     }
 
     return true;
@@ -3455,14 +3586,12 @@ int hlsl_compile_shader(const struct vkd3d_shader_code *hlsl, const struct vkd3d
     }
     entry_point = hlsl_source_info->entry_point ? hlsl_source_info->entry_point : "main";
 
-    if (!(profile = get_target_info(hlsl_source_info->profile)))
+    if (!(profile = hlsl_get_target_info(hlsl_source_info->profile)))
     {
         FIXME("Unknown compilation target %s.\n", debugstr_a(hlsl_source_info->profile));
         return VKD3D_ERROR_NOT_IMPLEMENTED;
     }
 
-    vkd3d_shader_dump_shader(compile_info->source_type, profile->type, &compile_info->source);
-
     if (compile_info->target_type == VKD3D_SHADER_TARGET_D3D_BYTECODE && profile->major_version > 3)
     {
         vkd3d_shader_error(message_context, NULL, VKD3D_SHADER_ERROR_HLSL_INCOMPATIBLE_PROFILE,
@@ -3501,7 +3630,7 @@ int hlsl_compile_shader(const struct vkd3d_shader_code *hlsl, const struct vkd3d
 
     if ((func = hlsl_get_function(&ctx, entry_point)))
     {
-        RB_FOR_EACH_ENTRY(decl, &func->overloads, struct hlsl_ir_function_decl, entry)
+        LIST_FOR_EACH_ENTRY(decl, &func->overloads, struct hlsl_ir_function_decl, entry)
         {
             if (!decl->has_body)
                 continue;
@@ -3567,7 +3696,7 @@ struct hlsl_ir_function_decl *hlsl_compile_internal_function(struct hlsl_ctx *ct
         hlsl_release_string_buffer(ctx, internal_name);
         return NULL;
     }
-    func = hlsl_get_func_decl(ctx, internal_name->buffer);
+    func = hlsl_get_first_func_decl(ctx, internal_name->buffer);
     hlsl_release_string_buffer(ctx, internal_name);
     return func;
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index 743a746f2bf..a0065572539 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -21,13 +21,10 @@
 #define __VKD3D_SHADER_HLSL_H
 
 #include "vkd3d_shader_private.h"
-#include "wine/rbtree.h"
+#include "rbtree.h"
 #include "d3dcommon.h"
 #include "d3dx9shader.h"
 
-enum vkd3d_sm4_register_type;
-enum vkd3d_sm4_swizzle_type;
-
 /* The general IR structure is inspired by Mesa GLSL hir, even though the code
  * ends up being quite different in practice. Anyway, here comes the relevant
  * licensing information.
@@ -284,6 +281,7 @@ enum hlsl_ir_node_type
     HLSL_IR_RESOURCE_STORE,
     HLSL_IR_STORE,
     HLSL_IR_SWIZZLE,
+    HLSL_IR_SWITCH,
 };
 
 /* Common data for every type of IR instruction node. */
@@ -357,11 +355,16 @@ struct hlsl_attribute
 #define HLSL_STORAGE_IN              0x00000800
 #define HLSL_STORAGE_OUT             0x00001000
 #define HLSL_MODIFIER_INLINE         0x00002000
+#define HLSL_STORAGE_CENTROID        0x00004000
+#define HLSL_STORAGE_NOPERSPECTIVE   0x00008000
 
 #define HLSL_TYPE_MODIFIERS_MASK     (HLSL_MODIFIER_PRECISE | HLSL_MODIFIER_VOLATILE | \
                                       HLSL_MODIFIER_CONST | HLSL_MODIFIER_ROW_MAJOR | \
                                       HLSL_MODIFIER_COLUMN_MAJOR)
 
+#define HLSL_INTERPOLATION_MODIFIERS_MASK (HLSL_STORAGE_NOINTERPOLATION | HLSL_STORAGE_CENTROID | \
+                                           HLSL_STORAGE_NOPERSPECTIVE)
+
 #define HLSL_MODIFIERS_MAJORITY_MASK (HLSL_MODIFIER_ROW_MAJOR | HLSL_MODIFIER_COLUMN_MAJOR)
 
 #define HLSL_ARRAY_ELEMENTS_COUNT_IMPLICIT 0
@@ -369,7 +372,7 @@ struct hlsl_attribute
 /* Reservation of a register and/or an offset for objects inside constant buffers, to be used as a
  *   starting point of their allocation. They are available through the register(·) and the
  *   packoffset(·) syntaxes, respectivelly.
- * The costant buffer offset is measured register components. */
+ * The constant buffer offset is measured register components. */
 struct hlsl_reg_reservation
 {
     char reg_type;
@@ -422,6 +425,9 @@ struct hlsl_ir_var
      * It may be less than the allocation size, e.g. for texture arrays. */
     unsigned int bind_count[HLSL_REGSET_LAST_OBJECT + 1];
 
+    /* Whether the shader performs dereferences with non-constant offsets in the variable. */
+    bool indexable;
+
     uint32_t is_input_semantic : 1;
     uint32_t is_output_semantic : 1;
     uint32_t is_uniform : 1;
@@ -444,7 +450,7 @@ struct hlsl_ir_function
     const char *name;
     /* Tree containing function definitions, stored as hlsl_ir_function_decl structures, which would
      *   be more than one in case of function overloading. */
-    struct rb_tree overloads;
+    struct list overloads;
 };
 
 struct hlsl_ir_function_decl
@@ -454,8 +460,8 @@ struct hlsl_ir_function_decl
     struct hlsl_ir_var *return_var;
 
     struct vkd3d_shader_location loc;
-    /* Item entry in hlsl_ir_function.overloads. The parameters' types are used as key. */
-    struct rb_entry entry;
+    /* Item entry in hlsl_ir_function.overloads. */
+    struct list entry;
 
     /* Function to which this declaration corresponds. */
     struct hlsl_ir_function *func;
@@ -497,6 +503,22 @@ struct hlsl_ir_loop
     unsigned int next_index; /* liveness index of the end of the loop */
 };
 
+struct hlsl_ir_switch_case
+{
+    unsigned int value;
+    bool is_default;
+    struct hlsl_block body;
+    struct list entry;
+    struct vkd3d_shader_location loc;
+};
+
+struct hlsl_ir_switch
+{
+    struct hlsl_ir_node node;
+    struct hlsl_src selector;
+    struct list cases;
+};
+
 enum hlsl_ir_expr_op
 {
     HLSL_OP0_VOID,
@@ -504,6 +526,7 @@ enum hlsl_ir_expr_op
     HLSL_OP1_ABS,
     HLSL_OP1_BIT_NOT,
     HLSL_OP1_CAST,
+    HLSL_OP1_CEIL,
     HLSL_OP1_COS,
     HLSL_OP1_COS_REDUCED,    /* Reduced range [-pi, pi] */
     HLSL_OP1_DSX,
@@ -556,7 +579,10 @@ enum hlsl_ir_expr_op
     /* MOVC(a, b, c) returns c if a is bitwise zero and b otherwise.
      * TERNARY(a, b, c) returns c if a == 0 and b otherwise.
      * They differ for floating point numbers, because
-     * -0.0 == 0.0, but it is not bitwise zero. */
+     * -0.0 == 0.0, but it is not bitwise zero. CMP(a, b, c) returns b
+       if a >= 0, and c otherwise. It's used only for SM1-SM3 targets, while
+       SM4+ is using MOVC in such cases. */
+    HLSL_OP3_CMP,
     HLSL_OP3_MOVC,
     HLSL_OP3_TERNARY,
 };
@@ -577,6 +603,10 @@ enum hlsl_ir_jump_type
     HLSL_IR_JUMP_DISCARD_NEG,
     HLSL_IR_JUMP_DISCARD_NZ,
     HLSL_IR_JUMP_RETURN,
+    /* UNRESOLVED_CONTINUE type is used by the parser when 'continue' statement is found,
+       it never reaches code generation, and is resolved to CONTINUE type once iteration
+       and loop exit logic was properly applied. */
+    HLSL_IR_JUMP_UNRESOLVED_CONTINUE,
 };
 
 struct hlsl_ir_jump
@@ -615,17 +645,25 @@ struct hlsl_deref
     unsigned int path_len;
     struct hlsl_src *path;
 
-    /* Single instruction node of data type uint used to represent the register offset (in register
-     *   components, within the pertaining regset), from the start of the variable, of the part
-     *   referenced.
-     * The path is lowered to this single offset -- whose value may vary between SM1 and SM4 --
-     *   before writing the bytecode.
+    /* Before writing the bytecode, deref paths are lowered into an offset (within the pertaining
+     *   regset) from the start of the variable, to the part of the variable that is referenced.
+     * This offset is stored using two fields, one for a variable part and other for a constant
+     *   part, which are added together:
+     *   - rel_offset: An offset given by an instruction node, in whole registers.
+     *   - const_offset: A constant number of register components.
      * Since the type information cannot longer be retrieved from the offset alone, the type is
-     *   stored in the data_type field. */
-    struct hlsl_src offset;
+     *   stored in the data_type field, which remains NULL if the deref hasn't been lowered yet. */
+    struct hlsl_src rel_offset;
+    unsigned int const_offset;
     struct hlsl_type *data_type;
 };
 
+/* Whether the path has been lowered to an offset or not. */
+static inline bool hlsl_deref_is_lowered(const struct hlsl_deref *deref)
+{
+    return !!deref->data_type;
+}
+
 struct hlsl_ir_load
 {
     struct hlsl_ir_node node;
@@ -641,6 +679,7 @@ enum hlsl_resource_load_type
     HLSL_RESOURCE_SAMPLE_LOD,
     HLSL_RESOURCE_SAMPLE_LOD_BIAS,
     HLSL_RESOURCE_SAMPLE_GRAD,
+    HLSL_RESOURCE_SAMPLE_PROJ,
     HLSL_RESOURCE_GATHER_RED,
     HLSL_RESOURCE_GATHER_GREEN,
     HLSL_RESOURCE_GATHER_BLUE,
@@ -702,6 +741,10 @@ struct hlsl_scope
     struct rb_tree types;
     /* Scope containing this scope. This value is NULL for the global scope. */
     struct hlsl_scope *upper;
+    /* The scope was created for the loop statement. */
+    bool loop;
+    /* The scope was created for the switch statement. */
+    bool _switch;
 };
 
 struct hlsl_profile_info
@@ -854,13 +897,8 @@ struct hlsl_ctx
     uint32_t in_state_block : 1;
     /* Whether the numthreads() attribute has been provided in the entry-point function. */
     uint32_t found_numthreads : 1;
-};
 
-enum hlsl_error_level
-{
-    HLSL_LEVEL_ERROR = 0,
-    HLSL_LEVEL_WARNING,
-    HLSL_LEVEL_NOTE,
+    bool semantic_compat_mapping;
 };
 
 struct hlsl_resource_load_params
@@ -944,6 +982,12 @@ static inline struct hlsl_ir_index *hlsl_ir_index(const struct hlsl_ir_node *nod
     return CONTAINING_RECORD(node, struct hlsl_ir_index, node);
 }
 
+static inline struct hlsl_ir_switch *hlsl_ir_switch(const struct hlsl_ir_node *node)
+{
+    assert(node->type == HLSL_IR_SWITCH);
+    return CONTAINING_RECORD(node, struct hlsl_ir_switch, node);
+}
+
 static inline void hlsl_block_init(struct hlsl_block *block)
 {
     list_init(&block->instrs);
@@ -1061,6 +1105,11 @@ static inline struct hlsl_type *hlsl_get_numeric_type(const struct hlsl_ctx *ctx
         return hlsl_get_matrix_type(ctx, base_type, dimx, dimy);
 }
 
+static inline bool hlsl_is_numeric_type(const struct hlsl_type *type)
+{
+    return type->class <= HLSL_CLASS_LAST_NUMERIC;
+}
+
 static inline unsigned int hlsl_sampler_dim_count(enum hlsl_sampler_dim dim)
 {
     switch (dim)
@@ -1117,6 +1166,9 @@ bool hlsl_copy_deref(struct hlsl_ctx *ctx, struct hlsl_deref *deref, const struc
 void hlsl_cleanup_deref(struct hlsl_deref *deref);
 void hlsl_cleanup_semantic(struct hlsl_semantic *semantic);
 
+void hlsl_cleanup_ir_switch_cases(struct list *cases);
+void hlsl_free_ir_switch_case(struct hlsl_ir_switch_case *c);
+
 void hlsl_replace_node(struct hlsl_ir_node *old, struct hlsl_ir_node *new);
 
 void hlsl_free_attribute(struct hlsl_attribute *attr);
@@ -1126,7 +1178,10 @@ void hlsl_free_type(struct hlsl_type *type);
 void hlsl_free_var(struct hlsl_ir_var *decl);
 
 struct hlsl_ir_function *hlsl_get_function(struct hlsl_ctx *ctx, const char *name);
-struct hlsl_ir_function_decl *hlsl_get_func_decl(struct hlsl_ctx *ctx, const char *name);
+struct hlsl_ir_function_decl *hlsl_get_first_func_decl(struct hlsl_ctx *ctx, const char *name);
+struct hlsl_ir_function_decl *hlsl_get_func_decl(struct hlsl_ctx *ctx, const char *name,
+        const struct hlsl_func_parameters *parameters);
+const struct hlsl_profile_info *hlsl_get_target_info(const char *target);
 struct hlsl_type *hlsl_get_type(struct hlsl_scope *scope, const char *name, bool recursive, bool case_insensitive);
 struct hlsl_ir_var *hlsl_get_var(struct hlsl_scope *scope, const char *name);
 
@@ -1210,6 +1265,10 @@ struct hlsl_ir_node *hlsl_new_unary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr
 struct hlsl_ir_var *hlsl_new_var(struct hlsl_ctx *ctx, const char *name, struct hlsl_type *type,
         const struct vkd3d_shader_location *loc, const struct hlsl_semantic *semantic, unsigned int modifiers,
         const struct hlsl_reg_reservation *reg_reservation);
+struct hlsl_ir_switch_case *hlsl_new_switch_case(struct hlsl_ctx *ctx, unsigned int value, bool is_default,
+        struct hlsl_block *body, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_new_switch(struct hlsl_ctx *ctx, struct hlsl_ir_node *selector,
+        struct list *cases, const struct vkd3d_shader_location *loc);
 
 void hlsl_error(struct hlsl_ctx *ctx, const struct vkd3d_shader_location *loc,
         enum vkd3d_shader_error error, const char *fmt, ...) VKD3D_PRINTF_FUNC(4, 5);
@@ -1232,13 +1291,12 @@ unsigned int hlsl_type_get_array_element_reg_size(const struct hlsl_type *type,
 struct hlsl_type *hlsl_type_get_component_type(struct hlsl_ctx *ctx, struct hlsl_type *type,
         unsigned int index);
 unsigned int hlsl_type_get_component_offset(struct hlsl_ctx *ctx, struct hlsl_type *type,
-        enum hlsl_regset regset, unsigned int index);
+        unsigned int index, enum hlsl_regset *regset);
 bool hlsl_type_is_row_major(const struct hlsl_type *type);
 unsigned int hlsl_type_minor_size(const struct hlsl_type *type);
 unsigned int hlsl_type_major_size(const struct hlsl_type *type);
 unsigned int hlsl_type_element_count(const struct hlsl_type *type);
 bool hlsl_type_is_resource(const struct hlsl_type *type);
-enum hlsl_regset hlsl_type_get_regset(const struct hlsl_type *type);
 unsigned int hlsl_type_get_sm4_offset(const struct hlsl_type *type, unsigned int offset);
 bool hlsl_types_are_equal(const struct hlsl_type *t1, const struct hlsl_type *t2);
 
@@ -1251,6 +1309,7 @@ unsigned int hlsl_map_swizzle(unsigned int swizzle, unsigned int writemask);
 unsigned int hlsl_swizzle_from_writemask(unsigned int writemask);
 
 struct hlsl_type *hlsl_deref_get_type(struct hlsl_ctx *ctx, const struct hlsl_deref *deref);
+enum hlsl_regset hlsl_deref_get_regset(struct hlsl_ctx *ctx, const struct hlsl_deref *deref);
 bool hlsl_component_index_range_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref *deref,
         unsigned int *start, unsigned int *count);
 bool hlsl_regset_index_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref *deref,
@@ -1273,7 +1332,7 @@ int hlsl_sm1_write(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_fun
 bool hlsl_sm4_usage_from_semantic(struct hlsl_ctx *ctx,
         const struct hlsl_semantic *semantic, bool output, D3D_NAME *usage);
 bool hlsl_sm4_register_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_semantic *semantic,
-        bool output, enum vkd3d_shader_register_type *type, enum vkd3d_sm4_swizzle_type *swizzle_type, bool *has_idx);
+        bool output, enum vkd3d_shader_register_type *type, bool *has_idx);
 int hlsl_sm4_write(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func, struct vkd3d_shader_code *out);
 
 struct hlsl_ir_function_decl *hlsl_compile_internal_function(struct hlsl_ctx *ctx, const char *name, const char *hlsl);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.l b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
index e9ae3ccf3d3..401fba60422 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.l
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
@@ -46,14 +46,13 @@ static void update_location(struct hlsl_ctx *ctx, YYLTYPE *loc);
 
 %x pp pp_line pp_pragma pp_ignore
 
-RESERVED1               auto|case|catch|char|class|const_cast|default|delete|dynamic_cast|enum
+RESERVED1               auto|catch|char|class|const_cast|delete|dynamic_cast|enum
 RESERVED2               explicit|friend|goto|long|mutable|new|operator|private|protected|public
 RESERVED3               reinterpret_cast|short|signed|sizeof|static_cast|template|this|throw|try
 RESERVED4               typename|union|unsigned|using|virtual
 
 WS                      [ \t]
 NEWLINE                 (\n)|(\r\n)
-DOUBLESLASHCOMMENT      "//"[^\n]*
 STRING                  \"[^\"]*\"
 IDENTIFIER              [A-Za-z_][A-Za-z0-9_]*
 
@@ -73,12 +72,16 @@ ANY                     (.)
 BlendState              {return KW_BLENDSTATE;          }
 break                   {return KW_BREAK;               }
 Buffer                  {return KW_BUFFER;              }
+case                    {return KW_CASE;                }
 cbuffer                 {return KW_CBUFFER;             }
+centroid                {return KW_CENTROID;            }
+column_major            {return KW_COLUMN_MAJOR;        }
 compile                 {return KW_COMPILE;             }
 const                   {return KW_CONST;               }
 continue                {return KW_CONTINUE;            }
 DepthStencilState       {return KW_DEPTHSTENCILSTATE;   }
 DepthStencilView        {return KW_DEPTHSTENCILVIEW;    }
+default                 {return KW_DEFAULT;             }
 discard                 {return KW_DISCARD;             }
 do                      {return KW_DO;                  }
 double                  {return KW_DOUBLE;              }
@@ -95,28 +98,32 @@ inout                   {return KW_INOUT;               }
 matrix                  {return KW_MATRIX;              }
 namespace               {return KW_NAMESPACE;           }
 nointerpolation         {return KW_NOINTERPOLATION;     }
+noperspective           {return KW_NOPERSPECTIVE;       }
 out                     {return KW_OUT;                 }
 packoffset              {return KW_PACKOFFSET;          }
 pass                    {return KW_PASS;                }
 PixelShader             {return KW_PIXELSHADER;         }
 precise                 {return KW_PRECISE;             }
 RasterizerState         {return KW_RASTERIZERSTATE;     }
+register                {return KW_REGISTER;            }
 RenderTargetView        {return KW_RENDERTARGETVIEW;    }
 return                  {return KW_RETURN;              }
-register                {return KW_REGISTER;            }
+row_major               {return KW_ROW_MAJOR;           }
 RWBuffer                {return KW_RWBUFFER;            }
 RWStructuredBuffer      {return KW_RWSTRUCTUREDBUFFER;  }
 RWTexture1D             {return KW_RWTEXTURE1D;         }
+RWTexture1DArray        {return KW_RWTEXTURE1DARRAY;    }
 RWTexture2D             {return KW_RWTEXTURE2D;         }
+RWTexture2DArray        {return KW_RWTEXTURE2DARRAY;    }
 RWTexture3D             {return KW_RWTEXTURE3D;         }
 sampler                 {return KW_SAMPLER;             }
 sampler1D               {return KW_SAMPLER1D;           }
 sampler2D               {return KW_SAMPLER2D;           }
 sampler3D               {return KW_SAMPLER3D;           }
-samplerCUBE             {return KW_SAMPLERCUBE;         }
-sampler_state           {return KW_SAMPLER_STATE;       }
 SamplerComparisonState  {return KW_SAMPLERCOMPARISONSTATE;}
+samplerCUBE             {return KW_SAMPLERCUBE;         }
 SamplerState            {return KW_SAMPLER;             }
+sampler_state           {return KW_SAMPLER_STATE;       }
 shared                  {return KW_SHARED;              }
 stateblock              {return KW_STATEBLOCK;          }
 stateblock_state        {return KW_STATEBLOCK_STATE;    }
@@ -125,21 +132,22 @@ string                  {return KW_STRING;              }
 struct                  {return KW_STRUCT;              }
 switch                  {return KW_SWITCH;              }
 tbuffer                 {return KW_TBUFFER;             }
-technique               {return KW_TECHNIQUE;           }
+(?i:technique)          {return KW_TECHNIQUE;           }
 technique10             {return KW_TECHNIQUE10;         }
+technique11             {return KW_TECHNIQUE11;         }
 texture                 {return KW_TEXTURE;             }
-texture1D               {return KW_TEXTURE1D;           }
 Texture1D               {return KW_TEXTURE1D;           }
+texture1D               {return KW_TEXTURE1D;           }
 Texture1DArray          {return KW_TEXTURE1DARRAY;      }
-texture2D               {return KW_TEXTURE2D;           }
 Texture2D               {return KW_TEXTURE2D;           }
+texture2D               {return KW_TEXTURE2D;           }
 Texture2DArray          {return KW_TEXTURE2DARRAY;      }
 Texture2DMS             {return KW_TEXTURE2DMS;         }
 Texture2DMSArray        {return KW_TEXTURE2DMSARRAY;    }
-texture3D               {return KW_TEXTURE3D;           }
 Texture3D               {return KW_TEXTURE3D;           }
-textureCUBE             {return KW_TEXTURECUBE;         }
+texture3D               {return KW_TEXTURE3D;           }
 TextureCube             {return KW_TEXTURECUBE;         }
+textureCUBE             {return KW_TEXTURECUBE;         }
 TextureCubeArray        {return KW_TEXTURECUBEARRAY;    }
 true                    {return KW_TRUE;                }
 typedef                 {return KW_TYPEDEF;             }
@@ -159,7 +167,6 @@ while                   {return KW_WHILE;               }
 \<\<=                   {return OP_LEFTSHIFTASSIGN;     }
 \>\>                    {return OP_RIGHTSHIFT;          }
 \>\>=                   {return OP_RIGHTSHIFTASSIGN;    }
-\.\.\.                  {return OP_ELLIPSIS;            }
 \<=                     {return OP_LE;                  }
 \>=                     {return OP_GE;                  }
 !=                      {return OP_NE;                  }
@@ -171,13 +178,6 @@ while                   {return KW_WHILE;               }
 &=                      {return OP_ANDASSIGN;           }
 \|=                     {return OP_ORASSIGN;            }
 ^=                      {return OP_XORASSIGN;           }
-##                      {return OP_UNKNOWN1;            }
-#@                      {return OP_UNKNOWN2;            }
-::                      {return OP_UNKNOWN3;            }
-\-\>                    {return OP_UNKNOWN4;            }
-
-column_major            {return KW_COLUMN_MAJOR;        }
-row_major               {return KW_ROW_MAJOR;           }
 
 {IDENTIFIER}            {
                             struct hlsl_ctx *ctx = yyget_extra(yyscanner);
@@ -203,20 +203,30 @@ row_major               {return KW_ROW_MAJOR;           }
                             yylval->floatval = atof(yytext);
                             return C_FLOAT;
                         }
-0x[0-9a-fA-F]+          {
+0x[0-9a-fA-F]+[lL]?     {
                             yylval->intval = vkd3d_parse_integer(yytext);
                             return C_INTEGER;
                         }
-0[0-7]+                 {
+0[0-7]+[lL]?            {
                             yylval->intval = vkd3d_parse_integer(yytext);
                             return C_INTEGER;
                         }
-[0-9]+                  {
+[0-9]+[lL]?             {
                             yylval->intval = vkd3d_parse_integer(yytext);
                             return C_INTEGER;
                         }
-
-{DOUBLESLASHCOMMENT}    {}
+0x[0-9a-fA-F]+([uU]|[uU][lL]|[lL][uU]) {
+                            yylval->intval = vkd3d_parse_integer(yytext);
+                            return C_UNSIGNED;
+                        }
+0[0-7]+([uU]|[uU][lL]|[lL][uU]) {
+                            yylval->intval = vkd3d_parse_integer(yytext);
+                            return C_UNSIGNED;
+                        }
+[0-9]+([uU]|[uU][lL]|[lL][uU]) {
+                            yylval->intval = vkd3d_parse_integer(yytext);
+                            return C_UNSIGNED;
+                        }
 
 {WS}+                   {}
 {NEWLINE}               {
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index fb6d485ea69..67b01293683 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -162,6 +162,12 @@ static void destroy_block(struct hlsl_block *block)
     vkd3d_free(block);
 }
 
+static void destroy_switch_cases(struct list *cases)
+{
+    hlsl_cleanup_ir_switch_cases(cases);
+    vkd3d_free(cases);
+}
+
 static bool hlsl_types_are_componentwise_compatible(struct hlsl_ctx *ctx, struct hlsl_type *src,
         struct hlsl_type *dst)
 {
@@ -205,7 +211,7 @@ static bool hlsl_types_are_componentwise_equal(struct hlsl_ctx *ctx, struct hlsl
     return true;
 }
 
-static bool type_contains_only_numerics(struct hlsl_type *type)
+static bool type_contains_only_numerics(const struct hlsl_type *type)
 {
     unsigned int i;
 
@@ -220,12 +226,12 @@ static bool type_contains_only_numerics(struct hlsl_type *type)
         }
         return true;
     }
-    return type->class <= HLSL_CLASS_LAST_NUMERIC;
+    return hlsl_is_numeric_type(type);
 }
 
 static bool explicit_compatible_data_types(struct hlsl_ctx *ctx, struct hlsl_type *src, struct hlsl_type *dst)
 {
-    if (src->class <= HLSL_CLASS_LAST_NUMERIC && src->dimx == 1 && src->dimy == 1 && type_contains_only_numerics(dst))
+    if (hlsl_is_numeric_type(src) && src->dimx == 1 && src->dimy == 1 && type_contains_only_numerics(dst))
         return true;
 
     if (src->class == HLSL_CLASS_MATRIX && dst->class == HLSL_CLASS_MATRIX
@@ -245,10 +251,10 @@ static bool explicit_compatible_data_types(struct hlsl_ctx *ctx, struct hlsl_typ
 
 static bool implicit_compatible_data_types(struct hlsl_ctx *ctx, struct hlsl_type *src, struct hlsl_type *dst)
 {
-    if ((src->class <= HLSL_CLASS_LAST_NUMERIC) != (dst->class <= HLSL_CLASS_LAST_NUMERIC))
+    if (hlsl_is_numeric_type(src) != hlsl_is_numeric_type(dst))
         return false;
 
-    if (src->class <= HLSL_CLASS_LAST_NUMERIC)
+    if (hlsl_is_numeric_type(src))
     {
         /* Scalar vars can be converted to any other numeric data type */
         if (src->dimx == 1 && src->dimy == 1)
@@ -305,7 +311,7 @@ static struct hlsl_ir_node *add_cast(struct hlsl_ctx *ctx, struct hlsl_block *bl
         struct hlsl_ir_var *var;
         unsigned int dst_idx;
 
-        broadcast = src_type->class <= HLSL_CLASS_LAST_NUMERIC && src_type->dimx == 1 && src_type->dimy == 1;
+        broadcast = hlsl_is_numeric_type(src_type) && src_type->dimx == 1 && src_type->dimy == 1;
         matrix_cast = !broadcast && dst_comp_count != src_comp_count
                 && src_type->class == HLSL_CLASS_MATRIX && dst_type->class == HLSL_CLASS_MATRIX;
         assert(src_comp_count >= dst_comp_count || broadcast);
@@ -464,6 +470,72 @@ static bool attribute_list_has_duplicates(const struct parse_attribute_list *att
     return false;
 }
 
+static void resolve_loop_continue(struct hlsl_ctx *ctx, struct hlsl_block *block, enum loop_type type,
+        struct hlsl_block *cond, struct hlsl_block *iter)
+{
+    struct hlsl_ir_node *instr, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE(instr, next, &block->instrs, struct hlsl_ir_node, entry)
+    {
+        if (instr->type == HLSL_IR_IF)
+        {
+            struct hlsl_ir_if *iff = hlsl_ir_if(instr);
+
+            resolve_loop_continue(ctx, &iff->then_block, type, cond, iter);
+            resolve_loop_continue(ctx, &iff->else_block, type, cond, iter);
+        }
+        else if (instr->type == HLSL_IR_JUMP)
+        {
+            struct hlsl_ir_jump *jump = hlsl_ir_jump(instr);
+            struct hlsl_block block;
+
+            if (jump->type != HLSL_IR_JUMP_UNRESOLVED_CONTINUE)
+                continue;
+
+            if (type == LOOP_DO_WHILE)
+            {
+                if (!hlsl_clone_block(ctx, &block, cond))
+                    return;
+                if (!append_conditional_break(ctx, &block))
+                {
+                    hlsl_block_cleanup(&block);
+                    return;
+                }
+                list_move_before(&instr->entry, &block.instrs);
+            }
+            else if (type == LOOP_FOR)
+            {
+                if (!hlsl_clone_block(ctx, &block, iter))
+                    return;
+                list_move_before(&instr->entry, &block.instrs);
+            }
+            jump->type = HLSL_IR_JUMP_CONTINUE;
+        }
+    }
+}
+
+static void check_loop_attributes(struct hlsl_ctx *ctx, const struct parse_attribute_list *attributes,
+        const struct vkd3d_shader_location *loc)
+{
+    bool has_unroll = false, has_loop = false, has_fastopt = false;
+    unsigned int i;
+
+    for (i = 0; i < attributes->count; ++i)
+    {
+        const char *name = attributes->attrs[i]->name;
+
+        has_loop |= !strcmp(name, "loop");
+        has_unroll |= !strcmp(name, "unroll");
+        has_fastopt |= !strcmp(name, "fastopt");
+    }
+
+    if (has_unroll && has_loop)
+        hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX, "Unroll attribute can't be used with 'loop' attribute.");
+
+    if (has_unroll && has_fastopt)
+        hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX, "Unroll attribute can't be used with 'fastopt' attribute.");
+}
+
 static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum loop_type type,
         const struct parse_attribute_list *attributes, struct hlsl_block *init, struct hlsl_block *cond,
         struct hlsl_block *iter, struct hlsl_block *body, const struct vkd3d_shader_location *loc)
@@ -474,6 +546,8 @@ static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum loop_type type,
     if (attribute_list_has_duplicates(attributes))
         hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX, "Found duplicate attribute.");
 
+    check_loop_attributes(ctx, attributes, loc);
+
     /* Ignore unroll(0) attribute, and any invalid attribute. */
     for (i = 0; i < attributes->count; ++i)
     {
@@ -489,8 +563,11 @@ static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum loop_type type,
                 hlsl_warning(ctx, loc, VKD3D_SHADER_ERROR_HLSL_NOT_IMPLEMENTED, "Loop unrolling is not implemented.");
             }
         }
-        else if (!strcmp(attr->name, "loop")
-                || !strcmp(attr->name, "fastopt")
+        else if (!strcmp(attr->name, "loop"))
+        {
+            /* TODO: this attribute will be used to disable unrolling, once it's implememented. */
+        }
+        else if (!strcmp(attr->name, "fastopt")
                 || !strcmp(attr->name, "allow_uav_condition"))
         {
             hlsl_fixme(ctx, loc, "Unhandled attribute '%s'.", attr->name);
@@ -501,6 +578,8 @@ static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum loop_type type,
         }
     }
 
+    resolve_loop_continue(ctx, body, type, cond, iter);
+
     if (!init && !(init = make_empty_block(ctx)))
         goto oom;
 
@@ -1079,22 +1158,6 @@ static struct hlsl_reg_reservation parse_packoffset(struct hlsl_ctx *ctx, const
     return reservation;
 }
 
-static struct hlsl_ir_function_decl *get_func_decl(struct rb_tree *funcs,
-        const char *name, const struct hlsl_func_parameters *parameters)
-{
-    struct hlsl_ir_function *func;
-    struct rb_entry *entry;
-
-    if ((entry = rb_get(funcs, name)))
-    {
-        func = RB_ENTRY_VALUE(entry, struct hlsl_ir_function, entry);
-
-        if ((entry = rb_get(&func->overloads, parameters)))
-            return RB_ENTRY_VALUE(entry, struct hlsl_ir_function_decl, entry);
-    }
-    return NULL;
-}
-
 static struct hlsl_block *make_block(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr)
 {
     struct hlsl_block *block;
@@ -1134,6 +1197,7 @@ static unsigned int evaluate_static_expression_as_uint(struct hlsl_ctx *ctx, str
             case HLSL_IR_RESOURCE_LOAD:
             case HLSL_IR_RESOURCE_STORE:
             case HLSL_IR_STORE:
+            case HLSL_IR_SWITCH:
                 hlsl_error(ctx, &node->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
                         "Expected literal expression.");
         }
@@ -1228,7 +1292,7 @@ static enum hlsl_base_type expr_common_base_type(enum hlsl_base_type t1, enum hl
 static bool expr_common_shape(struct hlsl_ctx *ctx, struct hlsl_type *t1, struct hlsl_type *t2,
         const struct vkd3d_shader_location *loc, enum hlsl_type_class *type, unsigned int *dimx, unsigned int *dimy)
 {
-    if (t1->class > HLSL_CLASS_LAST_NUMERIC)
+    if (!hlsl_is_numeric_type(t1))
     {
         struct vkd3d_string_buffer *string;
 
@@ -1239,7 +1303,7 @@ static bool expr_common_shape(struct hlsl_ctx *ctx, struct hlsl_type *t1, struct
         return false;
     }
 
-    if (t2->class > HLSL_CLASS_LAST_NUMERIC)
+    if (!hlsl_is_numeric_type(t2))
     {
         struct vkd3d_string_buffer *string;
 
@@ -1711,7 +1775,7 @@ static struct hlsl_ir_node *add_assignment(struct hlsl_ctx *ctx, struct hlsl_blo
             return NULL;
     }
 
-    if (lhs_type->class <= HLSL_CLASS_LAST_NUMERIC)
+    if (hlsl_is_numeric_type(lhs_type))
         writemask = (1 << lhs_type->dimx) - 1;
 
     if (!(rhs = add_implicit_conversion(ctx, block, rhs, lhs_type, &rhs->loc)))
@@ -1941,7 +2005,7 @@ static bool type_has_object_components(struct hlsl_type *type, bool must_be_in_s
 
 static bool type_has_numeric_components(struct hlsl_type *type)
 {
-    if (type->class <= HLSL_CLASS_LAST_NUMERIC)
+    if (hlsl_is_numeric_type(type))
         return true;
     if (type->class == HLSL_CLASS_ARRAY)
         return type_has_numeric_components(type->e.array.type);
@@ -2106,7 +2170,7 @@ static void declare_var(struct hlsl_ctx *ctx, struct parse_variable_def *v)
                     "Target profile doesn't support objects as struct members in uniform variables.");
         }
 
-        if ((func = hlsl_get_func_decl(ctx, var->name)))
+        if ((func = hlsl_get_first_func_decl(ctx, var->name)))
         {
             hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_REDEFINED,
                     "'%s' is already defined as a function.", var->name);
@@ -2261,56 +2325,27 @@ static struct hlsl_block *initialize_vars(struct hlsl_ctx *ctx, struct list *var
     return initializers;
 }
 
-struct find_function_call_args
-{
-    struct hlsl_ctx *ctx;
-    const struct parse_initializer *params;
-    struct hlsl_ir_function_decl *decl;
-    unsigned int compatible_overloads_count;
-};
-
-static void find_function_call_exact(struct rb_entry *entry, void *context)
-{
-    struct hlsl_ir_function_decl *decl = RB_ENTRY_VALUE(entry, struct hlsl_ir_function_decl, entry);
-    struct find_function_call_args *args = context;
-    unsigned int i;
-
-    if (decl->parameters.count != args->params->args_count)
-        return;
-
-    for (i = 0; i < decl->parameters.count; ++i)
-    {
-        if (!hlsl_types_are_equal(decl->parameters.vars[i]->data_type, args->params->args[i]->data_type))
-            return;
-    }
-    args->decl = decl;
-}
-
-static void find_function_call_compatible(struct rb_entry *entry, void *context)
+static bool func_is_compatible_match(struct hlsl_ctx *ctx,
+        const struct hlsl_ir_function_decl *decl, const struct parse_initializer *args)
 {
-    struct hlsl_ir_function_decl *decl = RB_ENTRY_VALUE(entry, struct hlsl_ir_function_decl, entry);
-    struct find_function_call_args *args = context;
     unsigned int i;
 
-    if (decl->parameters.count != args->params->args_count)
-        return;
+    if (decl->parameters.count != args->args_count)
+        return false;
 
     for (i = 0; i < decl->parameters.count; ++i)
     {
-        if (!implicit_compatible_data_types(args->ctx, args->params->args[i]->data_type,
-                decl->parameters.vars[i]->data_type))
-            return;
+        if (!implicit_compatible_data_types(ctx, args->args[i]->data_type, decl->parameters.vars[i]->data_type))
+            return false;
     }
-
-    args->compatible_overloads_count++;
-    args->decl = decl;
+    return true;
 }
 
 static struct hlsl_ir_function_decl *find_function_call(struct hlsl_ctx *ctx,
-        const char *name, const struct parse_initializer *params,
+        const char *name, const struct parse_initializer *args,
         const struct vkd3d_shader_location *loc)
 {
-    struct find_function_call_args args = {.ctx = ctx, .params = params};
+    struct hlsl_ir_function_decl *decl, *compatible_match = NULL;
     struct hlsl_ir_function *func;
     struct rb_entry *entry;
 
@@ -2318,16 +2353,20 @@ static struct hlsl_ir_function_decl *find_function_call(struct hlsl_ctx *ctx,
         return NULL;
     func = RB_ENTRY_VALUE(entry, struct hlsl_ir_function, entry);
 
-    rb_for_each_entry(&func->overloads, find_function_call_exact, &args);
-    if (!args.decl)
+    LIST_FOR_EACH_ENTRY(decl, &func->overloads, struct hlsl_ir_function_decl, entry)
     {
-        rb_for_each_entry(&func->overloads, find_function_call_compatible, &args);
-        if (args.compatible_overloads_count > 1)
+        if (func_is_compatible_match(ctx, decl, args))
         {
-            hlsl_fixme(ctx, loc, "Prioritize between multiple compatible function overloads.");
+            if (compatible_match)
+            {
+                hlsl_fixme(ctx, loc, "Prioritize between multiple compatible function overloads.");
+                break;
+            }
+            compatible_match = decl;
         }
     }
-    return args.decl;
+
+    return compatible_match;
 }
 
 static struct hlsl_ir_node *hlsl_new_void_expr(struct hlsl_ctx *ctx, const struct vkd3d_shader_location *loc)
@@ -2669,6 +2708,17 @@ static bool intrinsic_asuint(struct hlsl_ctx *ctx,
     return add_expr(ctx, params->instrs, HLSL_OP1_REINTERPRET, operands, data_type, loc);
 }
 
+static bool intrinsic_ceil(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_node *arg;
+
+    if (!(arg = intrinsic_float_convert_arg(ctx, params, params->args[0], loc)))
+        return false;
+
+    return !!add_unary_arithmetic_expr(ctx, params->instrs, HLSL_OP1_CEIL, arg, loc);
+}
+
 static bool intrinsic_clamp(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
@@ -2828,6 +2878,22 @@ static bool intrinsic_ddy_coarse(struct hlsl_ctx *ctx,
     return !!add_unary_arithmetic_expr(ctx, params->instrs, HLSL_OP1_DSY_COARSE, arg, loc);
 }
 
+static bool intrinsic_degrees(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_node *arg, *deg;
+
+    if (!(arg = intrinsic_float_convert_arg(ctx, params, params->args[0], loc)))
+        return false;
+
+    /* 1 rad = 180/pi degree = 57.2957795 degree */
+    if (!(deg = hlsl_new_float_constant(ctx, 57.2957795f, loc)))
+        return false;
+    hlsl_block_add_instr(params->instrs, deg);
+
+    return !!add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, arg, deg, loc);
+}
+
 static bool intrinsic_ddy_fine(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
@@ -2961,6 +3027,33 @@ static bool intrinsic_frac(struct hlsl_ctx *ctx,
     return !!add_unary_arithmetic_expr(ctx, params->instrs, HLSL_OP1_FRACT, arg, loc);
 }
 
+static bool intrinsic_fwidth(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_function_decl *func;
+    struct hlsl_type *type;
+    char *body;
+
+    static const char template[] =
+            "%s fwidth(%s x)\n"
+            "{\n"
+            "    return abs(ddx(x)) + abs(ddy(x));\n"
+            "}";
+
+    if (!elementwise_intrinsic_float_convert_args(ctx, params, loc))
+        return false;
+    type = params->args[0]->data_type;
+
+    if (!(body = hlsl_sprintf_alloc(ctx, template, type->name, type->name)))
+        return false;
+    func = hlsl_compile_internal_function(ctx, "fwidth", body);
+    vkd3d_free(body);
+    if (!func)
+        return false;
+
+    return add_user_call(ctx, func, params, loc);
+}
+
 static bool intrinsic_ldexp(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
@@ -3078,6 +3171,7 @@ static bool intrinsic_log(struct hlsl_ctx *ctx,
     /* ln(2) */
     if (!(coeff = hlsl_new_float_constant(ctx, 0.69314718055f, loc)))
         return false;
+    hlsl_block_add_instr(params->instrs, coeff);
 
     return !!add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, log, coeff, loc);
 }
@@ -3096,6 +3190,7 @@ static bool intrinsic_log10(struct hlsl_ctx *ctx,
     /* 1 / log2(10) */
     if (!(coeff = hlsl_new_float_constant(ctx, 0.301029996f, loc)))
         return false;
+    hlsl_block_add_instr(params->instrs, coeff);
 
     return !!add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, log, coeff, loc);
 }
@@ -3264,6 +3359,22 @@ static bool intrinsic_pow(struct hlsl_ctx *ctx,
     return !!add_pow_expr(ctx, params->instrs, params->args[0], params->args[1], loc);
 }
 
+static bool intrinsic_radians(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_node *arg, *rad;
+
+    if (!(arg = intrinsic_float_convert_arg(ctx, params, params->args[0], loc)))
+        return false;
+
+    /* 1 degree = pi/180 rad = 0.0174532925f rad */
+    if (!(rad = hlsl_new_float_constant(ctx, 0.0174532925f, loc)))
+        return false;
+    hlsl_block_add_instr(params->instrs, rad);
+
+    return !!add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, arg, rad, loc);
+}
+
 static bool intrinsic_reflect(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
@@ -3423,10 +3534,24 @@ static bool intrinsic_step(struct hlsl_ctx *ctx,
     return !!add_implicit_conversion(ctx, params->instrs, ge, type, loc);
 }
 
+static bool intrinsic_tan(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_node *arg = params->args[0], *sin, *cos;
+
+    if (!(sin = add_unary_arithmetic_expr(ctx, params->instrs, HLSL_OP1_SIN, arg, loc)))
+        return false;
+
+    if (!(cos = add_unary_arithmetic_expr(ctx, params->instrs, HLSL_OP1_COS, arg, loc)))
+        return false;
+
+    return !!add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_DIV, sin, cos, loc);
+}
+
 static bool intrinsic_tex(struct hlsl_ctx *ctx, const struct parse_initializer *params,
         const struct vkd3d_shader_location *loc, const char *name, enum hlsl_sampler_dim dim)
 {
-    struct hlsl_resource_load_params load_params = {.type = HLSL_RESOURCE_SAMPLE};
+    struct hlsl_resource_load_params load_params = { 0 };
     const struct hlsl_type *sampler_type;
     struct hlsl_ir_node *coords, *load;
 
@@ -3455,10 +3580,74 @@ static bool intrinsic_tex(struct hlsl_ctx *ctx, const struct parse_initializer *
         hlsl_release_string_buffer(ctx, string);
     }
 
-    if (!(coords = add_implicit_conversion(ctx, params->instrs, params->args[1],
-            hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, hlsl_sampler_dim_count(dim)), loc)))
+    if (!strcmp(name, "tex2Dlod"))
     {
-        return false;
+        struct hlsl_ir_node *lod, *c;
+
+        load_params.type = HLSL_RESOURCE_SAMPLE_LOD;
+
+        if (!(c = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, Y, Z, W), hlsl_sampler_dim_count(dim), params->args[1], loc)))
+            return false;
+        hlsl_block_add_instr(params->instrs, c);
+
+        if (!(coords = add_implicit_conversion(ctx, params->instrs, c, hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT,
+                hlsl_sampler_dim_count(dim)), loc)))
+        {
+            return false;
+        }
+
+        if (!(lod = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(W, W, W, W), 1, params->args[1], loc)))
+            return false;
+        hlsl_block_add_instr(params->instrs, lod);
+
+        if (!(load_params.lod = add_implicit_conversion(ctx, params->instrs, lod,
+                hlsl_get_scalar_type(ctx, HLSL_TYPE_FLOAT), loc)))
+        {
+            return false;
+        }
+    }
+    else if (!strcmp(name, "tex2Dproj")
+            || !strcmp(name, "tex3Dproj")
+            || !strcmp(name, "texCUBEproj"))
+    {
+        if (!(coords = add_implicit_conversion(ctx, params->instrs, params->args[1],
+                hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, 4), loc)))
+        {
+            return false;
+        }
+
+        if (shader_profile_version_ge(ctx, 4, 0))
+        {
+            unsigned int count = hlsl_sampler_dim_count(dim);
+            struct hlsl_ir_node *divisor;
+
+            if (!(divisor = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(W, W, W, W), count, coords, loc)))
+                return false;
+            hlsl_block_add_instr(params->instrs, divisor);
+
+            if (!(coords = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, Y, Z, W), count, coords, loc)))
+                return false;
+            hlsl_block_add_instr(params->instrs, coords);
+
+            if (!(coords = add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_DIV, coords, divisor, loc)))
+                return false;
+
+            load_params.type = HLSL_RESOURCE_SAMPLE;
+        }
+        else
+        {
+            load_params.type = HLSL_RESOURCE_SAMPLE_PROJ;
+        }
+    }
+    else
+    {
+        load_params.type = HLSL_RESOURCE_SAMPLE;
+
+        if (!(coords = add_implicit_conversion(ctx, params->instrs, params->args[1],
+                hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, hlsl_sampler_dim_count(dim)), loc)))
+        {
+            return false;
+        }
     }
 
     /* tex1D() functions never produce 1D resource declarations. For newer profiles half offset
@@ -3517,18 +3706,42 @@ static bool intrinsic_tex2D(struct hlsl_ctx *ctx,
     return intrinsic_tex(ctx, params, loc, "tex2D", HLSL_SAMPLER_DIM_2D);
 }
 
+static bool intrinsic_tex2Dlod(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_tex(ctx, params, loc, "tex2Dlod", HLSL_SAMPLER_DIM_2D);
+}
+
+static bool intrinsic_tex2Dproj(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_tex(ctx, params, loc, "tex2Dproj", HLSL_SAMPLER_DIM_2D);
+}
+
 static bool intrinsic_tex3D(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
     return intrinsic_tex(ctx, params, loc, "tex3D", HLSL_SAMPLER_DIM_3D);
 }
 
+static bool intrinsic_tex3Dproj(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_tex(ctx, params, loc, "tex3Dproj", HLSL_SAMPLER_DIM_3D);
+}
+
 static bool intrinsic_texCUBE(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
     return intrinsic_tex(ctx, params, loc, "texCUBE", HLSL_SAMPLER_DIM_CUBE);
 }
 
+static bool intrinsic_texCUBEproj(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_tex(ctx, params, loc, "texCUBEproj", HLSL_SAMPLER_DIM_CUBE);
+}
+
 static bool intrinsic_transpose(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
@@ -3659,6 +3872,7 @@ intrinsic_functions[] =
     {"any",                                 1, true,  intrinsic_any},
     {"asfloat",                             1, true,  intrinsic_asfloat},
     {"asuint",                             -1, true,  intrinsic_asuint},
+    {"ceil",                                1, true,  intrinsic_ceil},
     {"clamp",                               3, true,  intrinsic_clamp},
     {"clip",                                1, true,  intrinsic_clip},
     {"cos",                                 1, true,  intrinsic_cos},
@@ -3669,6 +3883,7 @@ intrinsic_functions[] =
     {"ddy",                                 1, true,  intrinsic_ddy},
     {"ddy_coarse",                          1, true,  intrinsic_ddy_coarse},
     {"ddy_fine",                            1, true,  intrinsic_ddy_fine},
+    {"degrees",                             1, true,  intrinsic_degrees},
     {"distance",                            2, true,  intrinsic_distance},
     {"dot",                                 2, true,  intrinsic_dot},
     {"exp",                                 1, true,  intrinsic_exp},
@@ -3676,6 +3891,7 @@ intrinsic_functions[] =
     {"floor",                               1, true,  intrinsic_floor},
     {"fmod",                                2, true,  intrinsic_fmod},
     {"frac",                                1, true,  intrinsic_frac},
+    {"fwidth",                              1, true,  intrinsic_fwidth},
     {"ldexp",                               2, true,  intrinsic_ldexp},
     {"length",                              1, true,  intrinsic_length},
     {"lerp",                                3, true,  intrinsic_lerp},
@@ -3688,6 +3904,7 @@ intrinsic_functions[] =
     {"mul",                                 2, true,  intrinsic_mul},
     {"normalize",                           1, true,  intrinsic_normalize},
     {"pow",                                 2, true,  intrinsic_pow},
+    {"radians",                             1, true,  intrinsic_radians},
     {"reflect",                             2, true,  intrinsic_reflect},
     {"round",                               1, true,  intrinsic_round},
     {"rsqrt",                               1, true,  intrinsic_rsqrt},
@@ -3697,10 +3914,15 @@ intrinsic_functions[] =
     {"smoothstep",                          3, true,  intrinsic_smoothstep},
     {"sqrt",                                1, true,  intrinsic_sqrt},
     {"step",                                2, true,  intrinsic_step},
+    {"tan",                                 1, true,  intrinsic_tan},
     {"tex1D",                              -1, false, intrinsic_tex1D},
     {"tex2D",                              -1, false, intrinsic_tex2D},
+    {"tex2Dlod",                            2, false, intrinsic_tex2Dlod},
+    {"tex2Dproj",                           2, false, intrinsic_tex2Dproj},
     {"tex3D",                              -1, false, intrinsic_tex3D},
+    {"tex3Dproj",                           2, false, intrinsic_tex3Dproj},
     {"texCUBE",                            -1, false, intrinsic_texCUBE},
+    {"texCUBEproj",                         2, false, intrinsic_texCUBEproj},
     {"transpose",                           1, true,  intrinsic_transpose},
     {"trunc",                               1, true,  intrinsic_trunc},
 };
@@ -3740,7 +3962,7 @@ static struct hlsl_block *add_call(struct hlsl_ctx *ctx, const char *name,
 
             for (i = 0; i < args->args_count; ++i)
             {
-                if (args->args[i]->data_type->class > HLSL_CLASS_LAST_NUMERIC)
+                if (!hlsl_is_numeric_type(args->args[i]->data_type))
                 {
                     struct vkd3d_string_buffer *string;
 
@@ -4544,6 +4766,66 @@ static void validate_texture_format_type(struct hlsl_ctx *ctx, struct hlsl_type
     }
 }
 
+static bool check_continue(struct hlsl_ctx *ctx, const struct hlsl_scope *scope, const struct vkd3d_shader_location *loc)
+{
+    if (scope->_switch)
+    {
+        hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
+                "The 'continue' statement is not allowed in 'switch' statements.");
+        return false;
+    }
+
+    if (scope->loop)
+        return true;
+
+    if (scope->upper)
+        return check_continue(ctx, scope->upper, loc);
+
+    hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX, "The 'continue' statement is only allowed in loops.");
+    return false;
+}
+
+static bool is_break_allowed(const struct hlsl_scope *scope)
+{
+    if (scope->loop || scope->_switch)
+        return true;
+
+    return scope->upper ? is_break_allowed(scope->upper) : false;
+}
+
+static void check_duplicated_switch_cases(struct hlsl_ctx *ctx, const struct hlsl_ir_switch_case *check, struct list *cases)
+{
+    struct hlsl_ir_switch_case *c;
+    bool found_duplicate = false;
+
+    LIST_FOR_EACH_ENTRY(c, cases, struct hlsl_ir_switch_case, entry)
+    {
+        if (check->is_default)
+        {
+            if ((found_duplicate = c->is_default))
+            {
+                hlsl_error(ctx, &check->loc, VKD3D_SHADER_ERROR_HLSL_DUPLICATE_SWITCH_CASE,
+                        "Found multiple 'default' statements.");
+                hlsl_note(ctx, &c->loc, VKD3D_SHADER_LOG_ERROR, "The 'default' statement was previously found here.");
+            }
+        }
+        else
+        {
+            if (c->is_default) continue;
+            if ((found_duplicate = (c->value == check->value)))
+            {
+                hlsl_error(ctx, &check->loc, VKD3D_SHADER_ERROR_HLSL_DUPLICATE_SWITCH_CASE,
+                        "Found duplicate 'case' statement.");
+                hlsl_note(ctx, &c->loc, VKD3D_SHADER_LOG_ERROR, "The same 'case %d' statement was previously found here.",
+                        c->value);
+            }
+        }
+
+        if (found_duplicate)
+            break;
+    }
+}
+
 }
 
 %locations
@@ -4582,16 +4864,20 @@ static void validate_texture_format_type(struct hlsl_ctx *ctx, struct hlsl_type
     enum hlsl_sampler_dim sampler_dim;
     struct hlsl_attribute *attr;
     struct parse_attribute_list attr_list;
+    struct hlsl_ir_switch_case *switch_case;
 }
 
 %token KW_BLENDSTATE
 %token KW_BREAK
 %token KW_BUFFER
+%token KW_CASE
 %token KW_CBUFFER
+%token KW_CENTROID
 %token KW_COLUMN_MAJOR
 %token KW_COMPILE
 %token KW_CONST
 %token KW_CONTINUE
+%token KW_DEFAULT
 %token KW_DEPTHSTENCILSTATE
 %token KW_DEPTHSTENCILVIEW
 %token KW_DISCARD
@@ -4610,6 +4896,7 @@ static void validate_texture_format_type(struct hlsl_ctx *ctx, struct hlsl_type
 %token KW_MATRIX
 %token KW_NAMESPACE
 %token KW_NOINTERPOLATION
+%token KW_NOPERSPECTIVE
 %token KW_OUT
 %token KW_PACKOFFSET
 %token KW_PASS
@@ -4623,7 +4910,9 @@ static void validate_texture_format_type(struct hlsl_ctx *ctx, struct hlsl_type
 %token KW_RWBUFFER
 %token KW_RWSTRUCTUREDBUFFER
 %token KW_RWTEXTURE1D
+%token KW_RWTEXTURE1DARRAY
 %token KW_RWTEXTURE2D
+%token KW_RWTEXTURE2DARRAY
 %token KW_RWTEXTURE3D
 %token KW_SAMPLER
 %token KW_SAMPLER1D
@@ -4642,6 +4931,7 @@ static void validate_texture_format_type(struct hlsl_ctx *ctx, struct hlsl_type
 %token KW_TBUFFER
 %token KW_TECHNIQUE
 %token KW_TECHNIQUE10
+%token KW_TECHNIQUE11
 %token KW_TEXTURE
 %token KW_TEXTURE1D
 %token KW_TEXTURE1DARRAY
@@ -4670,7 +4960,6 @@ static void validate_texture_format_type(struct hlsl_ctx *ctx, struct hlsl_type
 %token OP_LEFTSHIFTASSIGN
 %token OP_RIGHTSHIFT
 %token OP_RIGHTSHIFTASSIGN
-%token OP_ELLIPSIS
 %token OP_LE
 %token OP_GE
 %token OP_NE
@@ -4682,19 +4971,17 @@ static void validate_texture_format_type(struct hlsl_ctx *ctx, struct hlsl_type
 %token OP_ANDASSIGN
 %token OP_ORASSIGN
 %token OP_XORASSIGN
-%token OP_UNKNOWN1
-%token OP_UNKNOWN2
-%token OP_UNKNOWN3
-%token OP_UNKNOWN4
 
 %token <floatval> C_FLOAT
 
 %token <intval> C_INTEGER
+%token <intval> C_UNSIGNED
 %token <intval> PRE_LINE
 
 %type <list> type_specs
 %type <list> variables_def
 %type <list> variables_def_typed
+%type <list> switch_cases
 
 %token <name> VAR_IDENTIFIER
 %token <name> NEW_IDENTIFIER
@@ -4737,6 +5024,7 @@ static void validate_texture_format_type(struct hlsl_ctx *ctx, struct hlsl_type
 %type <block> statement
 %type <block> statement_list
 %type <block> struct_declaration_without_vars
+%type <block> switch_statement
 %type <block> unary_expr
 
 %type <boolval> boolean
@@ -4762,6 +5050,7 @@ static void validate_texture_format_type(struct hlsl_ctx *ctx, struct hlsl_type
 
 %type <name> any_identifier
 %type <name> var_identifier
+%type <name> technique_name
 
 %type <parameter> parameter
 
@@ -4775,6 +5064,8 @@ static void validate_texture_format_type(struct hlsl_ctx *ctx, struct hlsl_type
 
 %type <semantic> semantic
 
+%type <switch_case> switch_case
+
 %type <type> field_type
 %type <type> named_struct_spec
 %type <type> unnamed_struct_spec
@@ -4801,8 +5092,50 @@ hlsl_prog:
             destroy_block($2);
         }
     | hlsl_prog preproc_directive
+    | hlsl_prog technique
     | hlsl_prog ';'
 
+technique_name:
+      %empty
+        {
+            $$ = NULL;
+        }
+    | any_identifier
+
+pass_list:
+      %empty
+
+technique9:
+      KW_TECHNIQUE technique_name '{' pass_list '}'
+        {
+            hlsl_fixme(ctx, &@$, "Unsupported \'technique\' declaration.");
+        }
+
+technique10:
+      KW_TECHNIQUE10 technique_name '{' pass_list '}'
+        {
+            if (ctx->profile->type == VKD3D_SHADER_TYPE_EFFECT && ctx->profile->major_version == 2)
+                hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
+                        "The 'technique10' keyword is invalid for this profile.");
+
+            hlsl_fixme(ctx, &@$, "Unsupported \'technique10\' declaration.");
+        }
+
+technique11:
+      KW_TECHNIQUE11 technique_name '{' pass_list '}'
+        {
+            if (ctx->profile->type == VKD3D_SHADER_TYPE_EFFECT && ctx->profile->major_version == 2)
+                hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
+                        "The 'technique11' keyword is invalid for this profile.");
+
+            hlsl_fixme(ctx, &@$, "Unsupported \'technique11\' declaration.");
+        }
+
+technique:
+      technique9
+    | technique10
+    | technique11
+
 buffer_declaration:
       buffer_type any_identifier colon_attribute
         {
@@ -4952,7 +5285,7 @@ field:
 
             if (!(type = apply_type_modifiers(ctx, $2, &modifiers, true, &@1)))
                 YYABORT;
-            if (modifiers & ~HLSL_STORAGE_NOINTERPOLATION)
+            if (modifiers & ~HLSL_INTERPOLATION_MODIFIERS_MASK)
             {
                 struct vkd3d_string_buffer *string;
 
@@ -5132,7 +5465,7 @@ func_prototype_no_attrs:
                 hlsl_error(ctx, &@5, VKD3D_SHADER_ERROR_HLSL_INVALID_RESERVATION,
                         "packoffset() is not allowed on functions.");
 
-            if (($$.decl = get_func_decl(&ctx->functions, $3, &$5)))
+            if (($$.decl = hlsl_get_func_decl(ctx, $3, &$5)))
             {
                 const struct hlsl_func_parameters *params = &$$.decl->parameters;
                 size_t i;
@@ -5249,6 +5582,20 @@ scope_start:
             hlsl_push_scope(ctx);
         }
 
+loop_scope_start:
+      %empty
+        {
+            hlsl_push_scope(ctx);
+            ctx->cur_scope->loop = true;
+        }
+
+switch_scope_start:
+      %empty
+        {
+            hlsl_push_scope(ctx);
+            ctx->cur_scope->_switch = true;
+        }
+
 var_identifier:
       VAR_IDENTIFIER
     | NEW_IDENTIFIER
@@ -5441,10 +5788,18 @@ uav_type:
         {
             $$ = HLSL_SAMPLER_DIM_1D;
         }
+    | KW_RWTEXTURE1DARRAY
+        {
+            $$ = HLSL_SAMPLER_DIM_1DARRAY;
+        }
     | KW_RWTEXTURE2D
         {
             $$ = HLSL_SAMPLER_DIM_2D;
         }
+    | KW_RWTEXTURE2DARRAY
+        {
+            $$ = HLSL_SAMPLER_DIM_2DARRAY;
+        }
     | KW_RWTEXTURE3D
         {
             $$ = HLSL_SAMPLER_DIM_3D;
@@ -5591,7 +5946,9 @@ type_no_void:
             {
                 case HLSL_SAMPLER_DIM_BUFFER:
                 case HLSL_SAMPLER_DIM_1D:
+                case HLSL_SAMPLER_DIM_1DARRAY:
                 case HLSL_SAMPLER_DIM_2D:
+                case HLSL_SAMPLER_DIM_2DARRAY:
                 case HLSL_SAMPLER_DIM_3D:
                     if ($3->class == HLSL_CLASS_ARRAY)
                     {
@@ -5901,6 +6258,14 @@ var_modifiers:
         {
             $$ = add_modifiers(ctx, $2, HLSL_STORAGE_NOINTERPOLATION, &@1);
         }
+    | KW_CENTROID var_modifiers
+        {
+            $$ = add_modifiers(ctx, $2, HLSL_STORAGE_CENTROID, &@1);
+        }
+    | KW_NOPERSPECTIVE var_modifiers
+        {
+            $$ = add_modifiers(ctx, $2, HLSL_STORAGE_NOPERSPECTIVE, &@1);
+        }
     | KW_PRECISE var_modifiers
         {
             $$ = add_modifiers(ctx, $2, HLSL_MODIFIER_PRECISE, &@1);
@@ -6059,9 +6424,39 @@ statement:
     | jump_statement
     | selection_statement
     | loop_statement
+    | switch_statement
 
 jump_statement:
-      KW_RETURN expr ';'
+      KW_BREAK ';'
+        {
+            struct hlsl_ir_node *jump;
+
+            if (!is_break_allowed(ctx->cur_scope))
+            {
+                hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
+                        "The 'break' statement must be used inside of a loop or a switch.");
+            }
+
+            if (!($$ = make_empty_block(ctx)))
+                YYABORT;
+            if (!(jump = hlsl_new_jump(ctx, HLSL_IR_JUMP_BREAK, NULL, &@1)))
+                YYABORT;
+            hlsl_block_add_instr($$, jump);
+        }
+    | KW_CONTINUE ';'
+        {
+            struct hlsl_ir_node *jump;
+
+            check_continue(ctx, ctx->cur_scope, &@1);
+
+            if (!($$ = make_empty_block(ctx)))
+                YYABORT;
+
+            if (!(jump = hlsl_new_jump(ctx, HLSL_IR_JUMP_UNRESOLVED_CONTINUE, NULL, &@1)))
+                YYABORT;
+            hlsl_block_add_instr($$, jump);
+        }
+    | KW_RETURN expr ';'
         {
             $$ = $2;
             if (!add_return(ctx, $$, node_from_block($$), &@1))
@@ -6150,25 +6545,127 @@ if_body:
         }
 
 loop_statement:
-      attribute_list_optional KW_WHILE '(' expr ')' statement
+      attribute_list_optional loop_scope_start KW_WHILE '(' expr ')' statement
         {
-            $$ = create_loop(ctx, LOOP_WHILE, &$1, NULL, $4, NULL, $6, &@2);
+            $$ = create_loop(ctx, LOOP_WHILE, &$1, NULL, $5, NULL, $7, &@3);
+            hlsl_pop_scope(ctx);
         }
-    | attribute_list_optional KW_DO statement KW_WHILE '(' expr ')' ';'
+    | attribute_list_optional loop_scope_start KW_DO statement KW_WHILE '(' expr ')' ';'
         {
-            $$ = create_loop(ctx, LOOP_DO_WHILE, &$1, NULL, $6, NULL, $3, &@2);
+            $$ = create_loop(ctx, LOOP_DO_WHILE, &$1, NULL, $7, NULL, $4, &@3);
+            hlsl_pop_scope(ctx);
         }
-    | attribute_list_optional KW_FOR '(' scope_start expr_statement expr_statement expr_optional ')' statement
+    | attribute_list_optional loop_scope_start KW_FOR '(' expr_statement expr_statement expr_optional ')' statement
         {
-            $$ = create_loop(ctx, LOOP_FOR, &$1, $5, $6, $7, $9, &@2);
+            $$ = create_loop(ctx, LOOP_FOR, &$1, $5, $6, $7, $9, &@3);
             hlsl_pop_scope(ctx);
         }
-    | attribute_list_optional KW_FOR '(' scope_start declaration expr_statement expr_optional ')' statement
+    | attribute_list_optional loop_scope_start KW_FOR '(' declaration expr_statement expr_optional ')' statement
         {
-            $$ = create_loop(ctx, LOOP_FOR, &$1, $5, $6, $7, $9, &@2);
+            $$ = create_loop(ctx, LOOP_FOR, &$1, $5, $6, $7, $9, &@3);
+            hlsl_pop_scope(ctx);
+        }
+
+switch_statement:
+      attribute_list_optional switch_scope_start KW_SWITCH '(' expr ')' '{' switch_cases '}'
+        {
+            struct hlsl_ir_node *selector = node_from_block($5);
+            struct hlsl_ir_node *s;
+
+            if (!(selector = add_implicit_conversion(ctx, $5, selector, hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT), &@5)))
+            {
+                destroy_switch_cases($8);
+                destroy_block($5);
+                YYABORT;
+            }
+
+            s = hlsl_new_switch(ctx, selector, $8, &@3);
+
+            destroy_switch_cases($8);
+
+            if (!s)
+            {
+                destroy_block($5);
+                YYABORT;
+            }
+
+            $$ = $5;
+            hlsl_block_add_instr($$, s);
+
             hlsl_pop_scope(ctx);
         }
 
+switch_case:
+      KW_CASE expr ':' statement_list
+        {
+            struct hlsl_ir_switch_case *c;
+            unsigned int value;
+
+            value = evaluate_static_expression_as_uint(ctx, $2, &@2);
+
+            c = hlsl_new_switch_case(ctx, value, false, $4, &@2);
+
+            destroy_block($2);
+            destroy_block($4);
+
+            if (!c)
+                YYABORT;
+            $$ = c;
+        }
+    | KW_CASE expr ':'
+        {
+            struct hlsl_ir_switch_case *c;
+            unsigned int value;
+
+            value = evaluate_static_expression_as_uint(ctx, $2, &@2);
+
+            c = hlsl_new_switch_case(ctx, value, false, NULL, &@2);
+
+            destroy_block($2);
+
+            if (!c)
+                YYABORT;
+            $$ = c;
+        }
+    | KW_DEFAULT ':' statement_list
+        {
+            struct hlsl_ir_switch_case *c;
+
+            c = hlsl_new_switch_case(ctx, 0, true, $3, &@1);
+
+            destroy_block($3);
+
+            if (!c)
+                YYABORT;
+            $$ = c;
+        }
+    | KW_DEFAULT ':'
+        {
+            struct hlsl_ir_switch_case *c;
+
+            if (!(c = hlsl_new_switch_case(ctx, 0, true, NULL, &@1)))
+                YYABORT;
+            $$ = c;
+        }
+
+switch_cases:
+      switch_case
+        {
+            struct hlsl_ir_switch_case *c = LIST_ENTRY($1, struct hlsl_ir_switch_case, entry);
+            if (!($$ = make_empty_list(ctx)))
+            {
+                hlsl_free_ir_switch_case(c);
+                YYABORT;
+            }
+            list_add_head($$, &$1->entry);
+        }
+    | switch_cases switch_case
+        {
+            $$ = $1;
+            check_duplicated_switch_cases(ctx, $2, $$);
+            list_add_tail($$, &$2->entry);
+        }
+
 expr_optional:
       %empty
         {
@@ -6213,6 +6710,15 @@ primary_expr:
             if (!($$ = make_block(ctx, c)))
                 YYABORT;
         }
+    | C_UNSIGNED
+        {
+            struct hlsl_ir_node *c;
+
+            if (!(c = hlsl_new_uint_constant(ctx, $1, &@1)))
+                YYABORT;
+            if (!($$ = make_block(ctx, c)))
+                YYABORT;
+        }
     | boolean
         {
             struct hlsl_ir_node *c;
@@ -6316,7 +6822,7 @@ postfix_expr:
                     YYABORT;
                 $$ = $1;
             }
-            else if (node->data_type->class <= HLSL_CLASS_LAST_NUMERIC)
+            else if (hlsl_is_numeric_type(node->data_type))
             {
                 struct hlsl_ir_node *swizzle;
 
@@ -6359,7 +6865,7 @@ postfix_expr:
                 free_parse_initializer(&$4);
                 YYABORT;
             }
-            if ($2->class > HLSL_CLASS_LAST_NUMERIC)
+            if (!hlsl_is_numeric_type($2))
             {
                 struct vkd3d_string_buffer *string;
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index be024842164..5a70878bca7 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -23,30 +23,21 @@
 
 /* TODO: remove when no longer needed, only used for new_offset_instr_from_deref() */
 static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, struct hlsl_block *block,
-        struct hlsl_type *type, struct hlsl_ir_node *offset, struct hlsl_ir_node *idx,
-        enum hlsl_regset regset, const struct vkd3d_shader_location *loc)
+        struct hlsl_type *type, struct hlsl_ir_node *base_offset, struct hlsl_ir_node *idx,
+        enum hlsl_regset regset, unsigned int *offset_component, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_node *idx_offset = NULL;
     struct hlsl_ir_node *c;
 
-    hlsl_block_init(block);
-
     switch (type->class)
     {
         case HLSL_CLASS_VECTOR:
-            idx_offset = idx;
+            *offset_component += hlsl_ir_constant(idx)->value.u[0].u;
             break;
 
         case HLSL_CLASS_MATRIX:
         {
-            if (!(c = hlsl_new_uint_constant(ctx, 4, loc)))
-                return NULL;
-            hlsl_block_add_instr(block, c);
-
-            if (!(idx_offset = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, c, idx)))
-                return NULL;
-            hlsl_block_add_instr(block, idx_offset);
-
+            idx_offset = idx;
             break;
         }
 
@@ -54,6 +45,12 @@ static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, str
         {
             unsigned int size = hlsl_type_get_array_element_reg_size(type->e.array.type, regset);
 
+            if (regset == HLSL_REGSET_NUMERIC)
+            {
+                assert(size % 4 == 0);
+                size /= 4;
+            }
+
             if (!(c = hlsl_new_uint_constant(ctx, size, loc)))
                 return NULL;
             hlsl_block_add_instr(block, c);
@@ -69,8 +66,16 @@ static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, str
         {
             unsigned int field_idx = hlsl_ir_constant(idx)->value.u[0].u;
             struct hlsl_struct_field *field = &type->e.record.fields[field_idx];
+            unsigned int field_offset = field->reg_offset[regset];
+
+            if (regset == HLSL_REGSET_NUMERIC)
+            {
+                assert(*offset_component == 0);
+                *offset_component = field_offset % 4;
+                field_offset /= 4;
+            }
 
-            if (!(c = hlsl_new_uint_constant(ctx, field->reg_offset[regset], loc)))
+            if (!(c = hlsl_new_uint_constant(ctx, field_offset, loc)))
                 return NULL;
             hlsl_block_add_instr(block, c);
 
@@ -83,27 +88,33 @@ static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, str
             vkd3d_unreachable();
     }
 
-    if (offset)
+    if (idx_offset)
     {
-        if (!(idx_offset = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, offset, idx_offset)))
+        if (!(base_offset = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, base_offset, idx_offset)))
             return NULL;
-        hlsl_block_add_instr(block, idx_offset);
+        hlsl_block_add_instr(block, base_offset);
     }
 
-    return idx_offset;
+    return base_offset;
 }
 
 /* TODO: remove when no longer needed, only used for replace_deref_path_with_offset() */
 static struct hlsl_ir_node *new_offset_instr_from_deref(struct hlsl_ctx *ctx, struct hlsl_block *block,
-        const struct hlsl_deref *deref, const struct vkd3d_shader_location *loc)
+        const struct hlsl_deref *deref, unsigned int *offset_component, const struct vkd3d_shader_location *loc)
 {
-    enum hlsl_regset regset = hlsl_type_get_regset(deref->data_type);
-    struct hlsl_ir_node *offset = NULL;
+    enum hlsl_regset regset = hlsl_deref_get_regset(ctx, deref);
+    struct hlsl_ir_node *offset;
     struct hlsl_type *type;
     unsigned int i;
 
+    *offset_component = 0;
+
     hlsl_block_init(block);
 
+    if (!(offset = hlsl_new_uint_constant(ctx, 0, loc)))
+        return NULL;
+    hlsl_block_add_instr(block, offset);
+
     assert(deref->var);
     type = deref->var->data_type;
 
@@ -111,9 +122,14 @@ static struct hlsl_ir_node *new_offset_instr_from_deref(struct hlsl_ctx *ctx, st
     {
         struct hlsl_block idx_block;
 
+        hlsl_block_init(&idx_block);
+
         if (!(offset = new_offset_from_path_index(ctx, &idx_block, type, offset, deref->path[i].node,
-                regset, loc)))
+                regset, offset_component, loc)))
+        {
+            hlsl_block_cleanup(&idx_block);
             return NULL;
+        }
 
         hlsl_block_add_block(block, &idx_block);
 
@@ -127,14 +143,13 @@ static struct hlsl_ir_node *new_offset_instr_from_deref(struct hlsl_ctx *ctx, st
 static bool replace_deref_path_with_offset(struct hlsl_ctx *ctx, struct hlsl_deref *deref,
         struct hlsl_ir_node *instr)
 {
-    struct hlsl_type *type;
+    unsigned int offset_component;
     struct hlsl_ir_node *offset;
     struct hlsl_block block;
+    struct hlsl_type *type;
 
     assert(deref->var);
-
-    /* register offsets shouldn't be used before this point is reached. */
-    assert(!deref->offset.node);
+    assert(!hlsl_deref_is_lowered(deref));
 
     type = hlsl_deref_get_type(ctx, deref);
 
@@ -148,16 +163,35 @@ static bool replace_deref_path_with_offset(struct hlsl_ctx *ctx, struct hlsl_der
 
     deref->data_type = type;
 
-    if (!(offset = new_offset_instr_from_deref(ctx, &block, deref, &instr->loc)))
+    if (!(offset = new_offset_instr_from_deref(ctx, &block, deref, &offset_component, &instr->loc)))
         return false;
     list_move_before(&instr->entry, &block.instrs);
 
     hlsl_cleanup_deref(deref);
-    hlsl_src_from_node(&deref->offset, offset);
+    hlsl_src_from_node(&deref->rel_offset, offset);
+    deref->const_offset = offset_component;
 
     return true;
 }
 
+static bool clean_constant_deref_offset_srcs(struct hlsl_ctx *ctx, struct hlsl_deref *deref,
+        struct hlsl_ir_node *instr)
+{
+    if (deref->rel_offset.node && deref->rel_offset.node->type == HLSL_IR_CONSTANT)
+    {
+        enum hlsl_regset regset = hlsl_deref_get_regset(ctx, deref);
+
+        if (regset == HLSL_REGSET_NUMERIC)
+            deref->const_offset += 4 * hlsl_ir_constant(deref->rel_offset.node)->value.u[0].u;
+        else
+            deref->const_offset += hlsl_ir_constant(deref->rel_offset.node)->value.u[0].u;
+        hlsl_src_remove(&deref->rel_offset);
+        return true;
+    }
+    return false;
+}
+
+
 /* Split uniforms into two variables representing the constant and temp
  * registers, and copy the former to the latter, so that writes to uniforms
  * work. */
@@ -195,7 +229,7 @@ static void prepend_uniform_copy(struct hlsl_ctx *ctx, struct hlsl_block *block,
 
 static void validate_field_semantic(struct hlsl_ctx *ctx, struct hlsl_struct_field *field)
 {
-    if (!field->semantic.name && hlsl_get_multiarray_element_type(field->type)->class <= HLSL_CLASS_LAST_NUMERIC
+    if (!field->semantic.name && hlsl_is_numeric_type(hlsl_get_multiarray_element_type(field->type))
             && !field->semantic.reported_missing)
     {
         hlsl_error(ctx, &field->loc, VKD3D_SHADER_ERROR_HLSL_MISSING_SEMANTIC,
@@ -249,7 +283,7 @@ static struct hlsl_ir_var *add_semantic_var(struct hlsl_ctx *ctx, struct hlsl_ir
                 {
                     hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SEMANTIC,
                             "Output semantic \"%s%u\" is used multiple times.", semantic->name, index);
-                    hlsl_note(ctx, &ext_var->loc, HLSL_LEVEL_ERROR,
+                    hlsl_note(ctx, &ext_var->loc, VKD3D_SHADER_LOG_ERROR,
                             "First use of \"%s%u\" is here.", semantic->name, index);
                     semantic->reported_duplicated_output_next_index = index + 1;
                 }
@@ -262,7 +296,7 @@ static struct hlsl_ir_var *add_semantic_var(struct hlsl_ctx *ctx, struct hlsl_ir
                     hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SEMANTIC,
                             "Input semantic \"%s%u\" is used multiple times with incompatible types.",
                             semantic->name, index);
-                    hlsl_note(ctx, &ext_var->loc, HLSL_LEVEL_ERROR,
+                    hlsl_note(ctx, &ext_var->loc, VKD3D_SHADER_LOG_ERROR,
                             "First declaration of \"%s%u\" is here.", semantic->name, index);
                     semantic->reported_duplicated_input_incompatible_next_index = index + 1;
                 }
@@ -305,7 +339,7 @@ static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_block *block, s
     struct hlsl_ir_node *c;
     unsigned int i;
 
-    if (type->class > HLSL_CLASS_LAST_NUMERIC)
+    if (!hlsl_is_numeric_type(type))
     {
         struct vkd3d_string_buffer *string;
         if (!(string = hlsl_type_to_string(ctx, type)))
@@ -377,6 +411,8 @@ static void prepend_input_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_block *
 
         for (i = 0; i < hlsl_type_element_count(type); ++i)
         {
+            unsigned int element_modifiers = modifiers;
+
             if (type->class == HLSL_CLASS_ARRAY)
             {
                 elem_semantic_index = semantic_index
@@ -391,6 +427,17 @@ static void prepend_input_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_block *
                 semantic = &field->semantic;
                 elem_semantic_index = semantic->index;
                 loc = &field->loc;
+                element_modifiers |= field->storage_modifiers;
+
+                /* TODO: 'sample' modifier is not supported yet */
+
+                /* 'nointerpolation' always takes precedence, next the same is done for 'sample',
+                   remaining modifiers are combined. */
+                if (element_modifiers & HLSL_STORAGE_NOINTERPOLATION)
+                {
+                    element_modifiers &= ~HLSL_INTERPOLATION_MODIFIERS_MASK;
+                    element_modifiers |= HLSL_STORAGE_NOINTERPOLATION;
+                }
             }
 
             if (!(c = hlsl_new_uint_constant(ctx, i, &var->loc)))
@@ -402,7 +449,7 @@ static void prepend_input_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_block *
                 return;
             list_add_after(&c->entry, &element_load->node.entry);
 
-            prepend_input_copy_recurse(ctx, block, element_load, modifiers, semantic, elem_semantic_index);
+            prepend_input_copy_recurse(ctx, block, element_load, element_modifiers, semantic, elem_semantic_index);
         }
     }
     else
@@ -434,7 +481,7 @@ static void append_output_copy(struct hlsl_ctx *ctx, struct hlsl_block *block, s
     struct hlsl_ir_node *c;
     unsigned int i;
 
-    if (type->class > HLSL_CLASS_LAST_NUMERIC)
+    if (!hlsl_is_numeric_type(type))
     {
         struct vkd3d_string_buffer *string;
         if (!(string = hlsl_type_to_string(ctx, type)))
@@ -562,7 +609,19 @@ bool hlsl_transform_ir(struct hlsl_ctx *ctx, bool (*func)(struct hlsl_ctx *ctx,
             progress |= hlsl_transform_ir(ctx, func, &iff->else_block, context);
         }
         else if (instr->type == HLSL_IR_LOOP)
+        {
             progress |= hlsl_transform_ir(ctx, func, &hlsl_ir_loop(instr)->body, context);
+        }
+        else if (instr->type == HLSL_IR_SWITCH)
+        {
+            struct hlsl_ir_switch *s = hlsl_ir_switch(instr);
+            struct hlsl_ir_switch_case *c;
+
+            LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+            {
+                progress |= hlsl_transform_ir(ctx, func, &c->body, context);
+            }
+        }
 
         progress |= func(ctx, instr, context);
     }
@@ -822,6 +881,30 @@ static bool lower_return(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *fun
                 }
             }
         }
+        else if (instr->type == HLSL_IR_SWITCH)
+        {
+            struct hlsl_ir_switch *s = hlsl_ir_switch(instr);
+            struct hlsl_ir_switch_case *c;
+
+            LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+            {
+                has_early_return |= lower_return(ctx, func, &c->body, true);
+            }
+
+            if (has_early_return)
+            {
+                if (in_loop)
+                {
+                    /* For a 'switch' nested in a loop append a break after the 'switch'. */
+                    insert_early_return_break(ctx, func, instr);
+                }
+                else
+                {
+                    cf_instr = instr;
+                    break;
+                }
+            }
+        }
     }
 
     if (return_instr)
@@ -989,7 +1072,7 @@ static bool lower_matrix_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *ins
  * For the latter case, this pass takes care of lowering hlsl_ir_indexes into individual
  * hlsl_ir_loads, or individual hlsl_ir_resource_loads, in case the indexing is a
  * resource access. */
-static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_ir_node *val, *store;
     struct hlsl_deref var_deref;
@@ -1023,8 +1106,7 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
 
         if (!(load = hlsl_new_resource_load(ctx, &params, &instr->loc)))
             return false;
-        list_add_before(&instr->entry, &load->entry);
-        hlsl_replace_node(instr, load);
+        hlsl_block_add_instr(block, load);
         return true;
     }
 
@@ -1034,7 +1116,7 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
 
     if (!(store = hlsl_new_simple_store(ctx, var, val)))
         return false;
-    list_add_before(&instr->entry, &store->entry);
+    hlsl_block_add_instr(block, store);
 
     if (hlsl_index_is_noncontiguous(index))
     {
@@ -1054,38 +1136,36 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
 
             if (!(c = hlsl_new_uint_constant(ctx, i, &instr->loc)))
                 return false;
-            list_add_before(&instr->entry, &c->entry);
+            hlsl_block_add_instr(block, c);
 
             if (!(load = hlsl_new_load_index(ctx, &var_deref, c, &instr->loc)))
                 return false;
-            list_add_before(&instr->entry, &load->node.entry);
+            hlsl_block_add_instr(block, &load->node);
 
             if (!(load = hlsl_new_load_index(ctx, &load->src, index->idx.node, &instr->loc)))
                 return false;
-            list_add_before(&instr->entry, &load->node.entry);
+            hlsl_block_add_instr(block, &load->node);
 
             if (!(store = hlsl_new_store_index(ctx, &row_deref, c, &load->node, 0, &instr->loc)))
                 return false;
-            list_add_before(&instr->entry, &store->entry);
+            hlsl_block_add_instr(block, store);
         }
 
         if (!(load = hlsl_new_var_load(ctx, var, &instr->loc)))
             return false;
-        list_add_before(&instr->entry, &load->node.entry);
-        hlsl_replace_node(instr, &load->node);
+        hlsl_block_add_instr(block, &load->node);
     }
     else
     {
         if (!(load = hlsl_new_load_index(ctx, &var_deref, index->idx.node, &instr->loc)))
             return false;
-        list_add_before(&instr->entry, &load->node.entry);
-        hlsl_replace_node(instr, &load->node);
+        hlsl_block_add_instr(block, &load->node);
     }
     return true;
 }
 
 /* Lower casts from vec1 to vecN to swizzles. */
-static bool lower_broadcasts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_broadcasts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     const struct hlsl_type *src_type, *dst_type;
     struct hlsl_type *dst_scalar_type;
@@ -1101,25 +1181,22 @@ static bool lower_broadcasts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, v
 
     if (src_type->class <= HLSL_CLASS_VECTOR && dst_type->class <= HLSL_CLASS_VECTOR && src_type->dimx == 1)
     {
-        struct hlsl_ir_node *replacement, *new_cast, *swizzle;
+        struct hlsl_ir_node *new_cast, *swizzle;
 
         dst_scalar_type = hlsl_get_scalar_type(ctx, dst_type->base_type);
         /* We need to preserve the cast since it might be doing more than just
          * turning the scalar into a vector. */
         if (!(new_cast = hlsl_new_cast(ctx, cast->operands[0].node, dst_scalar_type, &cast->node.loc)))
             return false;
-        list_add_after(&cast->node.entry, &new_cast->entry);
-        replacement = new_cast;
+        hlsl_block_add_instr(block, new_cast);
 
         if (dst_type->dimx != 1)
         {
-            if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), dst_type->dimx, replacement, &cast->node.loc)))
+            if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), dst_type->dimx, new_cast, &cast->node.loc)))
                 return false;
-            list_add_after(&new_cast->entry, &swizzle->entry);
-            replacement = swizzle;
+            hlsl_block_add_instr(block, swizzle);
         }
 
-        hlsl_replace_node(&cast->node, replacement);
         return true;
     }
 
@@ -1632,6 +1709,19 @@ static void copy_propagation_invalidate_from_block(struct hlsl_ctx *ctx, struct
                 break;
             }
 
+            case HLSL_IR_SWITCH:
+            {
+                struct hlsl_ir_switch *s = hlsl_ir_switch(instr);
+                struct hlsl_ir_switch_case *c;
+
+                LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+                {
+                    copy_propagation_invalidate_from_block(ctx, state, &c->body);
+                }
+
+                break;
+            }
+
             default:
                 break;
         }
@@ -1680,6 +1770,28 @@ static bool copy_propagation_process_loop(struct hlsl_ctx *ctx, struct hlsl_ir_l
     return progress;
 }
 
+static bool copy_propagation_process_switch(struct hlsl_ctx *ctx, struct hlsl_ir_switch *s,
+        struct copy_propagation_state *state)
+{
+    struct copy_propagation_state inner_state;
+    struct hlsl_ir_switch_case *c;
+    bool progress = false;
+
+    LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+    {
+        copy_propagation_state_init(ctx, &inner_state, state);
+        progress |= copy_propagation_transform_block(ctx, &c->body, &inner_state);
+        copy_propagation_state_destroy(&inner_state);
+    }
+
+    LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+    {
+        copy_propagation_invalidate_from_block(ctx, state, &c->body);
+    }
+
+    return progress;
+}
+
 static bool copy_propagation_transform_block(struct hlsl_ctx *ctx, struct hlsl_block *block,
         struct copy_propagation_state *state)
 {
@@ -1718,6 +1830,10 @@ static bool copy_propagation_transform_block(struct hlsl_ctx *ctx, struct hlsl_b
                 progress |= copy_propagation_process_loop(ctx, hlsl_ir_loop(instr), state);
                 break;
 
+            case HLSL_IR_SWITCH:
+                progress |= copy_propagation_process_switch(ctx, hlsl_ir_switch(instr), state);
+                break;
+
             default:
                 break;
         }
@@ -1981,7 +2097,7 @@ static bool split_matrix_copies(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
     return true;
 }
 
-static bool lower_narrowing_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_narrowing_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     const struct hlsl_type *src_type, *dst_type;
     struct hlsl_type *dst_vector_type;
@@ -2004,12 +2120,12 @@ static bool lower_narrowing_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *ins
          * narrowing the vector. */
         if (!(new_cast = hlsl_new_cast(ctx, cast->operands[0].node, dst_vector_type, &cast->node.loc)))
             return false;
-        list_add_after(&cast->node.entry, &new_cast->entry);
+        hlsl_block_add_instr(block, new_cast);
+
         if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, Y, Z, W), dst_type->dimx, new_cast, &cast->node.loc)))
             return false;
-        list_add_after(&new_cast->entry, &swizzle->entry);
+        hlsl_block_add_instr(block, swizzle);
 
-        hlsl_replace_node(&cast->node, swizzle);
         return true;
     }
 
@@ -2068,7 +2184,138 @@ static bool remove_trivial_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *i
     return true;
 }
 
-static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool remove_trivial_conditional_branches(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+{
+    struct hlsl_ir_constant *condition;
+    struct hlsl_ir_if *iff;
+
+    if (instr->type != HLSL_IR_IF)
+        return false;
+    iff = hlsl_ir_if(instr);
+    if (iff->condition.node->type != HLSL_IR_CONSTANT)
+        return false;
+    condition = hlsl_ir_constant(iff->condition.node);
+
+    list_move_before(&instr->entry, condition->value.u[0].u ? &iff->then_block.instrs : &iff->else_block.instrs);
+    list_remove(&instr->entry);
+    hlsl_free_instr(instr);
+
+    return true;
+}
+
+static bool normalize_switch_cases(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+{
+    struct hlsl_ir_switch_case *c, *def = NULL;
+    bool missing_terminal_break = false;
+    struct hlsl_ir_node *node;
+    struct hlsl_ir_jump *jump;
+    struct hlsl_ir_switch *s;
+
+    if (instr->type != HLSL_IR_SWITCH)
+        return false;
+    s = hlsl_ir_switch(instr);
+
+    LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+    {
+        bool terminal_break = false;
+
+        if (list_empty(&c->body.instrs))
+        {
+            terminal_break = !!list_next(&s->cases, &c->entry);
+        }
+        else
+        {
+            node = LIST_ENTRY(list_tail(&c->body.instrs), struct hlsl_ir_node, entry);
+            if (node->type == HLSL_IR_JUMP)
+            {
+                jump = hlsl_ir_jump(node);
+                terminal_break = jump->type == HLSL_IR_JUMP_BREAK;
+            }
+        }
+
+        missing_terminal_break |= !terminal_break;
+
+        if (!terminal_break)
+        {
+            if (c->is_default)
+            {
+                hlsl_error(ctx, &c->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
+                        "The 'default' case block is not terminated with 'break' or 'return'.");
+            }
+            else
+            {
+                hlsl_error(ctx, &c->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
+                        "Switch case block '%u' is not terminated with 'break' or 'return'.", c->value);
+            }
+        }
+    }
+
+    if (missing_terminal_break)
+        return true;
+
+    LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+    {
+        if (c->is_default)
+        {
+            def = c;
+
+            /* Remove preceding empty cases. */
+            while (list_prev(&s->cases, &def->entry))
+            {
+                c = LIST_ENTRY(list_prev(&s->cases, &def->entry), struct hlsl_ir_switch_case, entry);
+                if (!list_empty(&c->body.instrs))
+                    break;
+                hlsl_free_ir_switch_case(c);
+            }
+
+            if (list_empty(&def->body.instrs))
+            {
+                /* Remove following empty cases. */
+                while (list_next(&s->cases, &def->entry))
+                {
+                    c = LIST_ENTRY(list_next(&s->cases, &def->entry), struct hlsl_ir_switch_case, entry);
+                    if (!list_empty(&c->body.instrs))
+                        break;
+                    hlsl_free_ir_switch_case(c);
+                }
+
+                /* Merge with the next case. */
+                if (list_next(&s->cases, &def->entry))
+                {
+                    c = LIST_ENTRY(list_next(&s->cases, &def->entry), struct hlsl_ir_switch_case, entry);
+                    c->is_default = true;
+                    hlsl_free_ir_switch_case(def);
+                    def = c;
+                }
+            }
+
+            break;
+        }
+    }
+
+    if (def)
+    {
+        list_remove(&def->entry);
+    }
+    else
+    {
+        struct hlsl_ir_node *jump;
+
+        if (!(def = hlsl_new_switch_case(ctx, 0, true, NULL, &s->node.loc)))
+            return true;
+        if (!(jump = hlsl_new_jump(ctx, HLSL_IR_JUMP_BREAK, NULL, &s->node.loc)))
+        {
+            hlsl_free_ir_switch_case(def);
+            return true;
+        }
+        hlsl_block_add_instr(&def->body, jump);
+    }
+    list_add_tail(&s->cases, &def->entry);
+
+    return true;
+}
+
+static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_ir_node *idx;
     struct hlsl_deref *deref;
@@ -2099,11 +2346,11 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
 
         if (!(vector_load = hlsl_new_load_parent(ctx, deref, &instr->loc)))
             return false;
-        list_add_before(&instr->entry, &vector_load->node.entry);
+        hlsl_block_add_instr(block, &vector_load->node);
 
         if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), type->dimx, idx, &instr->loc)))
             return false;
-        list_add_before(&instr->entry, &swizzle->entry);
+        hlsl_block_add_instr(block, swizzle);
 
         value.u[0].u = 0;
         value.u[1].u = 1;
@@ -2111,18 +2358,18 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
         value.u[3].u = 3;
         if (!(c = hlsl_new_constant(ctx, hlsl_get_vector_type(ctx, HLSL_TYPE_UINT, type->dimx), &value, &instr->loc)))
             return false;
-        list_add_before(&instr->entry, &c->entry);
+        hlsl_block_add_instr(block, c);
 
         operands[0] = swizzle;
         operands[1] = c;
         if (!(eq = hlsl_new_expr(ctx, HLSL_OP2_EQUAL, operands,
                 hlsl_get_vector_type(ctx, HLSL_TYPE_BOOL, type->dimx), &instr->loc)))
             return false;
-        list_add_before(&instr->entry, &eq->entry);
+        hlsl_block_add_instr(block, eq);
 
         if (!(eq = hlsl_new_cast(ctx, eq, type, &instr->loc)))
             return false;
-        list_add_before(&instr->entry, &eq->entry);
+        hlsl_block_add_instr(block, eq);
 
         op = HLSL_OP2_DOT;
         if (type->dimx == 1)
@@ -2134,8 +2381,7 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
         operands[1] = eq;
         if (!(dot = hlsl_new_expr(ctx, op, operands, instr->data_type, &instr->loc)))
             return false;
-        list_add_before(&instr->entry, &dot->entry);
-        hlsl_replace_node(instr, dot);
+        hlsl_block_add_instr(block, dot);
 
         return true;
     }
@@ -2173,6 +2419,7 @@ static bool lower_combined_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
         case HLSL_RESOURCE_SAMPLE:
         case HLSL_RESOURCE_SAMPLE_LOD:
         case HLSL_RESOURCE_SAMPLE_LOD_BIAS:
+        case HLSL_RESOURCE_SAMPLE_PROJ:
             break;
     }
     if (load->sampler.var)
@@ -2184,7 +2431,7 @@ static bool lower_combined_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
         return false;
     }
 
-    assert(hlsl_type_get_regset(load->resource.var->data_type) == HLSL_REGSET_SAMPLERS);
+    assert(hlsl_deref_get_regset(ctx, &load->resource) == HLSL_REGSET_SAMPLERS);
 
     if (!(name = hlsl_get_string_buffer(ctx)))
         return false;
@@ -2275,10 +2522,10 @@ static bool sort_synthetic_separated_samplers_first(struct hlsl_ctx *ctx)
 }
 
 /* Lower DIV to RCP + MUL. */
-static bool lower_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
+    struct hlsl_ir_node *rcp, *mul;
     struct hlsl_ir_expr *expr;
-    struct hlsl_ir_node *rcp;
 
     if (instr->type != HLSL_IR_EXPR)
         return false;
@@ -2288,18 +2535,20 @@ static bool lower_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, voi
 
     if (!(rcp = hlsl_new_unary_expr(ctx, HLSL_OP1_RCP, expr->operands[1].node, &instr->loc)))
         return false;
-    list_add_before(&expr->node.entry, &rcp->entry);
-    expr->op = HLSL_OP2_MUL;
-    hlsl_src_remove(&expr->operands[1]);
-    hlsl_src_from_node(&expr->operands[1], rcp);
+    hlsl_block_add_instr(block, rcp);
+
+    if (!(mul = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, expr->operands[0].node, rcp)))
+        return false;
+    hlsl_block_add_instr(block, mul);
+
     return true;
 }
 
 /* Lower SQRT to RSQ + RCP. */
-static bool lower_sqrt(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_sqrt(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
+    struct hlsl_ir_node *rsq, *rcp;
     struct hlsl_ir_expr *expr;
-    struct hlsl_ir_node *rsq;
 
     if (instr->type != HLSL_IR_EXPR)
         return false;
@@ -2309,15 +2558,16 @@ static bool lower_sqrt(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *c
 
     if (!(rsq = hlsl_new_unary_expr(ctx, HLSL_OP1_RSQ, expr->operands[0].node, &instr->loc)))
         return false;
-    list_add_before(&expr->node.entry, &rsq->entry);
-    expr->op = HLSL_OP1_RCP;
-    hlsl_src_remove(&expr->operands[0]);
-    hlsl_src_from_node(&expr->operands[0], rsq);
+    hlsl_block_add_instr(block, rsq);
+
+    if (!(rcp = hlsl_new_unary_expr(ctx, HLSL_OP1_RCP, rsq, &instr->loc)))
+        return false;
+    hlsl_block_add_instr(block, rcp);
     return true;
 }
 
 /* Lower DP2 to MUL + ADD */
-static bool lower_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_ir_node *arg1, *arg2, *mul, *replacement, *zero, *add_x, *add_y;
     struct hlsl_ir_expr *expr;
@@ -2338,7 +2588,7 @@ static bool lower_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *co
 
         if (!(zero = hlsl_new_float_constant(ctx, 0.0f, &expr->node.loc)))
             return false;
-        list_add_before(&instr->entry, &zero->entry);
+        hlsl_block_add_instr(block, zero);
 
         operands[0] = arg1;
         operands[1] = arg2;
@@ -2351,27 +2601,26 @@ static bool lower_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *co
     {
         if (!(mul = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, expr->operands[0].node, expr->operands[1].node)))
             return false;
-        list_add_before(&instr->entry, &mul->entry);
+        hlsl_block_add_instr(block, mul);
 
         if (!(add_x = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), instr->data_type->dimx, mul, &expr->node.loc)))
             return false;
-        list_add_before(&instr->entry, &add_x->entry);
+        hlsl_block_add_instr(block, add_x);
 
         if (!(add_y = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(Y, Y, Y, Y), instr->data_type->dimx, mul, &expr->node.loc)))
             return false;
-        list_add_before(&instr->entry, &add_y->entry);
+        hlsl_block_add_instr(block, add_y);
 
         if (!(replacement = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, add_x, add_y)))
             return false;
     }
-    list_add_before(&instr->entry, &replacement->entry);
+    hlsl_block_add_instr(block, replacement);
 
-    hlsl_replace_node(instr, replacement);
     return true;
 }
 
 /* Lower ABS to MAX */
-static bool lower_abs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_abs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_ir_node *arg, *neg, *replacement;
     struct hlsl_ir_expr *expr;
@@ -2385,18 +2634,17 @@ static bool lower_abs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *co
 
     if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg, &instr->loc)))
         return false;
-    list_add_before(&instr->entry, &neg->entry);
+    hlsl_block_add_instr(block, neg);
 
     if (!(replacement = hlsl_new_binary_expr(ctx, HLSL_OP2_MAX, neg, arg)))
         return false;
-    list_add_before(&instr->entry, &replacement->entry);
+    hlsl_block_add_instr(block, replacement);
 
-    hlsl_replace_node(instr, replacement);
     return true;
 }
 
 /* Lower ROUND using FRC, ROUND(x) -> ((x + 0.5) - FRC(x + 0.5)). */
-static bool lower_round(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_round(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_ir_node *arg, *neg, *sum, *frc, *half, *replacement;
     struct hlsl_type *type = instr->data_type;
@@ -2417,33 +2665,89 @@ static bool lower_round(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *
         half_value.u[i].f = 0.5f;
     if (!(half = hlsl_new_constant(ctx, type, &half_value, &expr->node.loc)))
         return false;
-
-    list_add_before(&instr->entry, &half->entry);
+    hlsl_block_add_instr(block, half);
 
     if (!(sum = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, arg, half)))
         return false;
-    list_add_before(&instr->entry, &sum->entry);
+    hlsl_block_add_instr(block, sum);
 
     if (!(frc = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, sum, &instr->loc)))
         return false;
-    list_add_before(&instr->entry, &frc->entry);
+    hlsl_block_add_instr(block, frc);
 
     if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, frc, &instr->loc)))
         return false;
-    list_add_before(&instr->entry, &neg->entry);
+    hlsl_block_add_instr(block, neg);
 
     if (!(replacement = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, sum, neg)))
         return false;
-    list_add_before(&instr->entry, &replacement->entry);
+    hlsl_block_add_instr(block, replacement);
+
+    return true;
+}
+
+/* Lower CEIL to FRC */
+static bool lower_ceil(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
+{
+    struct hlsl_ir_node *arg, *neg, *sum, *frc;
+    struct hlsl_ir_expr *expr;
+
+    if (instr->type != HLSL_IR_EXPR)
+        return false;
+
+    expr = hlsl_ir_expr(instr);
+    arg = expr->operands[0].node;
+    if (expr->op != HLSL_OP1_CEIL)
+        return false;
+
+    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg, &instr->loc)))
+        return false;
+    hlsl_block_add_instr(block, neg);
+
+    if (!(frc = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, neg, &instr->loc)))
+        return false;
+    hlsl_block_add_instr(block, frc);
+
+    if (!(sum = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, frc, arg)))
+        return false;
+    hlsl_block_add_instr(block, sum);
+
+    return true;
+}
+
+/* Lower FLOOR to FRC */
+static bool lower_floor(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
+{
+    struct hlsl_ir_node *arg, *neg, *sum, *frc;
+    struct hlsl_ir_expr *expr;
+
+    if (instr->type != HLSL_IR_EXPR)
+        return false;
+
+    expr = hlsl_ir_expr(instr);
+    arg = expr->operands[0].node;
+    if (expr->op != HLSL_OP1_FLOOR)
+        return false;
+
+    if (!(frc = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, arg, &instr->loc)))
+        return false;
+    hlsl_block_add_instr(block, frc);
+
+    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, frc, &instr->loc)))
+        return false;
+    hlsl_block_add_instr(block, neg);
+
+    if (!(sum = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, neg, arg)))
+        return false;
+    hlsl_block_add_instr(block, sum);
 
-    hlsl_replace_node(instr, replacement);
     return true;
 }
 
 /* Use 'movc' for the ternary operator. */
-static bool lower_ternary(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_ternary(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS], *replacement;
+    struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = { 0 }, *replacement;
     struct hlsl_ir_node *zero, *cond, *first, *second;
     struct hlsl_constant_value zero_value = { 0 };
     struct hlsl_ir_expr *expr;
@@ -2460,39 +2764,63 @@ static bool lower_ternary(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void
     first = expr->operands[1].node;
     second = expr->operands[2].node;
 
-    if (cond->data_type->base_type == HLSL_TYPE_FLOAT)
+    if (ctx->profile->major_version < 4 && ctx->profile->type == VKD3D_SHADER_TYPE_PIXEL)
     {
-        if (!(zero = hlsl_new_constant(ctx, cond->data_type, &zero_value, &instr->loc)))
+        struct hlsl_ir_node *abs, *neg;
+
+        if (!(abs = hlsl_new_unary_expr(ctx, HLSL_OP1_ABS, cond, &instr->loc)))
             return false;
-        list_add_tail(&instr->entry, &zero->entry);
+        hlsl_block_add_instr(block, abs);
 
-        memset(operands, 0, sizeof(operands));
-        operands[0] = zero;
-        operands[1] = cond;
-        type = cond->data_type;
-        type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_BOOL, type->dimx, type->dimy);
-        if (!(cond = hlsl_new_expr(ctx, HLSL_OP2_NEQUAL, operands, type, &instr->loc)))
+        if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, abs, &instr->loc)))
             return false;
-        list_add_before(&instr->entry, &cond->entry);
-    }
+        hlsl_block_add_instr(block, neg);
 
-    memset(operands, 0, sizeof(operands));
-    operands[0] = cond;
-    operands[1] = first;
-    operands[2] = second;
-    if (!(replacement = hlsl_new_expr(ctx, HLSL_OP3_MOVC, operands, first->data_type, &instr->loc)))
+        operands[0] = neg;
+        operands[1] = second;
+        operands[2] = first;
+        if (!(replacement = hlsl_new_expr(ctx, HLSL_OP3_CMP, operands, first->data_type, &instr->loc)))
+            return false;
+    }
+    else if (ctx->profile->major_version < 4 && ctx->profile->type == VKD3D_SHADER_TYPE_VERTEX)
+    {
+        hlsl_fixme(ctx, &instr->loc, "Ternary operator is not implemented for %s profile.", ctx->profile->name);
         return false;
-    list_add_before(&instr->entry, &replacement->entry);
+    }
+    else
+    {
+        if (cond->data_type->base_type == HLSL_TYPE_FLOAT)
+        {
+            if (!(zero = hlsl_new_constant(ctx, cond->data_type, &zero_value, &instr->loc)))
+                return false;
+            hlsl_block_add_instr(block, zero);
+
+            operands[0] = zero;
+            operands[1] = cond;
+            type = cond->data_type;
+            type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_BOOL, type->dimx, type->dimy);
+            if (!(cond = hlsl_new_expr(ctx, HLSL_OP2_NEQUAL, operands, type, &instr->loc)))
+                return false;
+            hlsl_block_add_instr(block, cond);
+        }
+
+        memset(operands, 0, sizeof(operands));
+        operands[0] = cond;
+        operands[1] = first;
+        operands[2] = second;
+        if (!(replacement = hlsl_new_expr(ctx, HLSL_OP3_MOVC, operands, first->data_type, &instr->loc)))
+            return false;
+    }
 
-    hlsl_replace_node(instr, replacement);
+    hlsl_block_add_instr(block, replacement);
     return true;
 }
 
-static bool lower_casts_to_bool(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_casts_to_bool(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_type *type = instr->data_type, *arg_type;
     static const struct hlsl_constant_value zero_value;
-    struct hlsl_ir_node *zero;
+    struct hlsl_ir_node *zero, *neq;
     struct hlsl_ir_expr *expr;
 
     if (instr->type != HLSL_IR_EXPR)
@@ -2512,10 +2840,12 @@ static bool lower_casts_to_bool(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
     zero = hlsl_new_constant(ctx, arg_type, &zero_value, &instr->loc);
     if (!zero)
         return false;
-    list_add_before(&instr->entry, &zero->entry);
+    hlsl_block_add_instr(block, zero);
 
-    expr->op = HLSL_OP2_NEQUAL;
-    hlsl_src_from_node(&expr->operands[1], zero);
+    if (!(neq = hlsl_new_binary_expr(ctx, HLSL_OP2_NEQUAL, expr->operands[0].node, zero)))
+        return false;
+    neq->data_type = expr->node.data_type;
+    hlsl_block_add_instr(block, neq);
 
     return true;
 }
@@ -2523,36 +2853,19 @@ static bool lower_casts_to_bool(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
 struct hlsl_ir_node *hlsl_add_conditional(struct hlsl_ctx *ctx, struct hlsl_block *instrs,
         struct hlsl_ir_node *condition, struct hlsl_ir_node *if_true, struct hlsl_ir_node *if_false)
 {
-    struct hlsl_block then_block, else_block;
-    struct hlsl_ir_node *iff, *store;
-    struct hlsl_ir_load *load;
-    struct hlsl_ir_var *var;
+    struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS];
+    struct hlsl_ir_node *cond;
 
     assert(hlsl_types_are_equal(if_true->data_type, if_false->data_type));
 
-    if (!(var = hlsl_new_synthetic_var(ctx, "conditional", if_true->data_type, &condition->loc)))
-        return NULL;
-
-    hlsl_block_init(&then_block);
-    hlsl_block_init(&else_block);
-
-    if (!(store = hlsl_new_simple_store(ctx, var, if_true)))
-        return NULL;
-    hlsl_block_add_instr(&then_block, store);
-
-    if (!(store = hlsl_new_simple_store(ctx, var, if_false)))
-        return NULL;
-    hlsl_block_add_instr(&else_block, store);
-
-    if (!(iff = hlsl_new_if(ctx, condition, &then_block, &else_block, &condition->loc)))
-        return NULL;
-    hlsl_block_add_instr(instrs, iff);
-
-    if (!(load = hlsl_new_var_load(ctx, var, &condition->loc)))
-        return NULL;
-    hlsl_block_add_instr(instrs, &load->node);
+    operands[0] = condition;
+    operands[1] = if_true;
+    operands[2] = if_false;
+    if (!(cond = hlsl_new_expr(ctx, HLSL_OP3_TERNARY, operands, if_true->data_type, &condition->loc)))
+        return false;
+    hlsl_block_add_instr(instrs, cond);
 
-    return &load->node;
+    return cond;
 }
 
 static bool lower_int_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
@@ -2683,10 +2996,10 @@ static bool lower_int_modulus(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
     return hlsl_add_conditional(ctx, block, and, neg, cast3);
 }
 
-static bool lower_int_abs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_int_abs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_type *type = instr->data_type;
-    struct hlsl_ir_node *arg, *neg;
+    struct hlsl_ir_node *arg, *neg, *max;
     struct hlsl_ir_expr *expr;
 
     if (instr->type != HLSL_IR_EXPR)
@@ -2704,15 +3017,16 @@ static bool lower_int_abs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void
 
     if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg, &instr->loc)))
         return false;
-    list_add_before(&instr->entry, &neg->entry);
+    hlsl_block_add_instr(block, neg);
 
-    expr->op = HLSL_OP2_MAX;
-    hlsl_src_from_node(&expr->operands[1], neg);
+    if (!(max = hlsl_new_binary_expr(ctx, HLSL_OP2_MAX, arg, neg)))
+        return false;
+    hlsl_block_add_instr(block, max);
 
     return true;
 }
 
-static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_ir_node *arg1, *arg2, *mult, *comps[4] = {0}, *res;
     struct hlsl_type *type = instr->data_type;
@@ -2738,7 +3052,7 @@ static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void
 
         if (!(mult = hlsl_new_binary_expr(ctx, is_bool ? HLSL_OP2_LOGIC_AND : HLSL_OP2_MUL, arg1, arg2)))
             return false;
-        list_add_before(&instr->entry, &mult->entry);
+        hlsl_block_add_instr(block, mult);
 
         for (i = 0; i < dimx; ++i)
         {
@@ -2746,7 +3060,7 @@ static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void
 
             if (!(comps[i] = hlsl_new_swizzle(ctx, s, 1, mult, &instr->loc)))
                 return false;
-            list_add_before(&instr->entry, &comps[i]->entry);
+            hlsl_block_add_instr(block, comps[i]);
         }
 
         res = comps[0];
@@ -2754,10 +3068,9 @@ static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void
         {
             if (!(res = hlsl_new_binary_expr(ctx, is_bool ? HLSL_OP2_LOGIC_OR : HLSL_OP2_ADD, res, comps[i])))
                 return false;
-            list_add_before(&instr->entry, &res->entry);
+            hlsl_block_add_instr(block, res);
         }
 
-        hlsl_replace_node(instr, res);
         return true;
     }
 
@@ -2922,6 +3235,7 @@ static bool dce(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
         case HLSL_IR_JUMP:
         case HLSL_IR_LOOP:
         case HLSL_IR_RESOURCE_STORE:
+        case HLSL_IR_SWITCH:
             break;
     }
 
@@ -2949,26 +3263,45 @@ static unsigned int index_instructions(struct hlsl_block *block, unsigned int in
             index = index_instructions(&hlsl_ir_loop(instr)->body, index);
             hlsl_ir_loop(instr)->next_index = index;
         }
+        else if (instr->type == HLSL_IR_SWITCH)
+        {
+            struct hlsl_ir_switch *s = hlsl_ir_switch(instr);
+            struct hlsl_ir_switch_case *c;
+
+            LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+            {
+                index = index_instructions(&c->body, index);
+            }
+        }
     }
 
     return index;
 }
 
-static void dump_function_decl(struct rb_entry *entry, void *context)
+static void dump_function(struct rb_entry *entry, void *context)
 {
-    struct hlsl_ir_function_decl *func = RB_ENTRY_VALUE(entry, struct hlsl_ir_function_decl, entry);
+    struct hlsl_ir_function *func = RB_ENTRY_VALUE(entry, struct hlsl_ir_function, entry);
+    struct hlsl_ir_function_decl *decl;
     struct hlsl_ctx *ctx = context;
 
-    if (func->has_body)
-        hlsl_dump_function(ctx, func);
+    LIST_FOR_EACH_ENTRY(decl, &func->overloads, struct hlsl_ir_function_decl, entry)
+    {
+        if (decl->has_body)
+            hlsl_dump_function(ctx, decl);
+    }
 }
 
-static void dump_function(struct rb_entry *entry, void *context)
+static bool mark_indexable_vars(struct hlsl_ctx *ctx, struct hlsl_deref *deref,
+        struct hlsl_ir_node *instr)
 {
-    struct hlsl_ir_function *func = RB_ENTRY_VALUE(entry, struct hlsl_ir_function, entry);
-    struct hlsl_ctx *ctx = context;
+    if (!deref->rel_offset.node)
+        return false;
+
+    assert(deref->var);
+    assert(deref->rel_offset.node->type != HLSL_IR_CONSTANT);
+    deref->var->indexable = true;
 
-    rb_for_each_entry(&func->overloads, dump_function_decl, ctx);
+    return true;
 }
 
 static char get_regset_name(enum hlsl_regset regset)
@@ -2993,31 +3326,39 @@ static void allocate_register_reservations(struct hlsl_ctx *ctx)
 
     LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
     {
-        enum hlsl_regset regset;
+        unsigned int r;
 
         if (!hlsl_type_is_resource(var->data_type))
             continue;
-        regset = hlsl_type_get_regset(var->data_type);
 
-        if (var->reg_reservation.reg_type && var->regs[regset].allocation_size)
+        if (var->reg_reservation.reg_type)
         {
-            if (var->reg_reservation.reg_type != get_regset_name(regset))
-            {
-                struct vkd3d_string_buffer *type_string;
-
-                type_string = hlsl_type_to_string(ctx, var->data_type);
-                hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_RESERVATION,
-                        "Object of type '%s' must be bound to register type '%c'.",
-                        type_string->buffer, get_regset_name(regset));
-                hlsl_release_string_buffer(ctx, type_string);
-            }
-            else
+            for (r = 0; r <= HLSL_REGSET_LAST_OBJECT; ++r)
             {
-                var->regs[regset].allocated = true;
-                var->regs[regset].id = var->reg_reservation.reg_index;
-                TRACE("Allocated reserved %s to %c%u-%c%u.\n", var->name, var->reg_reservation.reg_type,
-                        var->reg_reservation.reg_index, var->reg_reservation.reg_type,
-                        var->reg_reservation.reg_index + var->regs[regset].allocation_size);
+                if (var->regs[r].allocation_size > 0)
+                {
+                    if (var->reg_reservation.reg_type != get_regset_name(r))
+                    {
+                        struct vkd3d_string_buffer *type_string;
+
+                        /* We can throw this error because resources can only span across a single
+                         * regset, but we have to check for multiple regsets if we support register
+                         * reservations for structs for SM5. */
+                        type_string = hlsl_type_to_string(ctx, var->data_type);
+                        hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_RESERVATION,
+                                "Object of type '%s' must be bound to register type '%c'.",
+                                type_string->buffer, get_regset_name(r));
+                        hlsl_release_string_buffer(ctx, type_string);
+                    }
+                    else
+                    {
+                        var->regs[r].allocated = true;
+                        var->regs[r].id = var->reg_reservation.reg_index;
+                        TRACE("Allocated reserved %s to %c%u-%c%u.\n", var->name, var->reg_reservation.reg_type,
+                                var->reg_reservation.reg_index, var->reg_reservation.reg_type,
+                                var->reg_reservation.reg_index + var->regs[r].allocation_size);
+                    }
+                }
             }
         }
     }
@@ -3051,8 +3392,8 @@ static void compute_liveness_recurse(struct hlsl_block *block, unsigned int loop
             if (!var->first_write)
                 var->first_write = loop_first ? min(instr->index, loop_first) : instr->index;
             store->rhs.node->last_read = last_read;
-            if (store->lhs.offset.node)
-                store->lhs.offset.node->last_read = last_read;
+            if (store->lhs.rel_offset.node)
+                store->lhs.rel_offset.node->last_read = last_read;
             break;
         }
         case HLSL_IR_EXPR:
@@ -3079,8 +3420,8 @@ static void compute_liveness_recurse(struct hlsl_block *block, unsigned int loop
 
             var = load->src.var;
             var->last_read = max(var->last_read, last_read);
-            if (load->src.offset.node)
-                load->src.offset.node->last_read = last_read;
+            if (load->src.rel_offset.node)
+                load->src.rel_offset.node->last_read = last_read;
             break;
         }
         case HLSL_IR_LOOP:
@@ -3097,14 +3438,14 @@ static void compute_liveness_recurse(struct hlsl_block *block, unsigned int loop
 
             var = load->resource.var;
             var->last_read = max(var->last_read, last_read);
-            if (load->resource.offset.node)
-                load->resource.offset.node->last_read = last_read;
+            if (load->resource.rel_offset.node)
+                load->resource.rel_offset.node->last_read = last_read;
 
             if ((var = load->sampler.var))
             {
                 var->last_read = max(var->last_read, last_read);
-                if (load->sampler.offset.node)
-                    load->sampler.offset.node->last_read = last_read;
+                if (load->sampler.rel_offset.node)
+                    load->sampler.rel_offset.node->last_read = last_read;
             }
 
             if (load->coords.node)
@@ -3129,8 +3470,8 @@ static void compute_liveness_recurse(struct hlsl_block *block, unsigned int loop
 
             var = store->resource.var;
             var->last_read = max(var->last_read, last_read);
-            if (store->resource.offset.node)
-                store->resource.offset.node->last_read = last_read;
+            if (store->resource.rel_offset.node)
+                store->resource.rel_offset.node->last_read = last_read;
             store->coords.node->last_read = last_read;
             store->value.node->last_read = last_read;
             break;
@@ -3158,6 +3499,16 @@ static void compute_liveness_recurse(struct hlsl_block *block, unsigned int loop
                 jump->condition.node->last_read = last_read;
             break;
         }
+        case HLSL_IR_SWITCH:
+        {
+            struct hlsl_ir_switch *s = hlsl_ir_switch(instr);
+            struct hlsl_ir_switch_case *c;
+
+            LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+                compute_liveness_recurse(&c->body, loop_first, loop_last);
+            s->selector.node->last_read = last_read;
+            break;
+        }
         case HLSL_IR_CONSTANT:
             break;
         }
@@ -3191,18 +3542,20 @@ static void compute_liveness(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl
 
 struct register_allocator
 {
-    size_t count, capacity;
-
-    /* Highest register index that has been allocated.
-     * Used to declare sm4 temp count. */
-    uint32_t max_reg;
-
     struct allocation
     {
         uint32_t reg;
         unsigned int writemask;
         unsigned int first_write, last_read;
     } *allocations;
+    size_t count, capacity;
+
+    /* Indexable temps are allocated separately and always keep their index regardless of their
+     * lifetime. */
+    size_t indexable_count;
+
+    /* Total number of registers allocated so far. Used to declare sm4 temp count. */
+    uint32_t reg_count;
 };
 
 static unsigned int get_available_writemask(const struct register_allocator *allocator,
@@ -3245,7 +3598,7 @@ static void record_allocation(struct hlsl_ctx *ctx, struct register_allocator *a
     allocation->first_write = first_write;
     allocation->last_read = last_read;
 
-    allocator->max_reg = max(allocator->max_reg, reg_idx);
+    allocator->reg_count = max(allocator->reg_count, reg_idx + 1);
 }
 
 /* reg_size is the number of register components to be reserved, while component_count is the number
@@ -3284,13 +3637,19 @@ static struct hlsl_reg allocate_register(struct hlsl_ctx *ctx, struct register_a
 static bool is_range_available(const struct register_allocator *allocator,
         unsigned int first_write, unsigned int last_read, uint32_t reg_idx, unsigned int reg_size)
 {
+    unsigned int last_reg_mask = (1u << (reg_size % 4)) - 1;
+    unsigned int writemask;
     uint32_t i;
 
     for (i = 0; i < (reg_size / 4); ++i)
     {
-        if (get_available_writemask(allocator, first_write, last_read, reg_idx + i) != VKD3DSP_WRITEMASK_ALL)
+        writemask = get_available_writemask(allocator, first_write, last_read, reg_idx + i);
+        if (writemask != VKD3DSP_WRITEMASK_ALL)
             return false;
     }
+    writemask = get_available_writemask(allocator, first_write, last_read, reg_idx + (reg_size / 4));
+    if ((writemask & last_reg_mask) != last_reg_mask)
+        return false;
     return true;
 }
 
@@ -3309,6 +3668,8 @@ static struct hlsl_reg allocate_range(struct hlsl_ctx *ctx, struct register_allo
 
     for (i = 0; i < reg_size / 4; ++i)
         record_allocation(ctx, allocator, reg_idx + i, VKD3DSP_WRITEMASK_ALL, first_write, last_read);
+    if (reg_size % 4)
+        record_allocation(ctx, allocator, reg_idx + (reg_size / 4), (1u << (reg_size % 4)) - 1, first_write, last_read);
 
     ret.id = reg_idx;
     ret.allocation_size = align(reg_size, 4) / 4;
@@ -3356,7 +3717,7 @@ static bool track_object_components_sampler_dim(struct hlsl_ctx *ctx, struct hls
     load = hlsl_ir_resource_load(instr);
     var = load->resource.var;
 
-    regset = hlsl_type_get_regset(hlsl_deref_get_type(ctx, &load->resource));
+    regset = hlsl_deref_get_regset(ctx, &load->resource);
     if (!hlsl_regset_index_from_deref(ctx, &load->resource, regset, &index))
         return false;
 
@@ -3401,7 +3762,8 @@ static bool track_object_components_usage(struct hlsl_ctx *ctx, struct hlsl_ir_n
     load = hlsl_ir_resource_load(instr);
     var = load->resource.var;
 
-    regset = hlsl_type_get_regset(hlsl_deref_get_type(ctx, &load->resource));
+    regset = hlsl_deref_get_regset(ctx, &load->resource);
+
     if (!hlsl_regset_index_from_deref(ctx, &load->resource, regset, &index))
         return false;
 
@@ -3448,11 +3810,23 @@ static void allocate_variable_temp_register(struct hlsl_ctx *ctx,
 
     if (!var->regs[HLSL_REGSET_NUMERIC].allocated && var->last_read)
     {
-        var->regs[HLSL_REGSET_NUMERIC] = allocate_numeric_registers_for_type(ctx, allocator,
-                var->first_write, var->last_read, var->data_type);
+        if (var->indexable)
+        {
+            var->regs[HLSL_REGSET_NUMERIC].id = allocator->indexable_count++;
+            var->regs[HLSL_REGSET_NUMERIC].allocation_size = 1;
+            var->regs[HLSL_REGSET_NUMERIC].writemask = 0;
+            var->regs[HLSL_REGSET_NUMERIC].allocated = true;
+
+            TRACE("Allocated %s to x%u[].\n", var->name, var->regs[HLSL_REGSET_NUMERIC].id);
+        }
+        else
+        {
+            var->regs[HLSL_REGSET_NUMERIC] = allocate_numeric_registers_for_type(ctx, allocator,
+                    var->first_write, var->last_read, var->data_type);
 
-        TRACE("Allocated %s to %s (liveness %u-%u).\n", var->name, debug_register('r',
-                var->regs[HLSL_REGSET_NUMERIC], var->data_type), var->first_write, var->last_read);
+            TRACE("Allocated %s to %s (liveness %u-%u).\n", var->name, debug_register('r',
+                    var->regs[HLSL_REGSET_NUMERIC], var->data_type), var->first_write, var->last_read);
+        }
     }
 }
 
@@ -3508,6 +3882,18 @@ static void allocate_temp_registers_recurse(struct hlsl_ctx *ctx,
                 break;
             }
 
+            case HLSL_IR_SWITCH:
+            {
+                struct hlsl_ir_switch *s = hlsl_ir_switch(instr);
+                struct hlsl_ir_switch_case *c;
+
+                LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+                {
+                    allocate_temp_registers_recurse(ctx, &c->body, allocator);
+                }
+                break;
+            }
+
             default:
                 break;
         }
@@ -3556,7 +3942,7 @@ static void allocate_const_registers_recurse(struct hlsl_ctx *ctx,
                 constant->reg = allocate_numeric_registers_for_type(ctx, allocator, 1, UINT_MAX, type);
                 TRACE("Allocated constant @%u to %s.\n", instr->index, debug_register('c', constant->reg, type));
 
-                assert(type->class <= HLSL_CLASS_LAST_NUMERIC);
+                assert(hlsl_is_numeric_type(type));
                 assert(type->dimy == 1);
                 assert(constant->reg.writemask);
 
@@ -3617,6 +4003,18 @@ static void allocate_const_registers_recurse(struct hlsl_ctx *ctx,
                 break;
             }
 
+            case HLSL_IR_SWITCH:
+            {
+                struct hlsl_ir_switch *s = hlsl_ir_switch(instr);
+                struct hlsl_ir_switch_case *c;
+
+                LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+                {
+                    allocate_const_registers_recurse(ctx, &c->body, allocator);
+                }
+                break;
+            }
+
             default:
                 break;
         }
@@ -3675,7 +4073,7 @@ static void allocate_temp_registers(struct hlsl_ctx *ctx, struct hlsl_ir_functio
     }
 
     allocate_temp_registers_recurse(ctx, &entry_func->body, &allocator);
-    ctx->temp_count = allocator.max_reg + 1;
+    ctx->temp_count = allocator.reg_count;
     vkd3d_free(allocator.allocations);
 }
 
@@ -3728,7 +4126,7 @@ static void allocate_semantic_register(struct hlsl_ctx *ctx, struct hlsl_ir_var
                     "Invalid semantic '%s'.", var->semantic.name);
             return;
         }
-        if ((builtin = hlsl_sm4_register_from_semantic(ctx, &var->semantic, output, &type, NULL, &has_idx)))
+        if ((builtin = hlsl_sm4_register_from_semantic(ctx, &var->semantic, output, &type, &has_idx)))
             reg = has_idx ? var->semantic.index : 0;
     }
 
@@ -4190,30 +4588,25 @@ bool hlsl_regset_index_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref
 
 bool hlsl_offset_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref *deref, unsigned int *offset)
 {
-    struct hlsl_ir_node *offset_node = deref->offset.node;
-    enum hlsl_regset regset;
+    enum hlsl_regset regset = hlsl_deref_get_regset(ctx, deref);
+    struct hlsl_ir_node *offset_node = deref->rel_offset.node;
     unsigned int size;
 
-    if (!offset_node)
-    {
-        *offset = 0;
-        return true;
-    }
+    *offset = deref->const_offset;
 
-    /* We should always have generated a cast to UINT. */
-    assert(offset_node->data_type->class == HLSL_CLASS_SCALAR
-            && offset_node->data_type->base_type == HLSL_TYPE_UINT);
-
-    if (offset_node->type != HLSL_IR_CONSTANT)
+    if (offset_node)
+    {
+        /* We should always have generated a cast to UINT. */
+        assert(offset_node->data_type->class == HLSL_CLASS_SCALAR
+                && offset_node->data_type->base_type == HLSL_TYPE_UINT);
+        assert(offset_node->type != HLSL_IR_CONSTANT);
         return false;
-
-    *offset = hlsl_ir_constant(offset_node)->value.u[0].u;
-    regset = hlsl_type_get_regset(deref->data_type);
+    }
 
     size = deref->var->data_type->reg_size[regset];
     if (*offset >= size)
     {
-        hlsl_error(ctx, &deref->offset.node->loc, VKD3D_SHADER_ERROR_HLSL_OFFSET_OUT_OF_BOUNDS,
+        hlsl_error(ctx, &offset_node->loc, VKD3D_SHADER_ERROR_HLSL_OFFSET_OUT_OF_BOUNDS,
                 "Dereference is out of bounds. %u/%u", *offset, size);
         return false;
     }
@@ -4228,8 +4621,8 @@ unsigned int hlsl_offset_from_deref_safe(struct hlsl_ctx *ctx, const struct hlsl
     if (hlsl_offset_from_deref(ctx, deref, &offset))
         return offset;
 
-    hlsl_fixme(ctx, &deref->offset.node->loc, "Dereference with non-constant offset of type %s.",
-            hlsl_node_type_to_string(deref->offset.node->type));
+    hlsl_fixme(ctx, &deref->rel_offset.node->loc, "Dereference with non-constant offset of type %s.",
+            hlsl_node_type_to_string(deref->rel_offset.node->type));
 
     return 0;
 }
@@ -4241,7 +4634,7 @@ struct hlsl_reg hlsl_reg_from_deref(struct hlsl_ctx *ctx, const struct hlsl_dere
     unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref);
 
     assert(deref->data_type);
-    assert(deref->data_type->class <= HLSL_CLASS_LAST_NUMERIC);
+    assert(hlsl_is_numeric_type(deref->data_type));
 
     ret.id += offset / 4;
 
@@ -4319,6 +4712,62 @@ static bool type_has_object_components(struct hlsl_type *type)
     return false;
 }
 
+static void remove_unreachable_code(struct hlsl_ctx *ctx, struct hlsl_block *body)
+{
+    struct hlsl_ir_node *instr, *next;
+    struct hlsl_block block;
+    struct list *start;
+
+    LIST_FOR_EACH_ENTRY_SAFE(instr, next, &body->instrs, struct hlsl_ir_node, entry)
+    {
+        if (instr->type == HLSL_IR_IF)
+        {
+            struct hlsl_ir_if *iff = hlsl_ir_if(instr);
+
+            remove_unreachable_code(ctx, &iff->then_block);
+            remove_unreachable_code(ctx, &iff->else_block);
+        }
+        else if (instr->type == HLSL_IR_LOOP)
+        {
+            struct hlsl_ir_loop *loop = hlsl_ir_loop(instr);
+
+            remove_unreachable_code(ctx, &loop->body);
+        }
+        else if (instr->type == HLSL_IR_SWITCH)
+        {
+            struct hlsl_ir_switch *s = hlsl_ir_switch(instr);
+            struct hlsl_ir_switch_case *c;
+
+            LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+            {
+                remove_unreachable_code(ctx, &c->body);
+            }
+        }
+    }
+
+    /* Remove instructions past unconditional jumps. */
+    LIST_FOR_EACH_ENTRY(instr, &body->instrs, struct hlsl_ir_node, entry)
+    {
+        struct hlsl_ir_jump *jump;
+
+        if (instr->type != HLSL_IR_JUMP)
+            continue;
+
+        jump = hlsl_ir_jump(instr);
+        if (jump->type != HLSL_IR_JUMP_BREAK && jump->type != HLSL_IR_JUMP_CONTINUE)
+            continue;
+
+        if (!(start = list_next(&body->instrs, &instr->entry)))
+            break;
+
+        hlsl_block_init(&block);
+        list_move_slice_tail(&block.instrs, start, list_tail(&body->instrs));
+        hlsl_block_cleanup(&block);
+
+        break;
+    }
+}
+
 int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func,
         enum vkd3d_shader_target_type target_type, struct vkd3d_shader_code *out)
 {
@@ -4345,7 +4794,7 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
     while (hlsl_transform_ir(ctx, lower_calls, body, NULL));
 
     lower_ir(ctx, lower_matrix_swizzles, body);
-    hlsl_transform_ir(ctx, lower_index_loads, body, NULL);
+    lower_ir(ctx, lower_index_loads, body);
 
     LIST_FOR_EACH_ENTRY(var, &ctx->globals->vars, struct hlsl_ir_var, scope_entry)
     {
@@ -4408,7 +4857,7 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
     {
         hlsl_transform_ir(ctx, lower_discard_neg, body, NULL);
     }
-    hlsl_transform_ir(ctx, lower_broadcasts, body, NULL);
+    lower_ir(ctx, lower_broadcasts, body);
     while (hlsl_transform_ir(ctx, fold_redundant_casts, body, NULL));
     do
     {
@@ -4418,12 +4867,12 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
     while (progress);
     hlsl_transform_ir(ctx, split_matrix_copies, body, NULL);
 
-    hlsl_transform_ir(ctx, lower_narrowing_casts, body, NULL);
-    hlsl_transform_ir(ctx, lower_casts_to_bool, body, NULL);
-    hlsl_transform_ir(ctx, lower_int_dot, body, NULL);
+    lower_ir(ctx, lower_narrowing_casts, body);
+    lower_ir(ctx, lower_casts_to_bool, body);
+    lower_ir(ctx, lower_int_dot, body);
     lower_ir(ctx, lower_int_division, body);
     lower_ir(ctx, lower_int_modulus, body);
-    hlsl_transform_ir(ctx, lower_int_abs, body, NULL);
+    lower_ir(ctx, lower_int_abs, body);
     lower_ir(ctx, lower_float_modulus, body);
     hlsl_transform_ir(ctx, fold_redundant_casts, body, NULL);
     do
@@ -4433,12 +4882,15 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
         progress |= hlsl_copy_propagation_execute(ctx, body);
         progress |= hlsl_transform_ir(ctx, fold_swizzle_chains, body, NULL);
         progress |= hlsl_transform_ir(ctx, remove_trivial_swizzles, body, NULL);
+        progress |= hlsl_transform_ir(ctx, remove_trivial_conditional_branches, body, NULL);
     }
     while (progress);
+    remove_unreachable_code(ctx, body);
+    hlsl_transform_ir(ctx, normalize_switch_cases, body, NULL);
 
-    hlsl_transform_ir(ctx, lower_nonconstant_vector_derefs, body, NULL);
-    hlsl_transform_ir(ctx, lower_casts_to_bool, body, NULL);
-    hlsl_transform_ir(ctx, lower_int_dot, body, NULL);
+    lower_ir(ctx, lower_nonconstant_vector_derefs, body);
+    lower_ir(ctx, lower_casts_to_bool, body);
+    lower_ir(ctx, lower_int_dot, body);
 
     hlsl_transform_ir(ctx, validate_static_object_references, body, NULL);
     hlsl_transform_ir(ctx, track_object_components_sampler_dim, body, NULL);
@@ -4447,24 +4899,26 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
     hlsl_transform_ir(ctx, track_object_components_usage, body, NULL);
     sort_synthetic_separated_samplers_first(ctx);
 
-    if (profile->major_version >= 4)
-        hlsl_transform_ir(ctx, lower_ternary, body, NULL);
+    lower_ir(ctx, lower_ternary, body);
     if (profile->major_version < 4)
     {
-        hlsl_transform_ir(ctx, lower_division, body, NULL);
-        hlsl_transform_ir(ctx, lower_sqrt, body, NULL);
-        hlsl_transform_ir(ctx, lower_dot, body, NULL);
-        hlsl_transform_ir(ctx, lower_round, body, NULL);
+        lower_ir(ctx, lower_division, body);
+        lower_ir(ctx, lower_sqrt, body);
+        lower_ir(ctx, lower_dot, body);
+        lower_ir(ctx, lower_round, body);
+        lower_ir(ctx, lower_ceil, body);
+        lower_ir(ctx, lower_floor, body);
     }
 
     if (profile->major_version < 2)
     {
-        hlsl_transform_ir(ctx, lower_abs, body, NULL);
+        lower_ir(ctx, lower_abs, body);
     }
 
     /* TODO: move forward, remove when no longer needed */
     transform_derefs(ctx, replace_deref_path_with_offset, body);
     while (hlsl_transform_ir(ctx, hlsl_fold_constant_exprs, body, NULL));
+    transform_derefs(ctx, clean_constant_deref_offset_srcs, body);
 
     do
         compute_liveness(ctx, entry_func);
@@ -4475,6 +4929,8 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
     if (TRACE_ON())
         rb_for_each_entry(&ctx->functions, dump_function, ctx);
 
+    transform_derefs(ctx, mark_indexable_vars, body);
+
     calculate_resource_register_counts(ctx);
 
     allocate_register_reservations(ctx);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
index 41a72ab6c0d..b76b1fce507 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
@@ -63,6 +63,82 @@ static bool fold_abs(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     return true;
 }
 
+static uint32_t float_to_uint(float x)
+{
+    if (isnan(x) || x <= 0)
+        return 0;
+
+    if (x >= 4294967296.0f)
+        return UINT32_MAX;
+
+    return x;
+}
+
+static int32_t float_to_int(float x)
+{
+    if (isnan(x))
+        return 0;
+
+    if (x <= -2147483648.0f)
+        return INT32_MIN;
+
+    if (x >= 2147483648.0f)
+        return INT32_MAX;
+
+    return x;
+}
+
+static uint32_t double_to_uint(double x)
+{
+    if (isnan(x) || x <= 0)
+        return 0;
+
+    if (x >= 4294967296.0)
+        return UINT32_MAX;
+
+    return x;
+}
+
+static int32_t double_to_int(double x)
+{
+    if (isnan(x))
+        return 0;
+
+    if (x <= -2147483648.0)
+        return INT32_MIN;
+
+    if (x >= 2147483648.0)
+        return INT32_MAX;
+
+    return x;
+}
+
+static bool fold_bit_not(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
+        const struct hlsl_type *dst_type, const struct hlsl_ir_constant *src)
+{
+    enum hlsl_base_type type = dst_type->base_type;
+    unsigned int k;
+
+    assert(type == src->node.data_type->base_type);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        switch (type)
+        {
+            case HLSL_TYPE_INT:
+            case HLSL_TYPE_UINT:
+            case HLSL_TYPE_BOOL:
+                dst->u[k].u = ~src->value.u[k].u;
+                break;
+
+            default:
+                vkd3d_unreachable();
+        }
+    }
+
+    return true;
+}
+
 static bool fold_cast(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
         const struct hlsl_type *dst_type, const struct hlsl_ir_constant *src)
 {
@@ -86,15 +162,15 @@ static bool fold_cast(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
         {
             case HLSL_TYPE_FLOAT:
             case HLSL_TYPE_HALF:
-                u = src->value.u[k].f;
-                i = src->value.u[k].f;
+                u = float_to_uint(src->value.u[k].f);
+                i = float_to_int(src->value.u[k].f);
                 f = src->value.u[k].f;
                 d = src->value.u[k].f;
                 break;
 
             case HLSL_TYPE_DOUBLE:
-                u = src->value.u[k].d;
-                i = src->value.u[k].d;
+                u = double_to_uint(src->value.u[k].d);
+                i = double_to_int(src->value.u[k].d);
                 f = src->value.u[k].d;
                 d = src->value.u[k].d;
                 break;
@@ -152,6 +228,111 @@ static bool fold_cast(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     return true;
 }
 
+static bool fold_ceil(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
+        const struct hlsl_type *dst_type, const struct hlsl_ir_constant *src)
+{
+    enum hlsl_base_type type = dst_type->base_type;
+    unsigned int k;
+
+    assert(type == src->node.data_type->base_type);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        switch (type)
+        {
+            case HLSL_TYPE_FLOAT:
+            case HLSL_TYPE_HALF:
+                dst->u[k].f = ceilf(src->value.u[k].f);
+                break;
+
+            default:
+                FIXME("Fold 'ceil' for type %s.\n", debug_hlsl_type(ctx, dst_type));
+                return false;
+        }
+    }
+
+    return true;
+}
+
+static bool fold_exp2(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
+        const struct hlsl_type *dst_type, const struct hlsl_ir_constant *src)
+{
+    enum hlsl_base_type type = dst_type->base_type;
+    unsigned int k;
+
+    assert(type == src->node.data_type->base_type);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        switch (type)
+        {
+            case HLSL_TYPE_FLOAT:
+            case HLSL_TYPE_HALF:
+                dst->u[k].f = exp2f(src->value.u[k].f);
+                break;
+
+            default:
+                FIXME("Fold 'exp2' for type %s.\n", debug_hlsl_type(ctx, dst_type));
+                return false;
+        }
+    }
+
+    return true;
+}
+
+static bool fold_floor(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
+        const struct hlsl_type *dst_type, const struct hlsl_ir_constant *src)
+{
+    enum hlsl_base_type type = dst_type->base_type;
+    unsigned int k;
+
+    assert(type == src->node.data_type->base_type);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        switch (type)
+        {
+            case HLSL_TYPE_FLOAT:
+            case HLSL_TYPE_HALF:
+                dst->u[k].f = floorf(src->value.u[k].f);
+                break;
+
+            default:
+                FIXME("Fold 'floor' for type %s.\n", debug_hlsl_type(ctx, dst_type));
+                return false;
+        }
+    }
+
+    return true;
+}
+
+static bool fold_fract(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
+        const struct hlsl_type *dst_type, const struct hlsl_ir_constant *src)
+{
+    enum hlsl_base_type type = dst_type->base_type;
+    unsigned int k;
+    float i;
+
+    assert(type == src->node.data_type->base_type);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        switch (type)
+        {
+            case HLSL_TYPE_FLOAT:
+            case HLSL_TYPE_HALF:
+                dst->u[k].f = modff(src->value.u[k].f, &i);
+                break;
+
+            default:
+                FIXME("Fold 'fract' for type %s.\n", debug_hlsl_type(ctx, dst_type));
+                return false;
+        }
+    }
+
+    return true;
+}
+
 static bool fold_log2(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const struct hlsl_type *dst_type,
         const struct hlsl_ir_constant *src, const struct vkd3d_shader_location *loc)
 {
@@ -231,6 +412,30 @@ static bool fold_neg(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     return true;
 }
 
+static bool fold_not(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
+        const struct hlsl_type *dst_type, const struct hlsl_ir_constant *src)
+{
+    enum hlsl_base_type type = dst_type->base_type;
+    unsigned int k;
+
+    assert(type == src->node.data_type->base_type);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        switch (type)
+        {
+            case HLSL_TYPE_BOOL:
+                dst->u[k].u = ~src->value.u[k].u;
+                break;
+
+            default:
+                FIXME("Fold logic 'not' for type %s.\n", debug_hlsl_type(ctx, dst_type));
+                return false;
+        }
+    }
+    return true;
+}
+
 static bool fold_rcp(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const struct hlsl_type *dst_type,
         const struct hlsl_ir_constant *src, const struct vkd3d_shader_location *loc)
 {
@@ -276,6 +481,72 @@ static bool fold_rcp(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     return true;
 }
 
+static bool fold_rsq(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const struct hlsl_type *dst_type,
+        const struct hlsl_ir_constant *src, const struct vkd3d_shader_location *loc)
+{
+    enum hlsl_base_type type = dst_type->base_type;
+    unsigned int k;
+
+    assert(type == src->node.data_type->base_type);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        switch (type)
+        {
+            case HLSL_TYPE_FLOAT:
+            case HLSL_TYPE_HALF:
+                if (ctx->profile->major_version >= 4)
+                {
+                    if (src->value.u[k].f < 0.0f)
+                        hlsl_warning(ctx, loc, VKD3D_SHADER_WARNING_HLSL_IMAGINARY_NUMERIC_RESULT,
+                                "Imaginary square root result.");
+                    else if (src->value.u[k].f == 0.0f)
+                        hlsl_warning(ctx, loc, VKD3D_SHADER_WARNING_HLSL_IMAGINARY_NUMERIC_RESULT,
+                                "Floating point division by zero.");
+                }
+                dst->u[k].f = 1.0f / sqrtf(src->value.u[k].f);
+                if (ctx->profile->major_version < 4 && !isfinite(dst->u[k].f))
+                {
+                    hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_NON_FINITE_RESULT,
+                            "Infinities and NaNs are not allowed by the shader model.");
+                }
+                break;
+
+            default:
+                FIXME("Fold 'rsq' for type %s.\n", debug_hlsl_type(ctx, dst_type));
+                return false;
+        }
+    }
+
+    return true;
+}
+
+static bool fold_sat(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const struct hlsl_type *dst_type,
+        const struct hlsl_ir_constant *src)
+{
+    enum hlsl_base_type type = dst_type->base_type;
+    unsigned int k;
+
+    assert(type == src->node.data_type->base_type);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        switch (type)
+        {
+            case HLSL_TYPE_FLOAT:
+            case HLSL_TYPE_HALF:
+                dst->u[k].f = min(max(0.0f, src->value.u[k].f), 1.0f);
+                break;
+
+            default:
+                FIXME("Fold 'sat' for type %s.\n", debug_hlsl_type(ctx, dst_type));
+                return false;
+        }
+    }
+
+    return true;
+}
+
 static bool fold_sqrt(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const struct hlsl_type *dst_type,
         const struct hlsl_ir_constant *src, const struct vkd3d_shader_location *loc)
 {
@@ -679,6 +950,36 @@ static bool fold_less(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, con
     return true;
 }
 
+static bool fold_lshift(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const struct hlsl_type *dst_type,
+        const struct hlsl_ir_constant *src1, const struct hlsl_ir_constant *src2)
+{
+    unsigned int k;
+
+    assert(dst_type->base_type == src1->node.data_type->base_type);
+    assert(src2->node.data_type->base_type == HLSL_TYPE_INT);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        unsigned int shift = src2->value.u[k].u % 32;
+
+        switch (src1->node.data_type->base_type)
+        {
+            case HLSL_TYPE_INT:
+                dst->u[k].i = src1->value.u[k].i << shift;
+                break;
+
+            case HLSL_TYPE_UINT:
+                dst->u[k].u = src1->value.u[k].u << shift;
+                break;
+
+            default:
+                vkd3d_unreachable();
+        }
+    }
+
+    return true;
+}
+
 static bool fold_max(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const struct hlsl_type *dst_type,
         const struct hlsl_ir_constant *src1, const struct hlsl_ir_constant *src2)
 {
@@ -869,6 +1170,70 @@ static bool fold_nequal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
     return true;
 }
 
+static bool fold_ternary(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const struct hlsl_type *dst_type,
+        const struct hlsl_ir_constant *src1, const struct hlsl_ir_constant *src2, const struct hlsl_ir_constant *src3)
+{
+    unsigned int k;
+
+    assert(dst_type->base_type == src2->node.data_type->base_type);
+    assert(dst_type->base_type == src3->node.data_type->base_type);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        switch (src1->node.data_type->base_type)
+        {
+            case HLSL_TYPE_FLOAT:
+            case HLSL_TYPE_HALF:
+                dst->u[k] = src1->value.u[k].f != 0.0f ? src2->value.u[k] : src3->value.u[k];
+                break;
+
+            case HLSL_TYPE_DOUBLE:
+                dst->u[k] = src1->value.u[k].d != 0.0 ? src2->value.u[k] : src3->value.u[k];
+                break;
+
+            case HLSL_TYPE_INT:
+            case HLSL_TYPE_UINT:
+            case HLSL_TYPE_BOOL:
+                dst->u[k] = src1->value.u[k].u ? src2->value.u[k] : src3->value.u[k];
+                break;
+
+            default:
+                vkd3d_unreachable();
+        }
+    }
+    return true;
+}
+
+static bool fold_rshift(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const struct hlsl_type *dst_type,
+        const struct hlsl_ir_constant *src1, const struct hlsl_ir_constant *src2)
+{
+    unsigned int k;
+
+    assert(dst_type->base_type == src1->node.data_type->base_type);
+    assert(src2->node.data_type->base_type == HLSL_TYPE_INT);
+
+    for (k = 0; k < dst_type->dimx; ++k)
+    {
+        unsigned int shift = src2->value.u[k].u % 32;
+
+        switch (src1->node.data_type->base_type)
+        {
+            case HLSL_TYPE_INT:
+                dst->u[k].i = src1->value.u[k].i >> shift;
+                break;
+
+            case HLSL_TYPE_UINT:
+                dst->u[k].u = src1->value.u[k].u >> shift;
+                break;
+
+            default:
+                vkd3d_unreachable();
+        }
+    }
+
+    return true;
+}
+
 bool hlsl_fold_constant_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
 {
     struct hlsl_ir_constant *arg1, *arg2 = NULL, *arg3 = NULL;
@@ -908,10 +1273,30 @@ bool hlsl_fold_constant_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
             success = fold_abs(ctx, &res, instr->data_type, arg1);
             break;
 
+        case HLSL_OP1_BIT_NOT:
+            success = fold_bit_not(ctx, &res, instr->data_type, arg1);
+            break;
+
         case HLSL_OP1_CAST:
             success = fold_cast(ctx, &res, instr->data_type, arg1);
             break;
 
+        case HLSL_OP1_CEIL:
+            success = fold_ceil(ctx, &res, instr->data_type, arg1);
+            break;
+
+        case HLSL_OP1_EXP2:
+            success = fold_exp2(ctx, &res, instr->data_type, arg1);
+            break;
+
+        case HLSL_OP1_FLOOR:
+            success = fold_floor(ctx, &res, instr->data_type, arg1);
+            break;
+
+        case HLSL_OP1_FRACT:
+            success = fold_fract(ctx, &res, instr->data_type, arg1);
+            break;
+
         case HLSL_OP1_LOG2:
             success = fold_log2(ctx, &res, instr->data_type, arg1, &instr->loc);
             break;
@@ -920,10 +1305,22 @@ bool hlsl_fold_constant_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
             success = fold_neg(ctx, &res, instr->data_type, arg1);
             break;
 
+        case HLSL_OP1_LOGIC_NOT:
+            success = fold_not(ctx, &res, instr->data_type, arg1);
+            break;
+
         case HLSL_OP1_RCP:
             success = fold_rcp(ctx, &res, instr->data_type, arg1, &instr->loc);
             break;
 
+        case HLSL_OP1_RSQ:
+            success = fold_rsq(ctx, &res, instr->data_type, arg1, &instr->loc);
+            break;
+
+        case HLSL_OP1_SAT:
+            success = fold_sat(ctx, &res, instr->data_type, arg1);
+            break;
+
         case HLSL_OP1_SQRT:
             success = fold_sqrt(ctx, &res, instr->data_type, arg1, &instr->loc);
             break;
@@ -966,6 +1363,10 @@ bool hlsl_fold_constant_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
             success = fold_less(ctx, &res, instr->data_type, arg1, arg2);
             break;
 
+        case HLSL_OP2_LSHIFT:
+            success = fold_lshift(ctx, &res, instr->data_type, arg1, arg2);
+            break;
+
         case HLSL_OP2_MAX:
             success = fold_max(ctx, &res, instr->data_type, arg1, arg2);
             break;
@@ -986,10 +1387,18 @@ bool hlsl_fold_constant_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
             success = fold_nequal(ctx, &res, instr->data_type, arg1, arg2);
             break;
 
+        case HLSL_OP2_RSHIFT:
+            success = fold_rshift(ctx, &res, instr->data_type, arg1, arg2);
+            break;
+
         case HLSL_OP3_DP2ADD:
             success = fold_dp2add(ctx, &res, instr->data_type, arg1, arg2, arg3);
             break;
 
+        case HLSL_OP3_TERNARY:
+            success = fold_ternary(ctx, &res, instr->data_type, arg1, arg2, arg3);
+            break;
+
         default:
             FIXME("Fold \"%s\" expression.\n", debug_hlsl_expr_op(expr->op));
             success = false;
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index d2bfb933edc..acdb660ea82 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -31,11 +31,9 @@ static bool shader_instruction_is_dcl(const struct vkd3d_shader_instruction *ins
 
 static void vkd3d_shader_instruction_make_nop(struct vkd3d_shader_instruction *ins)
 {
-    ins->handler_idx = VKD3DSIH_NOP;
-    ins->dst_count = 0;
-    ins->src_count = 0;
-    ins->dst = NULL;
-    ins->src = NULL;
+    struct vkd3d_shader_location location = ins->location;
+
+    vsir_instruction_init(ins, &location, VKD3DSIH_NOP);
 }
 
 static void shader_register_eliminate_phase_addressing(struct vkd3d_shader_register *reg,
@@ -64,17 +62,7 @@ static void shader_instruction_eliminate_phase_instance_id(struct vkd3d_shader_i
         reg = (struct vkd3d_shader_register *)&ins->src[i].reg;
         if (shader_register_is_phase_instance_id(reg))
         {
-            reg->type = VKD3DSPR_IMMCONST;
-            reg->precision = VKD3D_SHADER_REGISTER_PRECISION_DEFAULT;
-            reg->non_uniform = false;
-            reg->idx[0].offset = ~0u;
-            reg->idx[0].rel_addr = NULL;
-            reg->idx[1].offset = ~0u;
-            reg->idx[1].rel_addr = NULL;
-            reg->idx[2].offset = ~0u;
-            reg->idx[2].rel_addr = NULL;
-            reg->idx_count = 0;
-            reg->immconst_type = VKD3D_IMMCONST_SCALAR;
+            vsir_register_init(reg, VKD3DSPR_IMMCONST, reg->data_type, 0);
             reg->u.immconst_uint[0] = instance_id;
             continue;
         }
@@ -161,6 +149,7 @@ struct hull_flattener
     unsigned int instance_count;
     unsigned int phase_body_idx;
     enum vkd3d_shader_opcode phase;
+    struct vkd3d_shader_location last_ret_location;
 };
 
 static bool flattener_is_in_fork_or_join_phase(const struct hull_flattener *flattener)
@@ -218,10 +207,15 @@ static void flattener_eliminate_phase_related_dcls(struct hull_flattener *normal
     {
         /* Leave only the first temp declaration and set it to the max count later. */
         if (!normaliser->max_temp_count)
+        {
+            normaliser->max_temp_count = ins->declaration.count;
             normaliser->temp_dcl_idx = index;
+        }
         else
+        {
+            normaliser->max_temp_count = max(normaliser->max_temp_count, ins->declaration.count);
             vkd3d_shader_instruction_make_nop(ins);
-        normaliser->max_temp_count = max(normaliser->max_temp_count, ins->declaration.count);
+        }
         return;
     }
 
@@ -233,6 +227,7 @@ static void flattener_eliminate_phase_related_dcls(struct hull_flattener *normal
 
     if (ins->handler_idx == VKD3DSIH_RET)
     {
+        normaliser->last_ret_location = ins->location;
         vkd3d_shader_instruction_make_nop(ins);
         if (locations->count >= ARRAY_SIZE(locations->locations))
         {
@@ -296,7 +291,7 @@ static enum vkd3d_result flattener_flatten_phases(struct hull_flattener *normali
     return VKD3D_OK;
 }
 
-void shader_register_init(struct vkd3d_shader_register *reg, enum vkd3d_shader_register_type reg_type,
+void vsir_register_init(struct vkd3d_shader_register *reg, enum vkd3d_shader_register_type reg_type,
         enum vkd3d_data_type data_type, unsigned int idx_count)
 {
     reg->type = reg_type;
@@ -305,17 +300,23 @@ void shader_register_init(struct vkd3d_shader_register *reg, enum vkd3d_shader_r
     reg->data_type = data_type;
     reg->idx[0].offset = ~0u;
     reg->idx[0].rel_addr = NULL;
+    reg->idx[0].is_in_bounds = false;
     reg->idx[1].offset = ~0u;
     reg->idx[1].rel_addr = NULL;
+    reg->idx[1].is_in_bounds = false;
     reg->idx[2].offset = ~0u;
     reg->idx[2].rel_addr = NULL;
+    reg->idx[2].is_in_bounds = false;
     reg->idx_count = idx_count;
-    reg->immconst_type = VKD3D_IMMCONST_SCALAR;
+    reg->dimension = VSIR_DIMENSION_SCALAR;
+    reg->alignment = 0;
 }
 
-void shader_instruction_init(struct vkd3d_shader_instruction *ins, enum vkd3d_shader_opcode handler_idx)
+void vsir_instruction_init(struct vkd3d_shader_instruction *ins, const struct vkd3d_shader_location *location,
+        enum vkd3d_shader_opcode handler_idx)
 {
     memset(ins, 0, sizeof(*ins));
+    ins->location = *location;
     ins->handler_idx = handler_idx;
 }
 
@@ -343,7 +344,7 @@ static enum vkd3d_result instruction_array_flatten_hull_shader_phases(struct vkd
 
         if (!shader_instruction_array_reserve(&flattener.instructions, flattener.instructions.count + 1))
             return VKD3D_ERROR_OUT_OF_MEMORY;
-        shader_instruction_init(&instructions->elements[instructions->count++], VKD3DSIH_RET);
+        vsir_instruction_init(&instructions->elements[instructions->count++], &flattener.last_ret_location, VKD3DSIH_RET);
     }
 
     *src_instructions = flattener.instructions;
@@ -370,7 +371,7 @@ static struct vkd3d_shader_src_param *instruction_array_create_outpointid_param(
     if (!(rel_addr = shader_src_param_allocator_get(&instructions->src_params, 1)))
         return NULL;
 
-    shader_register_init(&rel_addr->reg, VKD3DSPR_OUTPOINTID, VKD3D_DATA_UINT, 0);
+    vsir_register_init(&rel_addr->reg, VKD3DSPR_OUTPOINTID, VKD3D_DATA_UINT, 0);
     rel_addr->swizzle = 0;
     rel_addr->modifiers = 0;
 
@@ -400,11 +401,12 @@ static void shader_dst_param_io_init(struct vkd3d_shader_dst_param *param, const
     param->write_mask = e->mask;
     param->modifiers = 0;
     param->shift = 0;
-    shader_register_init(&param->reg, reg_type, vkd3d_data_type_from_component_type(e->component_type), idx_count);
+    vsir_register_init(&param->reg, reg_type, vkd3d_data_type_from_component_type(e->component_type), idx_count);
 }
 
 static enum vkd3d_result control_point_normaliser_emit_hs_input(struct control_point_normaliser *normaliser,
-        const struct shader_signature *s, unsigned int input_control_point_count, unsigned int dst)
+        const struct shader_signature *s, unsigned int input_control_point_count, unsigned int dst,
+        const struct vkd3d_shader_location *location)
 {
     struct vkd3d_shader_instruction *ins;
     struct vkd3d_shader_dst_param *param;
@@ -422,7 +424,7 @@ static enum vkd3d_result control_point_normaliser_emit_hs_input(struct control_p
     normaliser->instructions.count += count;
 
     ins = &normaliser->instructions.elements[dst];
-    shader_instruction_init(ins, VKD3DSIH_HS_CONTROL_POINT_PHASE);
+    vsir_instruction_init(ins, location, VKD3DSIH_HS_CONTROL_POINT_PHASE);
     ins->flags = 1;
     ++ins;
 
@@ -434,19 +436,20 @@ static enum vkd3d_result control_point_normaliser_emit_hs_input(struct control_p
 
         if (e->sysval_semantic != VKD3D_SHADER_SV_NONE)
         {
-            shader_instruction_init(ins, VKD3DSIH_DCL_INPUT_SIV);
+            vsir_instruction_init(ins, location, VKD3DSIH_DCL_INPUT_SIV);
             param = &ins->declaration.register_semantic.reg;
             ins->declaration.register_semantic.sysval_semantic = vkd3d_siv_from_sysval(e->sysval_semantic);
         }
         else
         {
-            shader_instruction_init(ins, VKD3DSIH_DCL_INPUT);
+            vsir_instruction_init(ins, location, VKD3DSIH_DCL_INPUT);
             param = &ins->declaration.dst;
         }
 
         shader_dst_param_io_init(param, e, VKD3DSPR_INPUT, 2);
         param->reg.idx[0].offset = input_control_point_count;
-        param->reg.idx[1].offset = i;
+        param->reg.idx[1].offset = e->register_index;
+        param->write_mask = e->mask;
 
         ++ins;
     }
@@ -511,7 +514,7 @@ static enum vkd3d_result instruction_array_normalise_hull_shader_control_point_i
             case VKD3DSIH_HS_FORK_PHASE:
             case VKD3DSIH_HS_JOIN_PHASE:
                 ret = control_point_normaliser_emit_hs_input(&normaliser, input_signature,
-                        input_control_point_count, i);
+                        input_control_point_count, i, &ins->location);
                 *src_instructions = normaliser.instructions;
                 return ret;
             default:
@@ -547,6 +550,8 @@ struct io_normaliser
     uint8_t input_range_map[MAX_REG_OUTPUT][VKD3D_VEC4_SIZE];
     uint8_t output_range_map[MAX_REG_OUTPUT][VKD3D_VEC4_SIZE];
     uint8_t pc_range_map[MAX_REG_OUTPUT][VKD3D_VEC4_SIZE];
+
+    bool use_vocp;
 };
 
 static bool io_normaliser_is_in_fork_or_join_phase(const struct io_normaliser *normaliser)
@@ -578,6 +583,12 @@ static unsigned int shader_signature_find_element_for_reg(const struct shader_si
     vkd3d_unreachable();
 }
 
+struct signature_element *vsir_signature_find_element_for_reg(const struct shader_signature *signature,
+        unsigned int reg_idx, unsigned int write_mask)
+{
+    return &signature->elements[shader_signature_find_element_for_reg(signature, reg_idx, write_mask)];
+}
+
 static unsigned int range_map_get_register_count(uint8_t range_map[][VKD3D_VEC4_SIZE],
         unsigned int register_idx, unsigned int write_mask)
 {
@@ -816,12 +827,6 @@ static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map
     return true;
 }
 
-static bool sysval_semantic_is_tess_factor(enum vkd3d_shader_sysval_semantic sysval_semantic)
-{
-    return sysval_semantic >= VKD3D_SHADER_SV_TESS_FACTOR_QUADEDGE
-        && sysval_semantic <= VKD3D_SHADER_SV_TESS_FACTOR_LINEDEN;
-}
-
 static unsigned int shader_register_normalise_arrayed_addressing(struct vkd3d_shader_register *reg,
         unsigned int id_idx, unsigned int register_index)
 {
@@ -870,11 +875,13 @@ static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_par
     else if (reg->type == VKD3DSPR_OUTPUT || dst_param->reg.type == VKD3DSPR_COLOROUT)
     {
         signature = normaliser->output_signature;
+        reg->type = VKD3DSPR_OUTPUT;
         dcl_params = normaliser->output_dcl_params;
     }
     else if (dst_param->reg.type == VKD3DSPR_INCONTROLPOINT || dst_param->reg.type == VKD3DSPR_INPUT)
     {
         signature = normaliser->input_signature;
+        reg->type = VKD3DSPR_INPUT;
         dcl_params = normaliser->input_dcl_params;
     }
     else
@@ -922,7 +929,7 @@ static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_par
         id_idx = 1;
     }
 
-    if ((e->register_count > 1 || sysval_semantic_is_tess_factor(e->sysval_semantic)))
+    if ((e->register_count > 1 || vsir_sysval_semantic_is_tess_factor(e->sysval_semantic)))
     {
         if (is_io_dcl)
         {
@@ -974,15 +981,13 @@ static void shader_src_param_io_normalise(struct vkd3d_shader_src_param *src_par
             signature = normaliser->patch_constant_signature;
             break;
         case VKD3DSPR_INCONTROLPOINT:
-            if (normaliser->shader_type == VKD3D_SHADER_TYPE_HULL)
-                reg->type = VKD3DSPR_INPUT;
+            reg->type = VKD3DSPR_INPUT;
             /* fall through */
         case VKD3DSPR_INPUT:
             signature = normaliser->input_signature;
             break;
         case VKD3DSPR_OUTCONTROLPOINT:
-            if (normaliser->shader_type == VKD3D_SHADER_TYPE_HULL)
-                reg->type = VKD3DSPR_OUTPUT;
+            reg->type = VKD3DSPR_OUTPUT;
             /* fall through */
         case VKD3DSPR_OUTPUT:
             signature = normaliser->output_signature;
@@ -997,7 +1002,7 @@ static void shader_src_param_io_normalise(struct vkd3d_shader_src_param *src_par
     element_idx = shader_signature_find_element_for_reg(signature, reg_idx, write_mask);
 
     e = &signature->elements[element_idx];
-    if ((e->register_count > 1 || sysval_semantic_is_tess_factor(e->sysval_semantic)))
+    if ((e->register_count > 1 || vsir_sysval_semantic_is_tess_factor(e->sysval_semantic)))
         id_idx = shader_register_normalise_arrayed_addressing(reg, id_idx, e->register_index);
     reg->idx[id_idx].offset = element_idx;
     reg->idx_count = id_idx + 1;
@@ -1014,7 +1019,6 @@ static void shader_instruction_normalise_io_params(struct vkd3d_shader_instructi
         struct io_normaliser *normaliser)
 {
     struct vkd3d_shader_register *reg;
-    bool keep = true;
     unsigned int i;
 
     switch (ins->handler_idx)
@@ -1023,6 +1027,10 @@ static void shader_instruction_normalise_io_params(struct vkd3d_shader_instructi
             if (normaliser->shader_type == VKD3D_SHADER_TYPE_HULL)
             {
                 reg = &ins->declaration.dst.reg;
+
+                if (reg->type == VKD3DSPR_OUTCONTROLPOINT)
+                    normaliser->use_vocp = true;
+
                 /* We don't need to keep OUTCONTROLPOINT or PATCHCONST input declarations since their
                 * equivalents were declared earlier, but INCONTROLPOINT may be the first occurrence. */
                 if (reg->type == VKD3DSPR_OUTCONTROLPOINT || reg->type == VKD3DSPR_PATCHCONST)
@@ -1033,15 +1041,16 @@ static void shader_instruction_normalise_io_params(struct vkd3d_shader_instructi
             /* fall through */
         case VKD3DSIH_DCL_INPUT_PS:
         case VKD3DSIH_DCL_OUTPUT:
-            keep = shader_dst_param_io_normalise(&ins->declaration.dst, true, normaliser);
+            if (!shader_dst_param_io_normalise(&ins->declaration.dst, true, normaliser))
+                vkd3d_shader_instruction_make_nop(ins);
             break;
         case VKD3DSIH_DCL_INPUT_SGV:
         case VKD3DSIH_DCL_INPUT_SIV:
         case VKD3DSIH_DCL_INPUT_PS_SGV:
         case VKD3DSIH_DCL_INPUT_PS_SIV:
         case VKD3DSIH_DCL_OUTPUT_SIV:
-            keep = shader_dst_param_io_normalise(&ins->declaration.register_semantic.reg, true,
-                    normaliser);
+            if (!shader_dst_param_io_normalise(&ins->declaration.register_semantic.reg, true, normaliser))
+                vkd3d_shader_instruction_make_nop(ins);
             break;
         case VKD3DSIH_HS_CONTROL_POINT_PHASE:
         case VKD3DSIH_HS_FORK_PHASE:
@@ -1060,29 +1069,24 @@ static void shader_instruction_normalise_io_params(struct vkd3d_shader_instructi
                 shader_src_param_io_normalise((struct vkd3d_shader_src_param *)&ins->src[i], normaliser);
             break;
     }
-
-    if (!keep)
-        shader_instruction_init(ins, VKD3DSIH_NOP);
 }
 
-static enum vkd3d_result instruction_array_normalise_io_registers(struct vkd3d_shader_instruction_array *instructions,
-        enum vkd3d_shader_type shader_type, struct shader_signature *input_signature,
-        struct shader_signature *output_signature, struct shader_signature *patch_constant_signature)
+static enum vkd3d_result shader_normalise_io_registers(struct vkd3d_shader_parser *parser)
 {
-    struct io_normaliser normaliser = {*instructions};
+    struct io_normaliser normaliser = {parser->instructions};
     struct vkd3d_shader_instruction *ins;
     bool has_control_point_phase;
     unsigned int i, j;
 
     normaliser.phase = VKD3DSIH_INVALID;
-    normaliser.shader_type = shader_type;
-    normaliser.input_signature = input_signature;
-    normaliser.output_signature = output_signature;
-    normaliser.patch_constant_signature = patch_constant_signature;
+    normaliser.shader_type = parser->shader_version.type;
+    normaliser.input_signature = &parser->shader_desc.input_signature;
+    normaliser.output_signature = &parser->shader_desc.output_signature;
+    normaliser.patch_constant_signature = &parser->shader_desc.patch_constant_signature;
 
-    for (i = 0, has_control_point_phase = false; i < instructions->count; ++i)
+    for (i = 0, has_control_point_phase = false; i < parser->instructions.count; ++i)
     {
-        ins = &instructions->elements[i];
+        ins = &parser->instructions.elements[i];
 
         switch (ins->handler_idx)
         {
@@ -1121,11 +1125,11 @@ static enum vkd3d_result instruction_array_normalise_io_registers(struct vkd3d_s
         }
     }
 
-    if (!shader_signature_merge(input_signature, normaliser.input_range_map, false)
-            || !shader_signature_merge(output_signature, normaliser.output_range_map, false)
-            || !shader_signature_merge(patch_constant_signature, normaliser.pc_range_map, true))
+    if (!shader_signature_merge(&parser->shader_desc.input_signature, normaliser.input_range_map, false)
+            || !shader_signature_merge(&parser->shader_desc.output_signature, normaliser.output_range_map, false)
+            || !shader_signature_merge(&parser->shader_desc.patch_constant_signature, normaliser.pc_range_map, true))
     {
-        *instructions = normaliser.instructions;
+        parser->instructions = normaliser.instructions;
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
 
@@ -1133,7 +1137,8 @@ static enum vkd3d_result instruction_array_normalise_io_registers(struct vkd3d_s
     for (i = 0; i < normaliser.instructions.count; ++i)
         shader_instruction_normalise_io_params(&normaliser.instructions.elements[i], &normaliser);
 
-    *instructions = normaliser.instructions;
+    parser->instructions = normaliser.instructions;
+    parser->shader_desc.use_vocp = normaliser.use_vocp;
     return VKD3D_OK;
 }
 
@@ -1207,7 +1212,7 @@ static void shader_register_normalise_flat_constants(struct vkd3d_shader_src_par
         {
             param->reg.type = VKD3DSPR_IMMCONST;
             param->reg.idx_count = 0;
-            param->reg.immconst_type = VKD3D_IMMCONST_VEC4;
+            param->reg.dimension = VSIR_DIMENSION_VEC4;
             for (j = 0; j < 4; ++j)
                 param->reg.u.immconst_uint[j] = normaliser->defs[i].value[j];
             return;
@@ -1260,6 +1265,164 @@ static enum vkd3d_result instruction_array_normalise_flat_constants(struct vkd3d
     return VKD3D_OK;
 }
 
+static void remove_dead_code(struct vkd3d_shader_parser *parser)
+{
+    size_t i, depth = 0;
+    bool dead = false;
+
+    for (i = 0; i < parser->instructions.count; ++i)
+    {
+        struct vkd3d_shader_instruction *ins = &parser->instructions.elements[i];
+
+        switch (ins->handler_idx)
+        {
+            case VKD3DSIH_IF:
+            case VKD3DSIH_LOOP:
+            case VKD3DSIH_SWITCH:
+                if (dead)
+                {
+                    vkd3d_shader_instruction_make_nop(ins);
+                    ++depth;
+                }
+                break;
+
+            case VKD3DSIH_ENDIF:
+            case VKD3DSIH_ENDLOOP:
+            case VKD3DSIH_ENDSWITCH:
+            case VKD3DSIH_ELSE:
+                if (dead)
+                {
+                    if (depth > 0)
+                    {
+                        if (ins->handler_idx != VKD3DSIH_ELSE)
+                            --depth;
+                        vkd3d_shader_instruction_make_nop(ins);
+                    }
+                    else
+                    {
+                        dead = false;
+                    }
+                }
+                break;
+
+            /* `depth' is counted with respect to where the dead code
+             * segment began. So it starts at zero and it signals the
+             * termination of the dead code segment when it would
+             * become negative. */
+            case VKD3DSIH_BREAK:
+            case VKD3DSIH_RET:
+            case VKD3DSIH_CONTINUE:
+                if (dead)
+                {
+                    vkd3d_shader_instruction_make_nop(ins);
+                }
+                else
+                {
+                    dead = true;
+                    depth = 0;
+                }
+                break;
+
+            /* If `case' or `default' appears at zero depth, it means
+             * that they are a possible target for the corresponding
+             * switch, so the code is live again. */
+            case VKD3DSIH_CASE:
+            case VKD3DSIH_DEFAULT:
+                if (dead)
+                {
+                    if (depth == 0)
+                        dead = false;
+                    else
+                        vkd3d_shader_instruction_make_nop(ins);
+                }
+                break;
+
+            /* Phase instructions can only appear in hull shaders and
+             * outside of any block. When a phase returns, control is
+             * moved to the following phase, so they make code live
+             * again. */
+            case VKD3DSIH_HS_CONTROL_POINT_PHASE:
+            case VKD3DSIH_HS_FORK_PHASE:
+            case VKD3DSIH_HS_JOIN_PHASE:
+                dead = false;
+                break;
+
+            default:
+                if (dead)
+                    vkd3d_shader_instruction_make_nop(ins);
+                break;
+        }
+    }
+}
+
+static enum vkd3d_result normalise_combined_samplers(struct vkd3d_shader_parser *parser)
+{
+    unsigned int i;
+
+    for (i = 0; i < parser->instructions.count; ++i)
+    {
+        struct vkd3d_shader_instruction *ins = &parser->instructions.elements[i];
+        struct vkd3d_shader_src_param *srcs;
+
+        switch (ins->handler_idx)
+        {
+            case VKD3DSIH_TEX:
+                if (!(srcs = shader_src_param_allocator_get(&parser->instructions.src_params, 3)))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+                memset(srcs, 0, sizeof(*srcs) * 3);
+
+                ins->handler_idx = VKD3DSIH_SAMPLE;
+
+                srcs[0] = ins->src[0];
+
+                srcs[1].reg.type = VKD3DSPR_RESOURCE;
+                srcs[1].reg.idx[0] = ins->src[1].reg.idx[0];
+                srcs[1].reg.idx[1] = ins->src[1].reg.idx[0];
+                srcs[1].reg.idx_count = 2;
+                srcs[1].reg.data_type = VKD3D_DATA_RESOURCE;
+                srcs[1].swizzle = VKD3D_SHADER_NO_SWIZZLE;
+
+                srcs[2].reg.type = VKD3DSPR_SAMPLER;
+                srcs[2].reg.idx[0] = ins->src[1].reg.idx[0];
+                srcs[2].reg.idx[1] = ins->src[1].reg.idx[0];
+                srcs[2].reg.idx_count = 2;
+                srcs[2].reg.data_type = VKD3D_DATA_SAMPLER;
+
+                ins->src = srcs;
+                ins->src_count = 3;
+                break;
+
+            case VKD3DSIH_TEXBEM:
+            case VKD3DSIH_TEXBEML:
+            case VKD3DSIH_TEXCOORD:
+            case VKD3DSIH_TEXDEPTH:
+            case VKD3DSIH_TEXDP3:
+            case VKD3DSIH_TEXDP3TEX:
+            case VKD3DSIH_TEXLDD:
+            case VKD3DSIH_TEXLDL:
+            case VKD3DSIH_TEXM3x2PAD:
+            case VKD3DSIH_TEXM3x2TEX:
+            case VKD3DSIH_TEXM3x3DIFF:
+            case VKD3DSIH_TEXM3x3PAD:
+            case VKD3DSIH_TEXM3x3SPEC:
+            case VKD3DSIH_TEXM3x3TEX:
+            case VKD3DSIH_TEXM3x3VSPEC:
+            case VKD3DSIH_TEXREG2AR:
+            case VKD3DSIH_TEXREG2GB:
+            case VKD3DSIH_TEXREG2RGB:
+                vkd3d_shader_parser_error(parser, VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED,
+                        "Aborting due to not yet implemented feature: "
+                        "Combined sampler instruction %#x.", ins->handler_idx);
+                return VKD3D_ERROR_NOT_IMPLEMENTED;
+
+            default:
+                break;
+        }
+    }
+
+    return VKD3D_OK;
+}
+
 enum vkd3d_result vkd3d_shader_normalise(struct vkd3d_shader_parser *parser,
         const struct vkd3d_shader_compile_info *compile_info)
 {
@@ -1280,15 +1443,366 @@ enum vkd3d_result vkd3d_shader_normalise(struct vkd3d_shader_parser *parser,
                 &parser->shader_desc.input_signature);
     }
     if (result >= 0)
-        result = instruction_array_normalise_io_registers(instructions, parser->shader_version.type,
-                &parser->shader_desc.input_signature, &parser->shader_desc.output_signature,
-                &parser->shader_desc.patch_constant_signature);
+        result = shader_normalise_io_registers(parser);
 
     if (result >= 0)
         result = instruction_array_normalise_flat_constants(parser);
 
+    if (result >= 0)
+        remove_dead_code(parser);
+
+    if (result >= 0)
+        result = normalise_combined_samplers(parser);
+
     if (result >= 0 && TRACE_ON())
         vkd3d_shader_trace(instructions, &parser->shader_version);
 
+    if (result >= 0 && !parser->failed)
+        vsir_validate(parser);
+
+    if (result >= 0 && parser->failed)
+        result = VKD3D_ERROR_INVALID_SHADER;
+
     return result;
 }
+
+struct validation_context
+{
+    struct vkd3d_shader_parser *parser;
+    size_t instruction_idx;
+    bool dcl_temps_found;
+    unsigned int temp_count;
+    enum vkd3d_shader_opcode phase;
+
+    enum vkd3d_shader_opcode *blocks;
+    size_t depth;
+    size_t blocks_capacity;
+};
+
+static void VKD3D_PRINTF_FUNC(3, 4) validator_error(struct validation_context *ctx,
+        enum vkd3d_shader_error error, const char *format, ...)
+{
+    struct vkd3d_string_buffer buf;
+    va_list args;
+
+    vkd3d_string_buffer_init(&buf);
+
+    va_start(args, format);
+    vkd3d_string_buffer_vprintf(&buf, format, args);
+    va_end(args);
+
+    vkd3d_shader_parser_error(ctx->parser, error, "instruction %zu: %s", ctx->instruction_idx + 1, buf.buffer);
+    ERR("VSIR validation error: instruction %zu: %s\n", ctx->instruction_idx + 1, buf.buffer);
+
+    vkd3d_string_buffer_cleanup(&buf);
+}
+
+static void vsir_validate_src_param(struct validation_context *ctx,
+        const struct vkd3d_shader_src_param *src);
+
+static void vsir_validate_register(struct validation_context *ctx,
+        const struct vkd3d_shader_register *reg)
+{
+    unsigned int i, temp_count = ctx->temp_count;
+
+    /* SM1-3 shaders do not include a DCL_TEMPS instruction. */
+    if (ctx->parser->shader_version.major <= 3)
+        temp_count = ctx->parser->shader_desc.temp_count;
+
+    if (reg->type >= VKD3DSPR_COUNT)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE, "Invalid register type %#x.",
+                reg->type);
+
+    if (reg->precision >= VKD3D_SHADER_REGISTER_PRECISION_COUNT)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_PRECISION, "Invalid register precision %#x.",
+                reg->precision);
+
+    if (reg->data_type >= VKD3D_DATA_COUNT)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE, "Invalid register data type %#x.",
+                reg->data_type);
+
+    if (reg->dimension >= VSIR_DIMENSION_COUNT)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION, "Invalid register dimension %#x.",
+                reg->dimension);
+
+    if (reg->idx_count > ARRAY_SIZE(reg->idx))
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT, "Invalid register index count %u.",
+                reg->idx_count);
+
+    for (i = 0; i < min(reg->idx_count, ARRAY_SIZE(reg->idx)); ++i)
+    {
+        const struct vkd3d_shader_src_param *param = reg->idx[i].rel_addr;
+        if (reg->idx[i].rel_addr)
+            vsir_validate_src_param(ctx, param);
+    }
+
+    switch (reg->type)
+    {
+        case VKD3DSPR_TEMP:
+            if (reg->idx_count != 1)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT, "Invalid index count %u for a TEMP register.",
+                        reg->idx_count);
+
+            if (reg->idx_count >= 1 && reg->idx[0].rel_addr)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX, "Non-NULL relative address for a TEMP register.");
+
+            if (reg->idx_count >= 1 && reg->idx[0].offset >= temp_count)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX, "TEMP register index %u exceeds the maximum count %u.",
+                        reg->idx[0].offset, temp_count);
+            break;
+
+        case VKD3DSPR_NULL:
+            if (reg->idx_count != 0)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT, "Invalid index count %u for a NULL register.",
+                        reg->idx_count);
+            break;
+
+        case VKD3DSPR_IMMCONST:
+            if (reg->idx_count != 0)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT, "Invalid index count %u for a IMMCONST register.",
+                        reg->idx_count);
+            break;
+
+        case VKD3DSPR_IMMCONST64:
+            if (reg->idx_count != 0)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT, "Invalid index count %u for a IMMCONST64 register.",
+                        reg->idx_count);
+            break;
+
+        default:
+            break;
+    }
+}
+
+static void vsir_validate_dst_param(struct validation_context *ctx,
+        const struct vkd3d_shader_dst_param *dst)
+{
+    vsir_validate_register(ctx, &dst->reg);
+
+    if (dst->write_mask & ~VKD3DSP_WRITEMASK_ALL)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK, "Destination has invalid write mask %#x.",
+                dst->write_mask);
+
+    if (dst->modifiers & ~VKD3DSPDM_MASK)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_MODIFIERS, "Destination has invalid modifiers %#x.",
+                dst->modifiers);
+
+    switch (dst->shift)
+    {
+        case 0:
+        case 1:
+        case 2:
+        case 3:
+        case 13:
+        case 14:
+        case 15:
+            break;
+
+        default:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SHIFT, "Destination has invalid shift %#x.",
+                    dst->shift);
+    }
+}
+
+static void vsir_validate_src_param(struct validation_context *ctx,
+        const struct vkd3d_shader_src_param *src)
+{
+    vsir_validate_register(ctx, &src->reg);
+
+    if (src->swizzle & ~0x03030303u)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SWIZZLE, "Source has invalid swizzle %#x.",
+                src->swizzle);
+
+    if (src->modifiers >= VKD3DSPSM_COUNT)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_MODIFIERS, "Source has invalid modifiers %#x.",
+                src->modifiers);
+}
+
+static void vsir_validate_dst_count(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction, unsigned int count)
+{
+    if (instruction->dst_count != count)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DEST_COUNT,
+                "Invalid destination count %u for an instruction of type %#x, expected %u.",
+                        instruction->dst_count, instruction->handler_idx, count);
+}
+
+static void vsir_validate_src_count(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction, unsigned int count)
+{
+    if (instruction->src_count != count)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SOURCE_COUNT,
+                "Invalid source count %u for an instruction of type %#x, expected %u.",
+                instruction->src_count, instruction->handler_idx, count);
+}
+
+static void vsir_validate_instruction(struct validation_context *ctx)
+{
+    const struct vkd3d_shader_instruction *instruction = &ctx->parser->instructions.elements[ctx->instruction_idx];
+    size_t i;
+
+    ctx->parser->location = instruction->location;
+
+    for (i = 0; i < instruction->dst_count; ++i)
+        vsir_validate_dst_param(ctx, &instruction->dst[i]);
+
+    for (i = 0; i < instruction->src_count; ++i)
+        vsir_validate_src_param(ctx, &instruction->src[i]);
+
+    if (instruction->handler_idx >= VKD3DSIH_INVALID)
+    {
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_HANDLER, "Invalid instruction handler %#x.",
+                instruction->handler_idx);
+    }
+
+    switch (instruction->handler_idx)
+    {
+        case VKD3DSIH_HS_DECLS:
+        case VKD3DSIH_HS_CONTROL_POINT_PHASE:
+        case VKD3DSIH_HS_FORK_PHASE:
+        case VKD3DSIH_HS_JOIN_PHASE:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 0);
+            if (ctx->parser->shader_version.type != VKD3D_SHADER_TYPE_HULL)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_HANDLER, "Phase instruction %#x is only valid in a hull shader.",
+                        instruction->handler_idx);
+            if (ctx->depth != 0)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "Phase instruction %#x must appear to top level.",
+                        instruction->handler_idx);
+            ctx->phase = instruction->handler_idx;
+            ctx->dcl_temps_found = false;
+            ctx->temp_count = 0;
+            return;
+
+        default:
+            break;
+    }
+
+    if (ctx->parser->shader_version.type == VKD3D_SHADER_TYPE_HULL &&
+            ctx->phase == VKD3DSIH_INVALID)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_HANDLER, "Instruction %#x appear before any phase instruction in a hull shader.",
+                instruction->handler_idx);
+
+    switch (instruction->handler_idx)
+    {
+        case VKD3DSIH_DCL_TEMPS:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 0);
+            if (ctx->dcl_temps_found)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_DUPLICATE_DCL_TEMPS, "Duplicate DCL_TEMPS instruction.");
+            if (instruction->declaration.count > ctx->parser->shader_desc.temp_count)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DCL_TEMPS, "Invalid DCL_TEMPS count %u, expected at most %u.",
+                        instruction->declaration.count, ctx->parser->shader_desc.temp_count);
+            ctx->dcl_temps_found = true;
+            ctx->temp_count = instruction->declaration.count;
+            break;
+
+        case VKD3DSIH_IF:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 1);
+            if (!vkd3d_array_reserve((void **)&ctx->blocks, &ctx->blocks_capacity, ctx->depth + 1, sizeof(*ctx->blocks)))
+                return;
+            ctx->blocks[ctx->depth++] = instruction->handler_idx;
+            break;
+
+        case VKD3DSIH_IFC:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 2);
+            if (!vkd3d_array_reserve((void **)&ctx->blocks, &ctx->blocks_capacity, ctx->depth + 1, sizeof(*ctx->blocks)))
+                return;
+            ctx->blocks[ctx->depth++] = VKD3DSIH_IF;
+            break;
+
+        case VKD3DSIH_ELSE:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 0);
+            if (ctx->depth == 0 || ctx->blocks[ctx->depth - 1] != VKD3DSIH_IF)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "ELSE instruction doesn't terminate IF block.");
+            else
+                ctx->blocks[ctx->depth - 1] = instruction->handler_idx;
+            break;
+
+        case VKD3DSIH_ENDIF:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 0);
+            if (ctx->depth == 0 || (ctx->blocks[ctx->depth - 1] != VKD3DSIH_IF && ctx->blocks[ctx->depth - 1] != VKD3DSIH_ELSE))
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "ENDIF instruction doesn't terminate IF/ELSE block.");
+            else
+                --ctx->depth;
+            break;
+
+        case VKD3DSIH_LOOP:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, ctx->parser->shader_version.major <= 3 ? 2 : 0);
+            if (!vkd3d_array_reserve((void **)&ctx->blocks, &ctx->blocks_capacity, ctx->depth + 1, sizeof(*ctx->blocks)))
+                return;
+            ctx->blocks[ctx->depth++] = instruction->handler_idx;
+            break;
+
+        case VKD3DSIH_ENDLOOP:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 0);
+            if (ctx->depth == 0 || ctx->blocks[ctx->depth - 1] != VKD3DSIH_LOOP)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "ENDLOOP instruction doesn't terminate LOOP block.");
+            else
+                --ctx->depth;
+            break;
+
+        case VKD3DSIH_REP:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 1);
+            if (!vkd3d_array_reserve((void **)&ctx->blocks, &ctx->blocks_capacity, ctx->depth + 1, sizeof(*ctx->blocks)))
+                return;
+            ctx->blocks[ctx->depth++] = instruction->handler_idx;
+            break;
+
+        case VKD3DSIH_ENDREP:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 0);
+            if (ctx->depth == 0 || ctx->blocks[ctx->depth - 1] != VKD3DSIH_REP)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "ENDREP instruction doesn't terminate REP block.");
+            else
+                --ctx->depth;
+            break;
+
+        case VKD3DSIH_SWITCH:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 1);
+            if (!vkd3d_array_reserve((void **)&ctx->blocks, &ctx->blocks_capacity, ctx->depth + 1, sizeof(*ctx->blocks)))
+                return;
+            ctx->blocks[ctx->depth++] = instruction->handler_idx;
+            break;
+
+        case VKD3DSIH_ENDSWITCH:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 0);
+            if (ctx->depth == 0 || ctx->blocks[ctx->depth - 1] != VKD3DSIH_SWITCH)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "ENDSWITCH instruction doesn't terminate SWITCH block.");
+            else
+                --ctx->depth;
+            break;
+
+        default:
+            break;
+    }
+}
+
+void vsir_validate(struct vkd3d_shader_parser *parser)
+{
+    struct validation_context ctx =
+    {
+        .parser = parser,
+        .phase = VKD3DSIH_INVALID,
+    };
+
+    if (!(parser->config_flags & VKD3D_SHADER_CONFIG_FLAG_FORCE_VALIDATION))
+        return;
+
+    for (ctx.instruction_idx = 0; ctx.instruction_idx < parser->instructions.count; ++ctx.instruction_idx)
+        vsir_validate_instruction(&ctx);
+
+    if (ctx.depth != 0)
+        validator_error(&ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "%zu nested blocks were not closed.", ctx.depth);
+
+    free(ctx.blocks);
+}
diff --git a/libs/vkd3d/libs/vkd3d-shader/preproc.h b/libs/vkd3d/libs/vkd3d-shader/preproc.h
index 4860cf5f90e..e1cb75e177c 100644
--- a/libs/vkd3d/libs/vkd3d-shader/preproc.h
+++ b/libs/vkd3d/libs/vkd3d-shader/preproc.h
@@ -22,7 +22,7 @@
 #define __VKD3D_SHADER_PREPROC_H
 
 #include "vkd3d_shader_private.h"
-#include "wine/rbtree.h"
+#include "rbtree.h"
 
 struct preproc_if_state
 {
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index 638764b81bc..be149a0cf34 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -18,7 +18,7 @@
  */
 
 #include "vkd3d_shader_private.h"
-#include "wine/rbtree.h"
+#include "rbtree.h"
 
 #include <stdarg.h>
 #include <stdio.h>
@@ -173,7 +173,13 @@ enum vkd3d_shader_input_sysval_semantic vkd3d_siv_from_sysval_indexed(enum vkd3d
 {
     switch (sysval)
     {
+        case VKD3D_SHADER_SV_COVERAGE:
+        case VKD3D_SHADER_SV_DEPTH:
+        case VKD3D_SHADER_SV_DEPTH_GREATER_EQUAL:
+        case VKD3D_SHADER_SV_DEPTH_LESS_EQUAL:
         case VKD3D_SHADER_SV_NONE:
+        case VKD3D_SHADER_SV_STENCIL_REF:
+        case VKD3D_SHADER_SV_TARGET:
             return VKD3D_SIV_NONE;
         case VKD3D_SHADER_SV_POSITION:
             return VKD3D_SIV_POSITION;
@@ -181,6 +187,16 @@ enum vkd3d_shader_input_sysval_semantic vkd3d_siv_from_sysval_indexed(enum vkd3d
             return VKD3D_SIV_CLIP_DISTANCE;
         case VKD3D_SHADER_SV_CULL_DISTANCE:
             return VKD3D_SIV_CULL_DISTANCE;
+        case VKD3D_SHADER_SV_INSTANCE_ID:
+            return VKD3D_SIV_INSTANCE_ID;
+        case VKD3D_SHADER_SV_IS_FRONT_FACE:
+            return VKD3D_SIV_IS_FRONT_FACE;
+        case VKD3D_SHADER_SV_PRIMITIVE_ID:
+            return VKD3D_SIV_PRIMITIVE_ID;
+        case VKD3D_SHADER_SV_RENDER_TARGET_ARRAY_INDEX:
+            return VKD3D_SIV_RENDER_TARGET_ARRAY_INDEX;
+        case VKD3D_SHADER_SV_SAMPLE_INDEX:
+            return VKD3D_SIV_SAMPLE_INDEX;
         case VKD3D_SHADER_SV_TESS_FACTOR_QUADEDGE:
             return VKD3D_SIV_QUAD_U0_TESS_FACTOR + index;
         case VKD3D_SHADER_SV_TESS_FACTOR_QUADINT:
@@ -193,6 +209,10 @@ enum vkd3d_shader_input_sysval_semantic vkd3d_siv_from_sysval_indexed(enum vkd3d
             return VKD3D_SIV_LINE_DETAIL_TESS_FACTOR;
         case VKD3D_SHADER_SV_TESS_FACTOR_LINEDEN:
             return VKD3D_SIV_LINE_DENSITY_TESS_FACTOR;
+        case VKD3D_SHADER_SV_VERTEX_ID:
+            return VKD3D_SIV_VERTEX_ID;
+        case VKD3D_SHADER_SV_VIEWPORT_ARRAY_INDEX:
+            return VKD3D_SIV_VIEWPORT_ARRAY_INDEX;
         default:
             FIXME("Unhandled sysval %#x, index %u.\n", sysval, index);
             return VKD3D_SIV_NONE;
@@ -1130,6 +1150,20 @@ static uint32_t vkd3d_spirv_get_op_type_pointer(struct vkd3d_spirv_builder *buil
             vkd3d_spirv_build_op_type_pointer);
 }
 
+static uint32_t vkd3d_spirv_build_op_constant_bool(struct vkd3d_spirv_builder *builder,
+        uint32_t result_type, uint32_t value)
+{
+    return vkd3d_spirv_build_op_tr(builder, &builder->global_stream,
+            value ? SpvOpConstantTrue : SpvOpConstantFalse, result_type);
+}
+
+static uint32_t vkd3d_spirv_get_op_constant_bool(struct vkd3d_spirv_builder *builder,
+        uint32_t result_type, uint32_t value)
+{
+    return vkd3d_spirv_build_once2(builder, value ? SpvOpConstantTrue : SpvOpConstantFalse, result_type, value,
+            vkd3d_spirv_build_op_constant_bool);
+}
+
 /* Types larger than 32-bits are not supported. */
 static uint32_t vkd3d_spirv_build_op_constant(struct vkd3d_spirv_builder *builder,
         uint32_t result_type, uint32_t value)
@@ -1215,10 +1249,14 @@ static uint32_t vkd3d_spirv_build_op_function_call(struct vkd3d_spirv_builder *b
             SpvOpFunctionCall, result_type, function_id, arguments, argument_count);
 }
 
-static uint32_t vkd3d_spirv_build_op_undef(struct vkd3d_spirv_builder *builder,
-        struct vkd3d_spirv_stream *stream, uint32_t type_id)
+static uint32_t vkd3d_spirv_build_op_undef(struct vkd3d_spirv_builder *builder, uint32_t type_id)
+{
+    return vkd3d_spirv_build_op_tr(builder, &builder->global_stream, SpvOpUndef, type_id);
+}
+
+static uint32_t vkd3d_spirv_get_op_undef(struct vkd3d_spirv_builder *builder, uint32_t type_id)
 {
-    return vkd3d_spirv_build_op_tr(builder, stream, SpvOpUndef, type_id);
+    return vkd3d_spirv_build_once1(builder, SpvOpUndef, type_id, vkd3d_spirv_build_op_undef);
 }
 
 static uint32_t vkd3d_spirv_build_op_access_chain(struct vkd3d_spirv_builder *builder,
@@ -1407,13 +1445,6 @@ static uint32_t vkd3d_spirv_build_op_udiv(struct vkd3d_spirv_builder *builder,
             SpvOpUDiv, result_type, operand0, operand1);
 }
 
-static uint32_t vkd3d_spirv_build_op_umod(struct vkd3d_spirv_builder *builder,
-        uint32_t result_type, uint32_t operand0, uint32_t operand1)
-{
-    return vkd3d_spirv_build_op_tr2(builder, &builder->function_stream,
-            SpvOpUMod, result_type, operand0, operand1);
-}
-
 static uint32_t vkd3d_spirv_build_op_isub(struct vkd3d_spirv_builder *builder,
         uint32_t result_type, uint32_t operand0, uint32_t operand1)
 {
@@ -1710,6 +1741,15 @@ static uint32_t vkd3d_spirv_build_op_glsl_std450_cos(struct vkd3d_spirv_builder
     return vkd3d_spirv_build_op_glsl_std450_tr1(builder, GLSLstd450Cos, result_type, operand);
 }
 
+static uint32_t vkd3d_spirv_build_op_glsl_std450_max(struct vkd3d_spirv_builder *builder,
+        uint32_t result_type, uint32_t x, uint32_t y)
+{
+    uint32_t glsl_std450_id = vkd3d_spirv_get_glsl_std450_instr_set(builder);
+    uint32_t operands[] = {x, y};
+    return vkd3d_spirv_build_op_ext_inst(builder, result_type, glsl_std450_id,
+            GLSLstd450NMax, operands, ARRAY_SIZE(operands));
+}
+
 static uint32_t vkd3d_spirv_build_op_glsl_std450_nclamp(struct vkd3d_spirv_builder *builder,
         uint32_t result_type, uint32_t x, uint32_t min, uint32_t max)
 {
@@ -1776,6 +1816,8 @@ static uint32_t vkd3d_spirv_get_type_id_for_data_type(struct vkd3d_spirv_builder
                 break;
             case VKD3D_DATA_DOUBLE:
                 return vkd3d_spirv_get_op_type_float(builder, 64);
+            case VKD3D_DATA_BOOL:
+                return vkd3d_spirv_get_op_type_bool(builder);
             default:
                 FIXME("Unhandled data type %#x.\n", data_type);
                 return 0;
@@ -2099,14 +2141,22 @@ static void vkd3d_symbol_make_register(struct vkd3d_symbol *symbol,
     symbol->type = VKD3D_SYMBOL_REGISTER;
     memset(&symbol->key, 0, sizeof(symbol->key));
     symbol->key.reg.type = reg->type;
-    if (vkd3d_shader_register_is_input(reg) || vkd3d_shader_register_is_output(reg)
-            || vkd3d_shader_register_is_patch_constant(reg))
+
+    switch (reg->type)
     {
-        symbol->key.reg.idx = reg->idx_count ? reg->idx[reg->idx_count - 1].offset : ~0u;
-        assert(!reg->idx_count || symbol->key.reg.idx != ~0u);
+        case VKD3DSPR_INPUT:
+        case VKD3DSPR_OUTPUT:
+        case VKD3DSPR_PATCHCONST:
+            symbol->key.reg.idx = reg->idx_count ? reg->idx[reg->idx_count - 1].offset : ~0u;
+            assert(!reg->idx_count || symbol->key.reg.idx != ~0u);
+            break;
+
+        case VKD3DSPR_IMMCONSTBUFFER:
+            break;
+
+        default:
+            symbol->key.reg.idx = reg->idx_count ? reg->idx[0].offset : ~0u;
     }
-    else if (reg->type != VKD3DSPR_IMMCONSTBUFFER)
-        symbol->key.reg.idx = reg->idx_count ? reg->idx[0].offset : ~0u;
 }
 
 static void vkd3d_symbol_set_register_info(struct vkd3d_symbol *symbol,
@@ -2251,6 +2301,12 @@ struct vkd3d_hull_shader_variables
     uint32_t patch_constants_id;
 };
 
+struct ssa_register_info
+{
+    enum vkd3d_data_type data_type;
+    uint32_t id;
+};
+
 struct spirv_compiler
 {
     struct vkd3d_spirv_builder spirv_builder;
@@ -2262,6 +2318,7 @@ struct spirv_compiler
     bool strip_debug;
     bool ssbo_uavs;
     bool uav_read_without_format;
+    SpvExecutionMode fragment_coordinate_origin;
 
     struct rb_tree symbol_table;
     uint32_t temp_id;
@@ -2299,7 +2356,6 @@ struct spirv_compiler
         uint32_t array_element_mask;
     } *output_info;
     uint32_t private_output_variable[MAX_REG_OUTPUT + 1]; /* 1 entry for oDepth */
-    uint32_t private_output_variable_array_idx[MAX_REG_OUTPUT + 1]; /* 1 entry for oDepth */
     uint32_t private_output_variable_write_mask[MAX_REG_OUTPUT + 1]; /* 1 entry for oDepth */
     uint32_t epilogue_function_id;
 
@@ -2323,6 +2379,9 @@ struct spirv_compiler
     bool write_tess_geom_point_size;
 
     struct vkd3d_string_buffer_cache string_buffers;
+
+    struct ssa_register_info *ssa_register_info;
+    unsigned int ssa_register_count;
 };
 
 static bool is_in_default_phase(const struct spirv_compiler *compiler)
@@ -2370,6 +2429,8 @@ static void spirv_compiler_destroy(struct spirv_compiler *compiler)
     shader_signature_cleanup(&compiler->output_signature);
     shader_signature_cleanup(&compiler->patch_constant_signature);
 
+    vkd3d_free(compiler->ssa_register_info);
+
     vkd3d_free(compiler);
 }
 
@@ -2422,6 +2483,7 @@ static struct spirv_compiler *spirv_compiler_create(const struct vkd3d_shader_ve
     compiler->formatting = VKD3D_SHADER_COMPILE_OPTION_FORMATTING_INDENT
             | VKD3D_SHADER_COMPILE_OPTION_FORMATTING_HEADER;
     compiler->write_tess_geom_point_size = true;
+    compiler->fragment_coordinate_origin = SpvExecutionModeOriginUpperLeft;
 
     for (i = 0; i < compile_info->option_count; ++i)
     {
@@ -2446,9 +2508,6 @@ static struct spirv_compiler *spirv_compiler_create(const struct vkd3d_shader_ve
                 compiler->formatting = option->value;
                 break;
 
-            default:
-                WARN("Ignoring unrecognised option %#x with value %#x.\n", option->name, option->value);
-
             case VKD3D_SHADER_COMPILE_OPTION_API_VERSION:
                 break;
 
@@ -2464,6 +2523,19 @@ static struct spirv_compiler *spirv_compiler_create(const struct vkd3d_shader_ve
             case VKD3D_SHADER_COMPILE_OPTION_WRITE_TESS_GEOM_POINT_SIZE:
                 compiler->write_tess_geom_point_size = option->value;
                 break;
+
+            case VKD3D_SHADER_COMPILE_OPTION_FRAGMENT_COORDINATE_ORIGIN:
+                if (option->value == VKD3D_SHADER_COMPILE_OPTION_FRAGMENT_COORDINATE_ORIGIN_UPPER_LEFT)
+                    compiler->fragment_coordinate_origin = SpvExecutionModeOriginUpperLeft;
+                else if (option->value == VKD3D_SHADER_COMPILE_OPTION_FRAGMENT_COORDINATE_ORIGIN_LOWER_LEFT)
+                    compiler->fragment_coordinate_origin = SpvExecutionModeOriginLowerLeft;
+                else
+                    WARN("Ignoring unrecognised value %#x for option %#x.\n", option->value, option->name);
+                break;
+
+            default:
+                WARN("Ignoring unrecognised option %#x with value %#x.\n", option->name, option->value);
+                break;
         }
     }
 
@@ -2848,9 +2920,16 @@ static uint32_t spirv_compiler_get_constant(struct spirv_compiler *compiler,
         case VKD3D_SHADER_COMPONENT_INT:
         case VKD3D_SHADER_COMPONENT_FLOAT:
             break;
+        case VKD3D_SHADER_COMPONENT_BOOL:
+            if (component_count == 1)
+                return vkd3d_spirv_get_op_constant_bool(builder, type_id, *values);
+            FIXME("Unsupported vector of bool.\n");
+            spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_INVALID_TYPE,
+                    "Vectors of bool type are not supported.");
+            return vkd3d_spirv_get_op_undef(builder, type_id);
         default:
             FIXME("Unhandled component_type %#x.\n", component_type);
-            return vkd3d_spirv_build_op_undef(builder, &builder->global_stream, type_id);
+            return vkd3d_spirv_get_op_undef(builder, type_id);
     }
 
     if (component_count == 1)
@@ -2879,7 +2958,7 @@ static uint32_t spirv_compiler_get_constant64(struct spirv_compiler *compiler,
     if (component_type != VKD3D_SHADER_COMPONENT_DOUBLE)
     {
         FIXME("Unhandled component_type %#x.\n", component_type);
-        return vkd3d_spirv_build_op_undef(builder, &builder->global_stream, type_id);
+        return vkd3d_spirv_get_op_undef(builder, type_id);
     }
 
     if (component_count == 1)
@@ -2975,13 +3054,12 @@ static bool spirv_compiler_get_register_name(char *buffer, unsigned int buffer_s
         case VKD3DSPR_INPUT:
             snprintf(buffer, buffer_size, "v%u", idx);
             break;
-        case VKD3DSPR_INCONTROLPOINT:
-            snprintf(buffer, buffer_size, "vicp%u", idx);
-            break;
         case VKD3DSPR_OUTPUT:
-        case VKD3DSPR_COLOROUT:
             snprintf(buffer, buffer_size, "o%u", idx);
             break;
+        case VKD3DSPR_COLOROUT:
+            snprintf(buffer, buffer_size, "oC%u", idx);
+            break;
         case VKD3DSPR_DEPTHOUT:
         case VKD3DSPR_DEPTHOUTGE:
         case VKD3DSPR_DEPTHOUTLE:
@@ -3318,21 +3396,6 @@ static bool spirv_compiler_get_register_info(const struct spirv_compiler *compil
     return true;
 }
 
-static bool register_is_descriptor(const struct vkd3d_shader_register *reg)
-{
-    switch (reg->type)
-    {
-        case VKD3DSPR_SAMPLER:
-        case VKD3DSPR_RESOURCE:
-        case VKD3DSPR_CONSTBUFFER:
-        case VKD3DSPR_UAV:
-            return true;
-
-        default:
-            return false;
-    }
-}
-
 static bool spirv_compiler_enable_descriptor_indexing(struct spirv_compiler *compiler,
         enum vkd3d_shader_register_type reg_type, enum vkd3d_shader_resource_type resource_type)
 {
@@ -3458,10 +3521,13 @@ static void spirv_compiler_emit_dereference_register(struct spirv_compiler *comp
             FIXME("Relative addressing not implemented.\n");
 
         /* Handle arrayed registers, e.g. v[3][0]. */
-        if (reg->idx_count > 1 && !register_is_descriptor(reg))
+        if (reg->idx_count > 1 && !vsir_register_is_descriptor(reg))
             indexes[index_count++] = spirv_compiler_emit_register_addressing(compiler, &reg->idx[0]);
     }
 
+    if (reg->alignment)
+        WARN("Ignoring alignment %u.\n", reg->alignment);
+
     if (index_count)
     {
         component_count = vkd3d_write_mask_component_count(register_info->write_mask);
@@ -3496,6 +3562,14 @@ static bool vkd3d_swizzle_is_equal(unsigned int dst_write_mask,
     return vkd3d_compact_swizzle(VKD3D_SHADER_NO_SWIZZLE, dst_write_mask) == vkd3d_compact_swizzle(swizzle, write_mask);
 }
 
+static bool vkd3d_swizzle_is_scalar(unsigned int swizzle)
+{
+    unsigned int component_idx = vkd3d_swizzle_get_component(swizzle, 0);
+    return vkd3d_swizzle_get_component(swizzle, 1) == component_idx
+            && vkd3d_swizzle_get_component(swizzle, 2) == component_idx
+            && vkd3d_swizzle_get_component(swizzle, 3) == component_idx;
+}
+
 static uint32_t spirv_compiler_emit_swizzle(struct spirv_compiler *compiler,
         uint32_t val_id, unsigned int val_write_mask, enum vkd3d_shader_component_type component_type,
         unsigned int swizzle, unsigned int write_mask)
@@ -3576,7 +3650,7 @@ static uint32_t spirv_compiler_emit_load_constant(struct spirv_compiler *compile
 
     assert(reg->type == VKD3DSPR_IMMCONST);
 
-    if (reg->immconst_type == VKD3D_IMMCONST_SCALAR)
+    if (reg->dimension == VSIR_DIMENSION_SCALAR)
     {
         for (i = 0; i < component_count; ++i)
             values[i] = *reg->u.immconst_uint;
@@ -3603,7 +3677,7 @@ static uint32_t spirv_compiler_emit_load_constant64(struct spirv_compiler *compi
 
     assert(reg->type == VKD3DSPR_IMMCONST64);
 
-    if (reg->immconst_type == VKD3D_IMMCONST_SCALAR)
+    if (reg->dimension == VSIR_DIMENSION_SCALAR)
     {
         for (i = 0; i < component_count; ++i)
             values[i] = *reg->u.immconst_uint64;
@@ -3631,7 +3705,7 @@ static uint32_t spirv_compiler_emit_load_undef(struct spirv_compiler *compiler,
     assert(reg->type == VKD3DSPR_UNDEF);
 
     type_id = vkd3d_spirv_get_type_id_for_data_type(builder, reg->data_type, component_count);
-    return vkd3d_spirv_build_op_undef(builder, &builder->global_stream, type_id);
+    return vkd3d_spirv_get_op_undef(builder, type_id);
 }
 
 static uint32_t spirv_compiler_emit_load_scalar(struct spirv_compiler *compiler,
@@ -3682,6 +3756,55 @@ static uint32_t spirv_compiler_emit_load_scalar(struct spirv_compiler *compiler,
     return val_id;
 }
 
+static const struct ssa_register_info *spirv_compiler_get_ssa_register_info(const struct spirv_compiler *compiler,
+        const struct vkd3d_shader_register *reg)
+{
+    assert(reg->idx[0].offset < compiler->ssa_register_count);
+    assert(reg->idx_count == 1);
+    return &compiler->ssa_register_info[reg->idx[0].offset];
+}
+
+static void spirv_compiler_set_ssa_register_info(const struct spirv_compiler *compiler,
+        const struct vkd3d_shader_register *reg, uint32_t val_id)
+{
+    unsigned int i = reg->idx[0].offset;
+    assert(i < compiler->ssa_register_count);
+    compiler->ssa_register_info[i].data_type = reg->data_type;
+    compiler->ssa_register_info[i].id = val_id;
+}
+
+static uint32_t spirv_compiler_emit_load_ssa_reg(struct spirv_compiler *compiler,
+        const struct vkd3d_shader_register *reg, enum vkd3d_shader_component_type component_type,
+        unsigned int swizzle)
+{
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    enum vkd3d_shader_component_type reg_component_type;
+    const struct ssa_register_info *ssa;
+    unsigned int component_idx;
+    uint32_t type_id, val_id;
+
+    ssa = spirv_compiler_get_ssa_register_info(compiler, reg);
+    val_id = ssa->id;
+    assert(val_id);
+    assert(vkd3d_swizzle_is_scalar(swizzle));
+
+    if (reg->dimension == VSIR_DIMENSION_SCALAR)
+    {
+        reg_component_type = vkd3d_component_type_from_data_type(ssa->data_type);
+        if (component_type != reg_component_type)
+        {
+            type_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
+            val_id = vkd3d_spirv_build_op_bitcast(builder, type_id, val_id);
+        }
+
+        return val_id;
+    }
+
+    type_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
+    component_idx = vkd3d_swizzle_get_component(swizzle, 0);
+    return vkd3d_spirv_build_op_composite_extract1(builder, type_id, val_id, component_idx);
+}
+
 static uint32_t spirv_compiler_emit_load_reg(struct spirv_compiler *compiler,
         const struct vkd3d_shader_register *reg, DWORD swizzle, DWORD write_mask)
 {
@@ -3701,10 +3824,14 @@ static uint32_t spirv_compiler_emit_load_reg(struct spirv_compiler *compiler,
 
     component_count = vkd3d_write_mask_component_count(write_mask);
     component_type = vkd3d_component_type_from_data_type(reg->data_type);
+
+    if (reg->type == VKD3DSPR_SSA)
+        return spirv_compiler_emit_load_ssa_reg(compiler, reg, component_type, swizzle);
+
     if (!spirv_compiler_get_register_info(compiler, reg, &reg_info))
     {
         type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
-        return vkd3d_spirv_build_op_undef(builder, &builder->global_stream, type_id);
+        return vkd3d_spirv_get_op_undef(builder, type_id);
     }
     assert(reg_info.component_type != VKD3D_SHADER_COMPONENT_DOUBLE);
     spirv_compiler_emit_dereference_register(compiler, reg, &reg_info);
@@ -3777,7 +3904,7 @@ static uint32_t spirv_compiler_emit_neg(struct spirv_compiler *compiler,
     type_id = spirv_compiler_get_type_id_for_reg(compiler, reg, write_mask);
     if (reg->data_type == VKD3D_DATA_FLOAT || reg->data_type == VKD3D_DATA_DOUBLE)
         return vkd3d_spirv_build_op_fnegate(builder, type_id, val_id);
-    else if (reg->data_type == VKD3D_DATA_INT)
+    else if (reg->data_type == VKD3D_DATA_INT || reg->data_type == VKD3D_DATA_UINT)
         return vkd3d_spirv_build_op_snegate(builder, type_id, val_id);
 
     FIXME("Unhandled data type %#x.\n", reg->data_type);
@@ -3912,6 +4039,12 @@ static void spirv_compiler_emit_store_reg(struct spirv_compiler *compiler,
 
     assert(!register_is_constant_or_undef(reg));
 
+    if (reg->type == VKD3DSPR_SSA)
+    {
+        spirv_compiler_set_ssa_register_info(compiler, reg, val_id);
+        return;
+    }
+
     if (!spirv_compiler_get_register_info(compiler, reg, &reg_info))
         return;
     spirv_compiler_emit_dereference_register(compiler, reg, &reg_info);
@@ -4108,17 +4241,41 @@ static uint32_t spirv_compiler_emit_int_to_bool(struct spirv_compiler *compiler,
 }
 
 static uint32_t spirv_compiler_emit_bool_to_int(struct spirv_compiler *compiler,
-        unsigned int component_count, uint32_t val_id)
+        unsigned int component_count, uint32_t val_id, bool signedness)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id, true_id, false_id;
 
-    true_id = spirv_compiler_get_constant_uint_vector(compiler, 0xffffffff, component_count);
+    true_id = spirv_compiler_get_constant_uint_vector(compiler, signedness ? 0xffffffff : 1, component_count);
     false_id = spirv_compiler_get_constant_uint_vector(compiler, 0, component_count);
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_UINT, component_count);
     return vkd3d_spirv_build_op_select(builder, type_id, val_id, true_id, false_id);
 }
 
+static uint32_t spirv_compiler_emit_bool_to_float(struct spirv_compiler *compiler,
+        unsigned int component_count, uint32_t val_id, bool signedness)
+{
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    uint32_t type_id, true_id, false_id;
+
+    true_id = spirv_compiler_get_constant_float_vector(compiler, signedness ? -1.0f : 1.0f, component_count);
+    false_id = spirv_compiler_get_constant_float_vector(compiler, 0.0f, component_count);
+    type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, component_count);
+    return vkd3d_spirv_build_op_select(builder, type_id, val_id, true_id, false_id);
+}
+
+static uint32_t spirv_compiler_emit_bool_to_double(struct spirv_compiler *compiler,
+        unsigned int component_count, uint32_t val_id, bool signedness)
+{
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    uint32_t type_id, true_id, false_id;
+
+    true_id = spirv_compiler_get_constant_double_vector(compiler, signedness ? -1.0 : 1.0, component_count);
+    false_id = spirv_compiler_get_constant_double_vector(compiler, 0.0, component_count);
+    type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_DOUBLE, component_count);
+    return vkd3d_spirv_build_op_select(builder, type_id, val_id, true_id, false_id);
+}
+
 typedef uint32_t (*vkd3d_spirv_builtin_fixup_pfn)(struct spirv_compiler *compiler,
         uint32_t val_id);
 
@@ -4161,7 +4318,7 @@ static uint32_t sv_instance_id_fixup(struct spirv_compiler *compiler,
 static uint32_t sv_front_face_fixup(struct spirv_compiler *compiler,
         uint32_t front_facing_id)
 {
-    return spirv_compiler_emit_bool_to_int(compiler, 1, front_facing_id);
+    return spirv_compiler_emit_bool_to_int(compiler, 1, front_facing_id, true);
 }
 
 /* frag_coord.w = 1.0f / frag_coord.w */
@@ -4195,47 +4352,41 @@ struct vkd3d_spirv_builtin
  */
 static const struct
 {
-    enum vkd3d_shader_input_sysval_semantic sysval;
+    enum vkd3d_shader_sysval_semantic sysval;
     struct vkd3d_spirv_builtin builtin;
     enum vkd3d_shader_spirv_environment environment;
 }
 vkd3d_system_value_builtins[] =
 {
-    {VKD3D_SIV_VERTEX_ID,   {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInVertexId},
+    {VKD3D_SHADER_SV_VERTEX_ID,             {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInVertexId},
             VKD3D_SHADER_SPIRV_ENVIRONMENT_OPENGL_4_5},
-    {VKD3D_SIV_INSTANCE_ID, {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInInstanceId},
+    {VKD3D_SHADER_SV_INSTANCE_ID,           {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInInstanceId},
             VKD3D_SHADER_SPIRV_ENVIRONMENT_OPENGL_4_5},
 
-    {VKD3D_SIV_POSITION,    {VKD3D_SHADER_COMPONENT_FLOAT, 4, SpvBuiltInPosition}},
-    {VKD3D_SIV_VERTEX_ID,   {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInVertexIndex, sv_vertex_id_fixup}},
-    {VKD3D_SIV_INSTANCE_ID, {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInInstanceIndex, sv_instance_id_fixup}},
+    {VKD3D_SHADER_SV_POSITION,              {VKD3D_SHADER_COMPONENT_FLOAT, 4, SpvBuiltInPosition}},
+    {VKD3D_SHADER_SV_VERTEX_ID,             {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInVertexIndex, sv_vertex_id_fixup}},
+    {VKD3D_SHADER_SV_INSTANCE_ID,           {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInInstanceIndex, sv_instance_id_fixup}},
 
-    {VKD3D_SIV_PRIMITIVE_ID, {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInPrimitiveId}},
+    {VKD3D_SHADER_SV_PRIMITIVE_ID,          {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInPrimitiveId}},
 
-    {VKD3D_SIV_RENDER_TARGET_ARRAY_INDEX, {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInLayer}},
-    {VKD3D_SIV_VIEWPORT_ARRAY_INDEX,      {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInViewportIndex}},
+    {VKD3D_SHADER_SV_RENDER_TARGET_ARRAY_INDEX, {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInLayer}},
+    {VKD3D_SHADER_SV_VIEWPORT_ARRAY_INDEX,      {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInViewportIndex}},
 
-    {VKD3D_SIV_IS_FRONT_FACE, {VKD3D_SHADER_COMPONENT_BOOL, 1, SpvBuiltInFrontFacing, sv_front_face_fixup}},
+    {VKD3D_SHADER_SV_IS_FRONT_FACE,         {VKD3D_SHADER_COMPONENT_BOOL, 1, SpvBuiltInFrontFacing, sv_front_face_fixup}},
 
-    {VKD3D_SIV_SAMPLE_INDEX, {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInSampleId}},
+    {VKD3D_SHADER_SV_SAMPLE_INDEX,          {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInSampleId}},
 
-    {VKD3D_SIV_CLIP_DISTANCE, {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInClipDistance, NULL, 1}},
-    {VKD3D_SIV_CULL_DISTANCE, {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInCullDistance, NULL, 1}},
+    {VKD3D_SHADER_SV_CLIP_DISTANCE,         {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInClipDistance, NULL, 1}},
+    {VKD3D_SHADER_SV_CULL_DISTANCE,         {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInCullDistance, NULL, 1}},
 
-    {VKD3D_SIV_QUAD_U0_TESS_FACTOR,      {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 0}},
-    {VKD3D_SIV_QUAD_V0_TESS_FACTOR,      {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 1}},
-    {VKD3D_SIV_QUAD_U1_TESS_FACTOR,      {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 2}},
-    {VKD3D_SIV_QUAD_V1_TESS_FACTOR,      {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 3}},
-    {VKD3D_SIV_QUAD_U_INNER_TESS_FACTOR, {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelInner, NULL, 2, 0}},
-    {VKD3D_SIV_QUAD_V_INNER_TESS_FACTOR, {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelInner, NULL, 2, 1}},
+    {VKD3D_SHADER_SV_TESS_FACTOR_QUADEDGE,  {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4}},
+    {VKD3D_SHADER_SV_TESS_FACTOR_QUADINT,   {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelInner, NULL, 2}},
 
-    {VKD3D_SIV_TRIANGLE_U_TESS_FACTOR,     {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 0}},
-    {VKD3D_SIV_TRIANGLE_V_TESS_FACTOR,     {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 1}},
-    {VKD3D_SIV_TRIANGLE_W_TESS_FACTOR,     {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 2}},
-    {VKD3D_SIV_TRIANGLE_INNER_TESS_FACTOR, {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelInner, NULL, 2, 0}},
+    {VKD3D_SHADER_SV_TESS_FACTOR_TRIEDGE,   {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4}},
+    {VKD3D_SHADER_SV_TESS_FACTOR_TRIINT,    {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelInner, NULL, 2}},
 
-    {VKD3D_SIV_LINE_DENSITY_TESS_FACTOR, {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 0}},
-    {VKD3D_SIV_LINE_DETAIL_TESS_FACTOR,  {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 1}},
+    {VKD3D_SHADER_SV_TESS_FACTOR_LINEDEN,   {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 0}},
+    {VKD3D_SHADER_SV_TESS_FACTOR_LINEDET,   {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInTessLevelOuter, NULL, 4, 1}},
 };
 static const struct vkd3d_spirv_builtin vkd3d_pixel_shader_position_builtin =
 {
@@ -4299,7 +4450,7 @@ static void spirv_compiler_emit_register_execution_mode(struct spirv_compiler *c
 }
 
 static const struct vkd3d_spirv_builtin *get_spirv_builtin_for_sysval(
-        const struct spirv_compiler *compiler, enum vkd3d_shader_input_sysval_semantic sysval)
+        const struct spirv_compiler *compiler, enum vkd3d_shader_sysval_semantic sysval)
 {
     enum vkd3d_shader_spirv_environment environment;
     unsigned int i;
@@ -4308,7 +4459,7 @@ static const struct vkd3d_spirv_builtin *get_spirv_builtin_for_sysval(
         return NULL;
 
     /* In pixel shaders, SV_Position is mapped to SpvBuiltInFragCoord. */
-    if (sysval == VKD3D_SIV_POSITION && compiler->shader_type == VKD3D_SHADER_TYPE_PIXEL)
+    if (sysval == VKD3D_SHADER_SV_POSITION && compiler->shader_type == VKD3D_SHADER_TYPE_PIXEL)
         return &vkd3d_pixel_shader_position_builtin;
 
     environment = spirv_compiler_get_target_environment(compiler);
@@ -4340,7 +4491,7 @@ static const struct vkd3d_spirv_builtin *get_spirv_builtin_for_register(
 }
 
 static const struct vkd3d_spirv_builtin *vkd3d_get_spirv_builtin(const struct spirv_compiler *compiler,
-        enum vkd3d_shader_register_type reg_type, enum vkd3d_shader_input_sysval_semantic sysval)
+        enum vkd3d_shader_register_type reg_type, enum vkd3d_shader_sysval_semantic sysval)
 {
     const struct vkd3d_spirv_builtin *builtin;
 
@@ -4349,8 +4500,7 @@ static const struct vkd3d_spirv_builtin *vkd3d_get_spirv_builtin(const struct sp
     if ((builtin = get_spirv_builtin_for_register(reg_type)))
         return builtin;
 
-    if (sysval != VKD3D_SIV_NONE || (reg_type != VKD3DSPR_OUTPUT && reg_type != VKD3DSPR_COLOROUT
-            && reg_type != VKD3DSPR_PATCHCONST))
+    if (sysval != VKD3D_SHADER_SV_NONE || (reg_type != VKD3DSPR_OUTPUT && reg_type != VKD3DSPR_PATCHCONST))
         FIXME("Unhandled builtin (register type %#x, sysval %#x).\n", reg_type, sysval);
     return NULL;
 }
@@ -4361,11 +4511,7 @@ static uint32_t spirv_compiler_get_invocation_id(struct spirv_compiler *compiler
 
     assert(compiler->shader_type == VKD3D_SHADER_TYPE_HULL);
 
-    memset(&r, 0, sizeof(r));
-    r.type = VKD3DSPR_OUTPOINTID;
-    r.idx[0].offset = ~0u;
-    r.idx[1].offset = ~0u;
-    r.idx_count = 0;
+    vsir_register_init(&r, VKD3DSPR_OUTPOINTID, VKD3D_DATA_FLOAT, 0);
     return spirv_compiler_get_register_id(compiler, &r);
 }
 
@@ -4486,7 +4632,7 @@ static uint32_t spirv_compiler_emit_builtin_variable_v(struct spirv_compiler *co
     assert(size_count <= ARRAY_SIZE(sizes));
     memcpy(sizes, array_sizes, size_count * sizeof(sizes[0]));
     array_sizes = sizes;
-    sizes[0] = max(sizes[0], builtin->spirv_array_size);
+    sizes[size_count - 1] = max(sizes[size_count - 1], builtin->spirv_array_size);
 
     id = spirv_compiler_emit_array_variable(compiler, &builder->global_stream, storage_class,
             builtin->component_type, builtin->component_count, array_sizes, size_count);
@@ -4524,27 +4670,8 @@ static unsigned int shader_signature_next_location(const struct shader_signature
     return max_row;
 }
 
-static unsigned int shader_register_get_io_indices(const struct vkd3d_shader_register *reg,
-        unsigned int *array_sizes)
-{
-    unsigned int i, element_idx;
-
-    array_sizes[0] = 0;
-    array_sizes[1] = 0;
-    element_idx = reg->idx[0].offset;
-    for (i = 1; i < reg->idx_count; ++i)
-    {
-        array_sizes[1] = array_sizes[0];
-        array_sizes[0] = element_idx;
-        element_idx = reg->idx[i].offset;
-    }
-
-    return element_idx;
-}
-
 static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_dst_param *dst, enum vkd3d_shader_input_sysval_semantic sysval,
-        enum vkd3d_shader_interpolation_mode interpolation_mode)
+        const struct vkd3d_shader_dst_param *dst)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     const struct vkd3d_shader_register *reg = &dst->reg;
@@ -4552,18 +4679,18 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     const struct signature_element *signature_element;
     const struct shader_signature *shader_signature;
     enum vkd3d_shader_component_type component_type;
-    uint32_t type_id, ptr_type_id, float_type_id;
     const struct vkd3d_spirv_builtin *builtin;
+    enum vkd3d_shader_sysval_semantic sysval;
     unsigned int write_mask, reg_write_mask;
     struct vkd3d_symbol *symbol = NULL;
     uint32_t val_id, input_id, var_id;
+    uint32_t type_id, float_type_id;
     struct vkd3d_symbol reg_symbol;
     SpvStorageClass storage_class;
     struct rb_entry *entry = NULL;
     bool use_private_var = false;
     unsigned int array_sizes[2];
     unsigned int element_idx;
-    uint32_t i, index;
 
     assert(!reg->idx_count || !reg->idx[0].rel_addr);
     assert(reg->idx_count < 2 || !reg->idx[1].rel_addr);
@@ -4571,15 +4698,22 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     shader_signature = reg->type == VKD3DSPR_PATCHCONST
             ? &compiler->patch_constant_signature : &compiler->input_signature;
 
-    element_idx = shader_register_get_io_indices(reg, array_sizes);
+    element_idx = reg->idx[reg->idx_count - 1].offset;
     signature_element = &shader_signature->elements[element_idx];
-
-    if ((compiler->shader_type == VKD3D_SHADER_TYPE_HULL || compiler->shader_type == VKD3D_SHADER_TYPE_GEOMETRY)
-            && !sysval && signature_element->sysval_semantic)
-        sysval = vkd3d_siv_from_sysval(signature_element->sysval_semantic);
+    sysval = signature_element->sysval_semantic;
+    /* The Vulkan spec does not explicitly forbid passing varyings from the
+     * TCS to the TES via builtins. However, Mesa doesn't seem to handle it
+     * well, and we don't actually need them to be in builtins. */
+    if (compiler->shader_type == VKD3D_SHADER_TYPE_DOMAIN && reg->type != VKD3DSPR_PATCHCONST)
+        sysval = VKD3D_SHADER_SV_NONE;
 
     builtin = get_spirv_builtin_for_sysval(compiler, sysval);
 
+    array_sizes[0] = (reg->type == VKD3DSPR_PATCHCONST ? 0 : compiler->input_control_point_count);
+    array_sizes[1] = signature_element->register_count;
+    if (array_sizes[1] == 1 && !vsir_sysval_semantic_is_tess_factor(signature_element->sysval_semantic))
+        array_sizes[1] = 0;
+
     write_mask = signature_element->mask;
 
     if (builtin)
@@ -4644,7 +4778,7 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
         if (component_idx)
             vkd3d_spirv_build_op_decorate1(builder, input_id, SpvDecorationComponent, component_idx);
 
-        spirv_compiler_emit_interpolation_decorations(compiler, input_id, interpolation_mode);
+        spirv_compiler_emit_interpolation_decorations(compiler, input_id, signature_element->interpolation_mode);
     }
 
     var_id = input_id;
@@ -4666,47 +4800,27 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
 
     if (use_private_var)
     {
+        struct vkd3d_shader_register dst_reg = *reg;
+        dst_reg.data_type = VKD3D_DATA_FLOAT;
+
         type_id = vkd3d_spirv_get_type_id(builder, component_type, input_component_count);
-        for (i = 0; i < max(array_sizes[0], 1); ++i)
-        {
-            struct vkd3d_shader_register dst_reg = *reg;
-            dst_reg.data_type = VKD3D_DATA_FLOAT;
 
-            val_id = input_id;
-            if (array_sizes[0])
-            {
-                ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassInput, type_id);
-                index = spirv_compiler_get_constant_uint(compiler, i);
-                val_id = vkd3d_spirv_build_op_in_bounds_access_chain1(builder, ptr_type_id, input_id, index);
-                dst_reg.idx[0].offset = i;
-            }
-            else if (builtin && builtin->spirv_array_size)
-            {
-                /* The D3D builtin is not an array, but the SPIR-V builtin is,
-                 * so we'll need to index into the SPIR-V builtin when loading
-                 * it. This happens when reading TessLevel in domain shaders. */
-                ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassInput, type_id);
-                index = spirv_compiler_get_constant_uint(compiler, builtin->member_idx);
-                val_id = vkd3d_spirv_build_op_in_bounds_access_chain1(builder, ptr_type_id, input_id, index);
-                dst_reg.idx[0].offset = element_idx + i;
-            }
-            val_id = vkd3d_spirv_build_op_load(builder, type_id, val_id, SpvMemoryAccessMaskNone);
+        val_id = vkd3d_spirv_build_op_load(builder, type_id, input_id, SpvMemoryAccessMaskNone);
 
-            if (builtin && builtin->fixup_pfn)
-                val_id = builtin->fixup_pfn(compiler, val_id);
+        if (builtin && builtin->fixup_pfn)
+            val_id = builtin->fixup_pfn(compiler, val_id);
 
-            if (component_type != VKD3D_SHADER_COMPONENT_FLOAT)
-            {
-                float_type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, input_component_count);
-                val_id = vkd3d_spirv_build_op_bitcast(builder, float_type_id, val_id);
-            }
+        if (component_type != VKD3D_SHADER_COMPONENT_FLOAT)
+        {
+            float_type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, input_component_count);
+            val_id = vkd3d_spirv_build_op_bitcast(builder, float_type_id, val_id);
+        }
 
-            val_id = spirv_compiler_emit_swizzle(compiler, val_id,
-                    vkd3d_write_mask_from_component_count(input_component_count),
-                    VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_SHADER_NO_SWIZZLE, dst->write_mask >> component_idx);
+        val_id = spirv_compiler_emit_swizzle(compiler, val_id,
+                vkd3d_write_mask_from_component_count(input_component_count),
+                VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_SHADER_NO_SWIZZLE, dst->write_mask >> component_idx);
 
-            spirv_compiler_emit_store_reg(compiler, &dst_reg, dst->write_mask, val_id);
-        }
+        spirv_compiler_emit_store_reg(compiler, &dst_reg, dst->write_mask, val_id);
     }
 
     return input_id;
@@ -4747,30 +4861,6 @@ static void spirv_compiler_emit_input_register(struct spirv_compiler *compiler,
     spirv_compiler_emit_register_debug_name(builder, input_id, reg);
 }
 
-static void spirv_compiler_emit_shader_phase_input(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_dst_param *dst)
-{
-    const struct vkd3d_shader_register *reg = &dst->reg;
-
-    switch (reg->type)
-    {
-        case VKD3DSPR_INPUT:
-        case VKD3DSPR_INCONTROLPOINT:
-        case VKD3DSPR_PATCHCONST:
-            spirv_compiler_emit_input(compiler, dst, VKD3D_SIV_NONE, VKD3DSIM_NONE);
-            return;
-        case VKD3DSPR_PRIMID:
-            spirv_compiler_emit_input_register(compiler, dst);
-            return;
-        case VKD3DSPR_OUTPOINTID: /* Emitted in spirv_compiler_emit_initial_declarations(). */
-        case VKD3DSPR_OUTCONTROLPOINT: /* See spirv_compiler_leave_shader_phase(). */
-            return;
-        default:
-            FIXME("Unhandled shader phase input register %#x.\n", reg->type);
-            return;
-    }
-}
-
 static unsigned int get_shader_output_swizzle(const struct spirv_compiler *compiler,
         unsigned int register_idx)
 {
@@ -4835,7 +4925,7 @@ static void spirv_compiler_emit_shader_signature_outputs(struct spirv_compiler *
     if (clip_distance_mask)
     {
         count = vkd3d_popcount(clip_distance_mask);
-        builtin = get_spirv_builtin_for_sysval(compiler, VKD3D_SIV_CLIP_DISTANCE);
+        builtin = get_spirv_builtin_for_sysval(compiler, VKD3D_SHADER_SV_CLIP_DISTANCE);
         clip_distance_id = spirv_compiler_emit_builtin_variable(compiler,
                 builtin, SpvStorageClassOutput, count);
     }
@@ -4843,7 +4933,7 @@ static void spirv_compiler_emit_shader_signature_outputs(struct spirv_compiler *
     if (cull_distance_mask)
     {
         count = vkd3d_popcount(cull_distance_mask);
-        builtin = get_spirv_builtin_for_sysval(compiler, VKD3D_SIV_CULL_DISTANCE);
+        builtin = get_spirv_builtin_for_sysval(compiler, VKD3D_SHADER_SV_CULL_DISTANCE);
         cull_distance_id = spirv_compiler_emit_builtin_variable(compiler,
                 builtin, SpvStorageClassOutput, count);
     }
@@ -4904,7 +4994,7 @@ static void spirv_compiler_emit_output_register(struct spirv_compiler *compiler,
 }
 
 static uint32_t spirv_compiler_emit_shader_phase_builtin_variable(struct spirv_compiler *compiler,
-        const struct vkd3d_spirv_builtin *builtin)
+        const struct vkd3d_spirv_builtin *builtin, const unsigned int *array_sizes, unsigned int size_count)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t *variable_id, id;
@@ -4919,7 +5009,7 @@ static uint32_t spirv_compiler_emit_shader_phase_builtin_variable(struct spirv_c
     if (variable_id && *variable_id)
         return *variable_id;
 
-    id = spirv_compiler_emit_builtin_variable(compiler, builtin, SpvStorageClassOutput, 0);
+    id = spirv_compiler_emit_builtin_variable_v(compiler, builtin, SpvStorageClassOutput, array_sizes, size_count);
     if (is_in_fork_or_join_phase(compiler))
         vkd3d_spirv_build_op_decorate(builder, id, SpvDecorationPatch, NULL, 0);
 
@@ -4928,8 +5018,7 @@ static uint32_t spirv_compiler_emit_shader_phase_builtin_variable(struct spirv_c
     return id;
 }
 
-static void spirv_compiler_emit_output(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_dst_param *dst, enum vkd3d_shader_input_sysval_semantic sysval)
+static void spirv_compiler_emit_output(struct spirv_compiler *compiler, const struct vkd3d_shader_dst_param *dst)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     const struct vkd3d_shader_register *reg = &dst->reg;
@@ -4938,6 +5027,7 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler,
     enum vkd3d_shader_component_type component_type;
     const struct shader_signature *shader_signature;
     const struct vkd3d_spirv_builtin *builtin;
+    enum vkd3d_shader_sysval_semantic sysval;
     unsigned int write_mask, reg_write_mask;
     bool use_private_variable = false;
     struct vkd3d_symbol reg_symbol;
@@ -4951,8 +5041,16 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler,
 
     shader_signature = is_patch_constant ? &compiler->patch_constant_signature : &compiler->output_signature;
 
-    element_idx = shader_register_get_io_indices(reg, array_sizes);
+    element_idx = reg->idx[reg->idx_count - 1].offset;
     signature_element = &shader_signature->elements[element_idx];
+    sysval = signature_element->sysval_semantic;
+    /* Don't use builtins for TCS -> TES varyings. See spirv_compiler_emit_input(). */
+    if (compiler->shader_type == VKD3D_SHADER_TYPE_HULL && !is_patch_constant)
+        sysval = VKD3D_SHADER_SV_NONE;
+    array_sizes[0] = (reg->type == VKD3DSPR_PATCHCONST ? 0 : compiler->output_control_point_count);
+    array_sizes[1] = signature_element->register_count;
+    if (array_sizes[1] == 1 && !vsir_sysval_semantic_is_tess_factor(signature_element->sysval_semantic))
+        array_sizes[1] = 0;
 
     builtin = vkd3d_get_spirv_builtin(compiler, dst->reg.type, sysval);
 
@@ -4997,7 +5095,7 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler,
     else if (builtin)
     {
         if (spirv_compiler_get_current_shader_phase(compiler))
-            id = spirv_compiler_emit_shader_phase_builtin_variable(compiler, builtin);
+            id = spirv_compiler_emit_shader_phase_builtin_variable(compiler, builtin, array_sizes, 2);
         else
             id = spirv_compiler_emit_builtin_variable_v(compiler, builtin, storage_class, array_sizes, 2);
 
@@ -5015,6 +5113,9 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler,
 
         if (is_patch_constant)
             location += shader_signature_next_location(&compiler->output_signature);
+        else if (compiler->shader_type == VKD3D_SHADER_TYPE_PIXEL
+                && signature_element->sysval_semantic == VKD3D_SHADER_SV_TARGET)
+            location = signature_element->semantic_index;
 
         id = spirv_compiler_emit_array_variable(compiler, &builder->global_stream,
                 storage_class, component_type, output_component_count, array_sizes, 2);
@@ -5073,16 +5174,15 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler,
 static uint32_t spirv_compiler_get_output_array_index(struct spirv_compiler *compiler,
         const struct signature_element *e)
 {
-    enum vkd3d_shader_input_sysval_semantic sysval;
+    enum vkd3d_shader_sysval_semantic sysval = e->sysval_semantic;
     const struct vkd3d_spirv_builtin *builtin;
 
-    sysval = vkd3d_siv_from_sysval_indexed(e->sysval_semantic, e->semantic_index);
     builtin = get_spirv_builtin_for_sysval(compiler, sysval);
 
     switch (sysval)
     {
-        case VKD3D_SIV_LINE_DETAIL_TESS_FACTOR:
-        case VKD3D_SIV_LINE_DENSITY_TESS_FACTOR:
+        case VKD3D_SHADER_SV_TESS_FACTOR_LINEDEN:
+        case VKD3D_SHADER_SV_TESS_FACTOR_LINEDET:
             return builtin->member_idx;
         default:
             return e->semantic_index;
@@ -5196,7 +5296,6 @@ static void spirv_compiler_emit_shader_epilogue_function(struct spirv_compiler *
 
     STATIC_ASSERT(ARRAY_SIZE(compiler->private_output_variable) == ARRAY_SIZE(param_id));
     STATIC_ASSERT(ARRAY_SIZE(compiler->private_output_variable) == ARRAY_SIZE(param_type_id));
-    STATIC_ASSERT(ARRAY_SIZE(compiler->private_output_variable) == ARRAY_SIZE(compiler->private_output_variable_array_idx));
     STATIC_ASSERT(ARRAY_SIZE(compiler->private_output_variable) == ARRAY_SIZE(compiler->private_output_variable_write_mask));
 
     is_patch_constant = is_in_fork_or_join_phase(compiler);
@@ -5252,7 +5351,6 @@ static void spirv_compiler_emit_shader_epilogue_function(struct spirv_compiler *
     vkd3d_spirv_build_op_function_end(builder);
 
     memset(compiler->private_output_variable, 0, sizeof(compiler->private_output_variable));
-    memset(compiler->private_output_variable_array_idx, 0, sizeof(compiler->private_output_variable_array_idx));
     memset(compiler->private_output_variable_write_mask, 0, sizeof(compiler->private_output_variable_write_mask));
     compiler->epilogue_function_id = 0;
 }
@@ -5262,10 +5360,7 @@ static void spirv_compiler_emit_hull_shader_builtins(struct spirv_compiler *comp
     struct vkd3d_shader_dst_param dst;
 
     memset(&dst, 0, sizeof(dst));
-    dst.reg.type = VKD3DSPR_OUTPOINTID;
-    dst.reg.idx[0].offset = ~0u;
-    dst.reg.idx[1].offset = ~0u;
-    dst.reg.idx_count = 0;
+    vsir_register_init(&dst.reg, VKD3DSPR_OUTPOINTID, VKD3D_DATA_FLOAT, 0);
     dst.write_mask = VKD3DSP_WRITEMASK_0;
     spirv_compiler_emit_input_register(compiler, &dst);
 }
@@ -5293,7 +5388,7 @@ static void spirv_compiler_emit_initial_declarations(struct spirv_compiler *comp
             break;
         case VKD3D_SHADER_TYPE_PIXEL:
             vkd3d_spirv_set_execution_model(builder, SpvExecutionModelFragment);
-            spirv_compiler_emit_execution_mode(compiler, SpvExecutionModeOriginUpperLeft, NULL, 0);
+            spirv_compiler_emit_execution_mode(compiler, compiler->fragment_coordinate_origin, NULL, 0);
             break;
         case VKD3D_SHADER_TYPE_COMPUTE:
             vkd3d_spirv_set_execution_model(builder, SpvExecutionModelGLCompute);
@@ -5329,7 +5424,7 @@ static size_t spirv_compiler_get_current_function_location(struct spirv_compiler
 static void spirv_compiler_emit_dcl_global_flags(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
-    unsigned int flags = instruction->flags;
+    enum vkd3d_shader_global_flags flags = instruction->declaration.global_flags;
 
     if (flags & VKD3DSGF_FORCE_EARLY_DEPTH_STENCIL)
     {
@@ -5344,9 +5439,9 @@ static void spirv_compiler_emit_dcl_global_flags(struct spirv_compiler *compiler
     }
 
     if (flags & ~(VKD3DSGF_REFACTORING_ALLOWED | VKD3DSGF_ENABLE_RAW_AND_STRUCTURED_BUFFERS))
-        FIXME("Unhandled global flags %#x.\n", flags);
+        FIXME("Unhandled global flags %#"PRIx64".\n", (uint64_t)flags);
     else
-        WARN("Unhandled global flags %#x.\n", flags);
+        WARN("Unhandled global flags %#"PRIx64".\n", (uint64_t)flags);
 }
 
 static void spirv_compiler_emit_temps(struct spirv_compiler *compiler, uint32_t count)
@@ -5375,6 +5470,18 @@ static void spirv_compiler_emit_temps(struct spirv_compiler *compiler, uint32_t
     vkd3d_spirv_end_function_stream_insertion(builder);
 }
 
+static void spirv_compiler_allocate_ssa_register_ids(struct spirv_compiler *compiler, unsigned int count)
+{
+    assert(!compiler->ssa_register_info);
+    if (!(compiler->ssa_register_info = vkd3d_calloc(count, sizeof(*compiler->ssa_register_info))))
+    {
+        ERR("Failed to allocate SSA register value id array, count %u.\n", count);
+        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_OUT_OF_MEMORY,
+                "Failed to allocate SSA register value id array of count %u.", count);
+    }
+    compiler->ssa_register_count = count;
+}
+
 static void spirv_compiler_emit_dcl_indexable_temp(struct spirv_compiler *compiler,
           const struct vkd3d_shader_instruction *instruction)
 {
@@ -5388,11 +5495,17 @@ static void spirv_compiler_emit_dcl_indexable_temp(struct spirv_compiler *compil
     if (temp->component_count != 4)
         FIXME("Unhandled component count %u.\n", temp->component_count);
 
-    memset(&reg, 0, sizeof(reg));
-    reg.type = VKD3DSPR_IDXTEMP;
+    vsir_register_init(&reg, VKD3DSPR_IDXTEMP, VKD3D_DATA_FLOAT, 1);
     reg.idx[0].offset = temp->register_idx;
-    reg.idx[1].offset = ~0u;
-    reg.idx_count = 1;
+
+    if (temp->alignment)
+        WARN("Ignoring alignment %u.\n", temp->alignment);
+    if (temp->initialiser)
+    {
+        FIXME("Initialisers are not supported.\n");
+        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                "Initialisers for indexable temps are not supported.");
+    }
 
     function_location = spirv_compiler_get_current_function_location(compiler);
     vkd3d_spirv_begin_function_stream_insertion(builder, function_location);
@@ -5461,13 +5574,14 @@ static void spirv_compiler_emit_push_constant_buffers(struct spirv_compiler *com
 
     struct_id = vkd3d_spirv_build_op_type_struct(builder, member_ids, count);
     vkd3d_spirv_build_op_decorate(builder, struct_id, SpvDecorationBlock, NULL, 0);
-    vkd3d_spirv_build_op_name(builder, struct_id, "push_cb");
+    vkd3d_spirv_build_op_name(builder, struct_id, "push_cb_struct");
     vkd3d_free(member_ids);
 
     pointer_type_id = vkd3d_spirv_get_op_type_pointer(builder, storage_class, struct_id);
     var_id = vkd3d_spirv_build_op_variable(builder, &builder->global_stream,
             pointer_type_id, storage_class, 0);
     compiler->push_constants_var_id = var_id;
+    vkd3d_spirv_build_op_name(builder, var_id, "push_cb");
 
     for (i = 0, j = 0; i < compiler->shader_interface.push_constant_buffer_count; ++i)
     {
@@ -5571,17 +5685,17 @@ static void spirv_compiler_emit_cbv_declaration(struct spirv_compiler *compiler,
     const SpvStorageClass storage_class = SpvStorageClassUniform;
     struct vkd3d_push_constant_buffer_binding *push_cb;
     struct vkd3d_descriptor_variable_info var_info;
+    struct vkd3d_shader_register reg;
     struct vkd3d_symbol reg_symbol;
     unsigned int size;
 
-    struct vkd3d_shader_register reg =
-    {
-        .type = VKD3DSPR_CONSTBUFFER,
-        .idx[0].offset = register_id,
-        .idx_count = 1,
-    };
+    vsir_register_init(&reg, VKD3DSPR_CONSTBUFFER, VKD3D_DATA_FLOAT, 3);
+    reg.idx[0].offset = register_id;
+    reg.idx[1].offset = range->first;
+    reg.idx[2].offset = range->last;
 
-    size = size_in_bytes / (VKD3D_VEC4_SIZE * sizeof(uint32_t));
+    size = align(size_in_bytes, VKD3D_VEC4_SIZE * sizeof(uint32_t));
+    size /= VKD3D_VEC4_SIZE * sizeof(uint32_t);
 
     if ((push_cb = spirv_compiler_find_push_constant_buffer(compiler, range)))
     {
@@ -5629,23 +5743,25 @@ static void spirv_compiler_emit_dcl_immediate_constant_buffer(struct spirv_compi
     struct vkd3d_symbol reg_symbol;
     unsigned int i;
 
-    if (!(elements = vkd3d_calloc(icb->vec4_count, sizeof(*elements))))
+    assert(icb->data_type == VKD3D_DATA_FLOAT);
+    assert(icb->component_count == VKD3D_VEC4_SIZE);
+
+    if (!(elements = vkd3d_calloc(icb->element_count, sizeof(*elements))))
         return;
-    for (i = 0; i < icb->vec4_count; ++i)
+    for (i = 0; i < icb->element_count; ++i)
         elements[i] = spirv_compiler_get_constant(compiler,
                 VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_VEC4_SIZE, &icb->data[4 * i]);
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_VEC4_SIZE);
-    length_id = spirv_compiler_get_constant_uint(compiler, icb->vec4_count);
+    length_id = spirv_compiler_get_constant_uint(compiler, icb->element_count);
     type_id = vkd3d_spirv_get_op_type_array(builder, type_id, length_id);
-    const_id = vkd3d_spirv_build_op_constant_composite(builder, type_id, elements, icb->vec4_count);
+    const_id = vkd3d_spirv_build_op_constant_composite(builder, type_id, elements, icb->element_count);
     ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassPrivate, type_id);
     icb_id = vkd3d_spirv_build_op_variable(builder, &builder->global_stream,
             ptr_type_id, SpvStorageClassPrivate, const_id);
     vkd3d_spirv_build_op_name(builder, icb_id, "icb");
     vkd3d_free(elements);
 
-    memset(&reg, 0, sizeof(reg));
-    reg.type = VKD3DSPR_IMMCONSTBUFFER;
+    vsir_register_init(&reg, VKD3DSPR_IMMCONSTBUFFER, VKD3D_DATA_FLOAT, 0);
     vkd3d_symbol_make_register(&reg_symbol, &reg);
     vkd3d_symbol_set_register_info(&reg_symbol, icb_id, SpvStorageClassPrivate,
             VKD3D_SHADER_COMPONENT_FLOAT, VKD3DSP_WRITEMASK_ALL);
@@ -5658,15 +5774,12 @@ static void spirv_compiler_emit_sampler_declaration(struct spirv_compiler *compi
     const SpvStorageClass storage_class = SpvStorageClassUniformConstant;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     struct vkd3d_descriptor_variable_info var_info;
+    struct vkd3d_shader_register reg;
     struct vkd3d_symbol reg_symbol;
     uint32_t type_id, var_id;
 
-    const struct vkd3d_shader_register reg =
-    {
-        .type = VKD3DSPR_SAMPLER,
-        .idx[0].offset = register_id,
-        .idx_count = 1,
-    };
+    vsir_register_init(&reg, VKD3DSPR_SAMPLER, VKD3D_DATA_FLOAT, 1);
+    reg.idx[0].offset = register_id;
 
     vkd3d_symbol_make_sampler(&reg_symbol, &reg);
     reg_symbol.info.sampler.range = *range;
@@ -5847,6 +5960,7 @@ static void spirv_compiler_emit_combined_sampler_declarations(struct spirv_compi
                 current->sampler_index == VKD3D_SHADER_DUMMY_SAMPLER_INDEX ? 0 : current->sampler_space,
                 current->sampler_index);
         symbol.id = var_id;
+        symbol.descriptor_array = NULL;
         symbol.info.resource.range = *resource_range;
         symbol.info.resource.sampled_type = sampled_type;
         symbol.info.resource.type_id = image_type_id;
@@ -5872,13 +5986,10 @@ static void spirv_compiler_emit_resource_declaration(struct spirv_compiler *comp
     const struct vkd3d_spirv_resource_type *resource_type_info;
     enum vkd3d_shader_component_type sampled_type;
     struct vkd3d_symbol resource_symbol;
+    struct vkd3d_shader_register reg;
 
-    struct vkd3d_shader_register reg =
-    {
-        .type = is_uav ? VKD3DSPR_UAV : VKD3DSPR_RESOURCE,
-        .idx[0].offset = register_id,
-        .idx_count = 1,
-    };
+    vsir_register_init(&reg, is_uav ? VKD3DSPR_UAV : VKD3DSPR_RESOURCE, VKD3D_DATA_FLOAT, 1);
+    reg.idx[0].offset = register_id;
 
     if (resource_type == VKD3D_SHADER_RESOURCE_TEXTURE_2DMS && sample_count == 1)
         resource_type = VKD3D_SHADER_RESOURCE_TEXTURE_2D;
@@ -6030,36 +6141,17 @@ static void spirv_compiler_emit_dcl_input(struct spirv_compiler *compiler,
 {
     const struct vkd3d_shader_dst_param *dst = &instruction->declaration.dst;
 
-    if (spirv_compiler_get_current_shader_phase(compiler))
-        spirv_compiler_emit_shader_phase_input(compiler, dst);
-    else if (vkd3d_shader_register_is_input(&dst->reg) || dst->reg.type == VKD3DSPR_PATCHCONST)
-        spirv_compiler_emit_input(compiler, dst, VKD3D_SIV_NONE, VKD3DSIM_NONE);
-    else
+    /* OUTPOINTID is handled in spirv_compiler_emit_hull_shader_builtins(). */
+    if (dst->reg.type == VKD3DSPR_INPUT || dst->reg.type == VKD3DSPR_PATCHCONST)
+        spirv_compiler_emit_input(compiler, dst);
+    else if (dst->reg.type != VKD3DSPR_OUTPOINTID)
         spirv_compiler_emit_input_register(compiler, dst);
-
-    if (dst->reg.type == VKD3DSPR_OUTCONTROLPOINT)
-        compiler->use_vocp = true;
-}
-
-static void spirv_compiler_emit_dcl_input_ps(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_instruction *instruction)
-{
-    spirv_compiler_emit_input(compiler, &instruction->declaration.dst, VKD3D_SIV_NONE, instruction->flags);
-}
-
-static void spirv_compiler_emit_dcl_input_ps_sysval(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_instruction *instruction)
-{
-    const struct vkd3d_shader_register_semantic *semantic = &instruction->declaration.register_semantic;
-
-    spirv_compiler_emit_input(compiler, &semantic->reg, semantic->sysval_semantic, instruction->flags);
 }
 
 static void spirv_compiler_emit_dcl_input_sysval(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
-    spirv_compiler_emit_input(compiler, &instruction->declaration.register_semantic.reg,
-            instruction->declaration.register_semantic.sysval_semantic, VKD3DSIM_NONE);
+    spirv_compiler_emit_input(compiler, &instruction->declaration.register_semantic.reg);
 }
 
 static void spirv_compiler_emit_dcl_output(struct spirv_compiler *compiler,
@@ -6067,9 +6159,9 @@ static void spirv_compiler_emit_dcl_output(struct spirv_compiler *compiler,
 {
     const struct vkd3d_shader_dst_param *dst = &instruction->declaration.dst;
 
-    if (vkd3d_shader_register_is_output(&dst->reg)
-            || (is_in_fork_or_join_phase(compiler) && vkd3d_shader_register_is_patch_constant(&dst->reg)))
-        spirv_compiler_emit_output(compiler, dst, VKD3D_SIV_NONE);
+    if (dst->reg.type == VKD3DSPR_OUTPUT
+            || (is_in_fork_or_join_phase(compiler) && dst->reg.type == VKD3DSPR_PATCHCONST))
+        spirv_compiler_emit_output(compiler, dst);
     else
         spirv_compiler_emit_output_register(compiler, dst);
 }
@@ -6077,13 +6169,7 @@ static void spirv_compiler_emit_dcl_output(struct spirv_compiler *compiler,
 static void spirv_compiler_emit_dcl_output_siv(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
-    enum vkd3d_shader_input_sysval_semantic sysval;
-    const struct vkd3d_shader_dst_param *dst;
-
-    dst = &instruction->declaration.register_semantic.reg;
-    sysval = instruction->declaration.register_semantic.sysval_semantic;
-
-    spirv_compiler_emit_output(compiler, dst, sysval);
+    spirv_compiler_emit_output(compiler, &instruction->declaration.register_semantic.reg);
 }
 
 static void spirv_compiler_emit_dcl_stream(struct spirv_compiler *compiler,
@@ -6305,7 +6391,6 @@ static void spirv_compiler_leave_shader_phase(struct spirv_compiler *compiler)
          * Control point phase has separate output registers. */
         memset(compiler->output_info, 0, signature->element_count * sizeof(*compiler->output_info));
         memset(compiler->private_output_variable, 0, sizeof(compiler->private_output_variable));
-        memset(compiler->private_output_variable_array_idx, 0, sizeof(compiler->private_output_variable_array_idx));
         memset(compiler->private_output_variable_write_mask, 0, sizeof(compiler->private_output_variable_write_mask));
     }
 }
@@ -6361,20 +6446,13 @@ static void spirv_compiler_emit_default_control_point_phase(struct spirv_compile
     invocation_id = spirv_compiler_emit_load_invocation_id(compiler);
 
     memset(&invocation, 0, sizeof(invocation));
-    invocation.reg.type = VKD3DSPR_OUTPOINTID;
-    invocation.reg.data_type = VKD3D_DATA_INT;
-    invocation.reg.idx[0].offset = ~0u;
-    invocation.reg.idx[1].offset = ~0u;
-    invocation.reg.idx[2].offset = ~0u;
-    invocation.reg.idx_count = 0;
+    vsir_register_init(&invocation.reg, VKD3DSPR_OUTPOINTID, VKD3D_DATA_INT, 0);
     invocation.swizzle = VKD3D_SHADER_NO_SWIZZLE;
 
-    memset(&input_reg, 0, sizeof(input_reg));
-    input_reg.type = VKD3DSPR_INPUT;
-    input_reg.data_type = VKD3D_DATA_FLOAT;
+    vsir_register_init(&input_reg, VKD3DSPR_INPUT, VKD3D_DATA_FLOAT, 2);
+    input_reg.idx[0].offset = 0;
     input_reg.idx[0].rel_addr = &invocation;
-    input_reg.idx[2].offset = ~0u;
-    input_reg.idx_count = 2;
+    input_reg.idx[1].offset = 0;
     input_id = spirv_compiler_get_register_id(compiler, &input_reg);
 
     assert(input_signature->element_count == output_signature->element_count);
@@ -6441,36 +6519,17 @@ static void spirv_compiler_emit_hull_shader_barrier(struct spirv_compiler *compi
 static void spirv_compiler_emit_shader_epilogue_invocation(struct spirv_compiler *compiler)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
-    uint32_t void_id, type_id, ptr_type_id, function_id;
     uint32_t arguments[MAX_REG_OUTPUT];
+    uint32_t void_id, function_id;
     unsigned int i, count;
 
     if ((function_id = compiler->epilogue_function_id))
     {
         void_id = vkd3d_spirv_get_op_type_void(builder);
-        type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, 4);
-        ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassPrivate, type_id);
         for (i = 0, count = 0; i < ARRAY_SIZE(compiler->private_output_variable); ++i)
         {
             if (compiler->private_output_variable[i])
-            {
-                uint32_t argument_id = compiler->private_output_variable[i];
-                unsigned int argument_idx = count++;
-
-                if (compiler->private_output_variable_array_idx[i])
-                {
-                    uint32_t tmp_id;
-
-                    tmp_id = vkd3d_spirv_build_op_access_chain1(builder, ptr_type_id,
-                            argument_id, compiler->private_output_variable_array_idx[i]);
-                    tmp_id = vkd3d_spirv_build_op_load(builder, type_id, tmp_id, SpvMemoryAccessMaskNone);
-                    argument_id = vkd3d_spirv_build_op_variable(builder,
-                            &builder->global_stream, ptr_type_id, SpvStorageClassPrivate, 0);
-                    vkd3d_spirv_build_op_store(builder, argument_id, tmp_id, SpvMemoryAccessMaskNone);
-                }
-
-                arguments[argument_idx] = argument_id;
-            }
+                arguments[count++] = compiler->private_output_variable[i];
         }
 
         vkd3d_spirv_build_op_function_call(builder, void_id, function_id, arguments, count);
@@ -6520,9 +6579,8 @@ static SpvOp spirv_compiler_map_alu_instruction(const struct vkd3d_shader_instru
         {VKD3DSIH_DTOF,       SpvOpFConvert},
         {VKD3DSIH_DTOI,       SpvOpConvertFToS},
         {VKD3DSIH_DTOU,       SpvOpConvertFToU},
+        {VKD3DSIH_FREM,       SpvOpFRem},
         {VKD3DSIH_FTOD,       SpvOpFConvert},
-        {VKD3DSIH_FTOI,       SpvOpConvertFToS},
-        {VKD3DSIH_FTOU,       SpvOpConvertFToU},
         {VKD3DSIH_IADD,       SpvOpIAdd},
         {VKD3DSIH_INEG,       SpvOpSNegate},
         {VKD3DSIH_ISHL,       SpvOpShiftLeftLogical},
@@ -6548,7 +6606,55 @@ static SpvOp spirv_compiler_map_alu_instruction(const struct vkd3d_shader_instru
     return SpvOpMax;
 }
 
-static void spirv_compiler_emit_alu_instruction(struct spirv_compiler *compiler,
+static SpvOp spirv_compiler_map_logical_instruction(const struct vkd3d_shader_instruction *instruction)
+{
+    switch (instruction->handler_idx)
+    {
+        case VKD3DSIH_AND:
+            return SpvOpLogicalAnd;
+        case VKD3DSIH_OR:
+            return SpvOpLogicalOr;
+        case VKD3DSIH_XOR:
+            return SpvOpLogicalNotEqual;
+        default:
+            return SpvOpMax;
+    }
+}
+
+static void spirv_compiler_emit_bool_cast(struct spirv_compiler *compiler,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    const struct vkd3d_shader_dst_param *dst = instruction->dst;
+    const struct vkd3d_shader_src_param *src = instruction->src;
+    uint32_t val_id;
+
+    assert(src->reg.data_type == VKD3D_DATA_BOOL && dst->reg.data_type != VKD3D_DATA_BOOL);
+
+    val_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
+    if (dst->reg.data_type == VKD3D_DATA_FLOAT)
+    {
+        val_id = spirv_compiler_emit_bool_to_float(compiler, 1, val_id, instruction->handler_idx == VKD3DSIH_ITOF);
+    }
+    else if (dst->reg.data_type == VKD3D_DATA_DOUBLE)
+    {
+        /* ITOD is not supported. Frontends which emit bool casts must use ITOF for double. */
+        val_id = spirv_compiler_emit_bool_to_double(compiler, 1, val_id, instruction->handler_idx == VKD3DSIH_ITOF);
+    }
+    else if (dst->reg.data_type == VKD3D_DATA_UINT)
+    {
+        val_id = spirv_compiler_emit_bool_to_int(compiler, 1, val_id, instruction->handler_idx == VKD3DSIH_ITOI);
+    }
+    else
+    {
+        WARN("Unhandled data type %u.\n", dst->reg.data_type);
+        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_INVALID_TYPE,
+                "Register data type %u is unhandled.", dst->reg.data_type);
+    }
+
+    spirv_compiler_emit_store_dst(compiler, dst, val_id);
+}
+
+static enum vkd3d_result spirv_compiler_emit_alu_instruction(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
@@ -6556,14 +6662,36 @@ static void spirv_compiler_emit_alu_instruction(struct spirv_compiler *compiler,
     const struct vkd3d_shader_src_param *src = instruction->src;
     uint32_t src_ids[SPIRV_MAX_SRC_COUNT];
     uint32_t type_id, val_id;
+    SpvOp op = SpvOpMax;
     unsigned int i;
-    SpvOp op;
 
-    op = spirv_compiler_map_alu_instruction(instruction);
+    if (src->reg.data_type == VKD3D_DATA_BOOL)
+    {
+        if (dst->reg.data_type == VKD3D_DATA_BOOL)
+        {
+            /* VSIR supports logic ops AND/OR/XOR on bool values. */
+            op = spirv_compiler_map_logical_instruction(instruction);
+        }
+        else if (instruction->handler_idx == VKD3DSIH_ITOF || instruction->handler_idx == VKD3DSIH_UTOF
+                || instruction->handler_idx == VKD3DSIH_ITOI || instruction->handler_idx == VKD3DSIH_UTOU)
+        {
+            /* VSIR supports cast from bool to signed/unsigned integer types and floating point types,
+             * where bool is treated as a 1-bit integer and a signed 'true' value converts to -1. */
+            spirv_compiler_emit_bool_cast(compiler, instruction);
+            return VKD3D_OK;
+        }
+    }
+    else
+    {
+        op = spirv_compiler_map_alu_instruction(instruction);
+    }
+
     if (op == SpvOpMax)
     {
         ERR("Unexpected instruction %#x.\n", instruction->handler_idx);
-        return;
+        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_INVALID_HANDLER,
+                "Encountered invalid/unhandled instruction handler %#x.", instruction->handler_idx);
+        return VKD3D_ERROR_INVALID_SHADER;
     }
 
     assert(instruction->dst_count == 1);
@@ -6595,6 +6723,7 @@ static void spirv_compiler_emit_alu_instruction(struct spirv_compiler *compiler,
         vkd3d_spirv_build_op_decorate(builder, val_id, SpvDecorationNoContraction, NULL, 0);
 
     spirv_compiler_emit_store_dst(compiler, dst, val_id);
+    return VKD3D_OK;
 }
 
 static enum GLSLstd450 spirv_compiler_map_ext_glsl_instruction(
@@ -6694,7 +6823,8 @@ static void spirv_compiler_emit_mov(struct spirv_compiler *compiler,
     uint32_t components[VKD3D_VEC4_SIZE];
     unsigned int i, component_count;
 
-    if (register_is_constant_or_undef(&src->reg) || dst->modifiers || src->modifiers)
+    if (register_is_constant_or_undef(&src->reg) || src->reg.type == VKD3DSPR_SSA || dst->reg.type == VKD3DSPR_SSA
+            || dst->modifiers || src->modifiers)
         goto general_implementation;
 
     spirv_compiler_get_register_info(compiler, &dst->reg, &dst_reg_info);
@@ -6760,8 +6890,9 @@ static void spirv_compiler_emit_movc(struct spirv_compiler *compiler,
     component_count = vkd3d_write_mask_component_count(dst->write_mask);
     type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
 
-    condition_id = spirv_compiler_emit_int_to_bool(compiler,
-            VKD3D_SHADER_CONDITIONAL_OP_NZ, component_count, condition_id);
+    if (src[0].reg.data_type != VKD3D_DATA_BOOL)
+        condition_id = spirv_compiler_emit_int_to_bool(compiler,
+                VKD3D_SHADER_CONDITIONAL_OP_NZ, component_count, condition_id);
     val_id = vkd3d_spirv_build_op_select(builder, type_id, condition_id, src1_id, src2_id);
 
     spirv_compiler_emit_store_dst(compiler, dst, val_id);
@@ -6899,7 +7030,7 @@ static void spirv_compiler_emit_imul(struct spirv_compiler *compiler,
     uint32_t type_id, val_id, src0_id, src1_id;
 
     if (dst[0].reg.type != VKD3DSPR_NULL)
-        FIXME("Extended multiplies not implemented.\n"); /* SpvOpSMulExtended */
+        FIXME("Extended multiplies not implemented.\n"); /* SpvOpSMulExtended/SpvOpUMulExtended */
 
     if (dst[1].reg.type == VKD3DSPR_NULL)
         return;
@@ -6935,7 +7066,7 @@ static void spirv_compiler_emit_imad(struct spirv_compiler *compiler,
     spirv_compiler_emit_store_dst(compiler, dst, val_id);
 }
 
-static void spirv_compiler_emit_udiv(struct spirv_compiler *compiler,
+static void spirv_compiler_emit_int_div(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
     uint32_t type_id, val_id, src0_id, src1_id, condition_id, uint_max_id;
@@ -6943,6 +7074,10 @@ static void spirv_compiler_emit_udiv(struct spirv_compiler *compiler,
     const struct vkd3d_shader_dst_param *dst = instruction->dst;
     const struct vkd3d_shader_src_param *src = instruction->src;
     unsigned int component_count = 0;
+    SpvOp div_op, mod_op;
+
+    div_op = instruction->handler_idx == VKD3DSIH_IDIV ? SpvOpSDiv : SpvOpUDiv;
+    mod_op = instruction->handler_idx == VKD3DSIH_IDIV ? SpvOpSRem : SpvOpUMod;
 
     if (dst[0].reg.type != VKD3DSPR_NULL)
     {
@@ -6957,7 +7092,7 @@ static void spirv_compiler_emit_udiv(struct spirv_compiler *compiler,
         uint_max_id = spirv_compiler_get_constant_uint_vector(compiler,
                 0xffffffff, component_count);
 
-        val_id = vkd3d_spirv_build_op_udiv(builder, type_id, src0_id, src1_id);
+        val_id = vkd3d_spirv_build_op_tr2(builder, &builder->function_stream, div_op, type_id, src0_id, src1_id);
         /* The SPIR-V spec says: "The resulting value is undefined if Operand 2 is 0." */
         val_id = vkd3d_spirv_build_op_select(builder, type_id, condition_id, val_id, uint_max_id);
 
@@ -6980,7 +7115,7 @@ static void spirv_compiler_emit_udiv(struct spirv_compiler *compiler,
                     0xffffffff, component_count);
         }
 
-        val_id = vkd3d_spirv_build_op_umod(builder, type_id, src0_id, src1_id);
+        val_id = vkd3d_spirv_build_op_tr2(builder, &builder->function_stream, mod_op, type_id, src0_id, src1_id);
         /* The SPIR-V spec says: "The resulting value is undefined if Operand 2 is 0." */
         val_id = vkd3d_spirv_build_op_select(builder, type_id, condition_id, val_id, uint_max_id);
 
@@ -6988,6 +7123,106 @@ static void spirv_compiler_emit_udiv(struct spirv_compiler *compiler,
     }
 }
 
+static void spirv_compiler_emit_ftoi(struct spirv_compiler *compiler,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    uint32_t src_id, int_min_id, int_max_id, zero_id, float_max_id, condition_id, val_id;
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    const struct vkd3d_shader_dst_param *dst = instruction->dst;
+    const struct vkd3d_shader_src_param *src = instruction->src;
+    uint32_t src_type_id, dst_type_id, condition_type_id;
+    enum vkd3d_shader_component_type component_type;
+    unsigned int component_count;
+
+    assert(instruction->dst_count == 1);
+    assert(instruction->src_count == 1);
+
+    /* OpConvertFToI has undefined results if the result cannot be represented
+     * as a signed integer, but Direct3D expects the result to saturate,
+     * and for NaN to yield zero. */
+
+    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    src_type_id = spirv_compiler_get_type_id_for_reg(compiler, &src->reg, dst->write_mask);
+    dst_type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
+    src_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
+
+    if (src->reg.data_type == VKD3D_DATA_DOUBLE)
+    {
+        int_min_id = spirv_compiler_get_constant_double_vector(compiler, -2147483648.0, component_count);
+        float_max_id = spirv_compiler_get_constant_double_vector(compiler, 2147483648.0, component_count);
+    }
+    else
+    {
+        int_min_id = spirv_compiler_get_constant_float_vector(compiler, -2147483648.0f, component_count);
+        float_max_id = spirv_compiler_get_constant_float_vector(compiler, 2147483648.0f, component_count);
+    }
+
+    val_id = vkd3d_spirv_build_op_glsl_std450_max(builder, src_type_id, src_id, int_min_id);
+
+    /* VSIR allows the destination of a signed conversion to be unsigned. */
+    component_type = vkd3d_component_type_from_data_type(dst->reg.data_type);
+
+    int_max_id = spirv_compiler_get_constant_vector(compiler, component_type, component_count, INT_MAX);
+    condition_type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_BOOL, component_count);
+    condition_id = vkd3d_spirv_build_op_tr2(builder, &builder->function_stream,
+            SpvOpFOrdGreaterThanEqual, condition_type_id, val_id, float_max_id);
+
+    val_id = vkd3d_spirv_build_op_tr1(builder, &builder->function_stream, SpvOpConvertFToS, dst_type_id, val_id);
+    val_id = vkd3d_spirv_build_op_select(builder, dst_type_id, condition_id, int_max_id, val_id);
+
+    zero_id = spirv_compiler_get_constant_vector(compiler, component_type, component_count, 0);
+    condition_id = vkd3d_spirv_build_op_tr1(builder, &builder->function_stream, SpvOpIsNan, condition_type_id, src_id);
+    val_id = vkd3d_spirv_build_op_select(builder, dst_type_id, condition_id, zero_id, val_id);
+
+    spirv_compiler_emit_store_dst(compiler, dst, val_id);
+}
+
+static void spirv_compiler_emit_ftou(struct spirv_compiler *compiler,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    uint32_t src_id, zero_id, uint_max_id, float_max_id, condition_id, val_id;
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    const struct vkd3d_shader_dst_param *dst = instruction->dst;
+    const struct vkd3d_shader_src_param *src = instruction->src;
+    uint32_t src_type_id, dst_type_id, condition_type_id;
+    unsigned int component_count;
+
+    assert(instruction->dst_count == 1);
+    assert(instruction->src_count == 1);
+
+    /* OpConvertFToU has undefined results if the result cannot be represented
+     * as an unsigned integer, but Direct3D expects the result to saturate,
+     * and for NaN to yield zero. */
+
+    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    src_type_id = spirv_compiler_get_type_id_for_reg(compiler, &src->reg, dst->write_mask);
+    dst_type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
+    src_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
+
+    if (src->reg.data_type == VKD3D_DATA_DOUBLE)
+    {
+        zero_id = spirv_compiler_get_constant_double_vector(compiler, 0.0, component_count);
+        float_max_id = spirv_compiler_get_constant_double_vector(compiler, 4294967296.0, component_count);
+    }
+    else
+    {
+        zero_id = spirv_compiler_get_constant_float_vector(compiler, 0.0f, component_count);
+        float_max_id = spirv_compiler_get_constant_float_vector(compiler, 4294967296.0f, component_count);
+    }
+
+    val_id = vkd3d_spirv_build_op_glsl_std450_max(builder, src_type_id, src_id, zero_id);
+
+    uint_max_id = spirv_compiler_get_constant_uint_vector(compiler, UINT_MAX, component_count);
+    condition_type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_BOOL, component_count);
+    condition_id = vkd3d_spirv_build_op_tr2(builder, &builder->function_stream,
+            SpvOpFOrdGreaterThanEqual, condition_type_id, val_id, float_max_id);
+
+    val_id = vkd3d_spirv_build_op_tr1(builder, &builder->function_stream, SpvOpConvertFToU, dst_type_id, val_id);
+    val_id = vkd3d_spirv_build_op_select(builder, dst_type_id, condition_id, uint_max_id, val_id);
+
+    spirv_compiler_emit_store_dst(compiler, dst, val_id);
+}
+
 static void spirv_compiler_emit_bitfield_instruction(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
@@ -7123,18 +7358,22 @@ static void spirv_compiler_emit_comparison_instruction(struct spirv_compiler *co
 
     switch (instruction->handler_idx)
     {
-        case VKD3DSIH_DEQ:
-        case VKD3DSIH_EQ:  op = SpvOpFOrdEqual; break;
-        case VKD3DSIH_DGE:
-        case VKD3DSIH_GE:  op = SpvOpFOrdGreaterThanEqual; break;
+        case VKD3DSIH_DEQO:
+        case VKD3DSIH_EQO: op = SpvOpFOrdEqual; break;
+        case VKD3DSIH_EQU: op = SpvOpFUnordEqual; break;
+        case VKD3DSIH_DGEO:
+        case VKD3DSIH_GEO: op = SpvOpFOrdGreaterThanEqual; break;
+        case VKD3DSIH_GEU: op = SpvOpFUnordGreaterThanEqual; break;
         case VKD3DSIH_IEQ: op = SpvOpIEqual; break;
         case VKD3DSIH_IGE: op = SpvOpSGreaterThanEqual; break;
         case VKD3DSIH_ILT: op = SpvOpSLessThan; break;
         case VKD3DSIH_INE: op = SpvOpINotEqual; break;
         case VKD3DSIH_DLT:
-        case VKD3DSIH_LT:  op = SpvOpFOrdLessThan; break;
+        case VKD3DSIH_LTO: op = SpvOpFOrdLessThan; break;
+        case VKD3DSIH_LTU: op = SpvOpFUnordLessThan; break;
+        case VKD3DSIH_NEO: op = SpvOpFOrdNotEqual; break;
         case VKD3DSIH_DNE:
-        case VKD3DSIH_NE:  op = SpvOpFUnordNotEqual; break;
+        case VKD3DSIH_NEU: op = SpvOpFUnordNotEqual; break;
         case VKD3DSIH_UGE: op = SpvOpUGreaterThanEqual; break;
         case VKD3DSIH_ULT: op = SpvOpULessThan; break;
         default:
@@ -7151,7 +7390,8 @@ static void spirv_compiler_emit_comparison_instruction(struct spirv_compiler *co
     result_id = vkd3d_spirv_build_op_tr2(builder, &builder->function_stream,
             op, type_id, src0_id, src1_id);
 
-    result_id = spirv_compiler_emit_bool_to_int(compiler, component_count, result_id);
+    if (dst->reg.data_type != VKD3D_DATA_BOOL)
+        result_id = spirv_compiler_emit_bool_to_int(compiler, component_count, result_id, true);
     spirv_compiler_emit_store_reg(compiler, &dst->reg, dst->write_mask, result_id);
 }
 
@@ -9175,16 +9415,12 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_DCL_TGSM_STRUCTURED:
             spirv_compiler_emit_dcl_tgsm_structured(compiler, instruction);
             break;
+        case VKD3DSIH_DCL_INPUT_PS:
         case VKD3DSIH_DCL_INPUT:
             spirv_compiler_emit_dcl_input(compiler, instruction);
             break;
-        case VKD3DSIH_DCL_INPUT_PS:
-            spirv_compiler_emit_dcl_input_ps(compiler, instruction);
-            break;
         case VKD3DSIH_DCL_INPUT_PS_SGV:
         case VKD3DSIH_DCL_INPUT_PS_SIV:
-            spirv_compiler_emit_dcl_input_ps_sysval(compiler, instruction);
-            break;
         case VKD3DSIH_DCL_INPUT_SGV:
         case VKD3DSIH_DCL_INPUT_SIV:
             spirv_compiler_emit_dcl_input_sysval(compiler, instruction);
@@ -9210,11 +9446,7 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_DCL_GS_INSTANCES:
             spirv_compiler_emit_dcl_gs_instances(compiler, instruction);
             break;
-        case VKD3DSIH_DCL_INPUT_CONTROL_POINT_COUNT:
-            compiler->input_control_point_count = instruction->declaration.count;
-            break;
         case VKD3DSIH_DCL_OUTPUT_CONTROL_POINT_COUNT:
-            compiler->output_control_point_count = instruction->declaration.count;
             spirv_compiler_emit_output_vertex_count(compiler, instruction);
             break;
         case VKD3DSIH_DCL_TESSELLATOR_DOMAIN:
@@ -9256,25 +9488,24 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_DIV:
         case VKD3DSIH_DMUL:
         case VKD3DSIH_DTOF:
-        case VKD3DSIH_DTOI:
-        case VKD3DSIH_DTOU:
+        case VKD3DSIH_FREM:
         case VKD3DSIH_FTOD:
-        case VKD3DSIH_FTOI:
-        case VKD3DSIH_FTOU:
         case VKD3DSIH_IADD:
         case VKD3DSIH_INEG:
         case VKD3DSIH_ISHL:
         case VKD3DSIH_ISHR:
         case VKD3DSIH_ITOD:
         case VKD3DSIH_ITOF:
+        case VKD3DSIH_ITOI:
         case VKD3DSIH_MUL:
         case VKD3DSIH_NOT:
         case VKD3DSIH_OR:
         case VKD3DSIH_USHR:
         case VKD3DSIH_UTOD:
         case VKD3DSIH_UTOF:
+        case VKD3DSIH_UTOU:
         case VKD3DSIH_XOR:
-            spirv_compiler_emit_alu_instruction(compiler, instruction);
+            ret = spirv_compiler_emit_alu_instruction(compiler, instruction);
             break;
         case VKD3DSIH_DFMA:
         case VKD3DSIH_DMAX:
@@ -9313,26 +9544,40 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
             spirv_compiler_emit_sincos(compiler, instruction);
             break;
         case VKD3DSIH_IMUL:
+        case VKD3DSIH_UMUL:
             spirv_compiler_emit_imul(compiler, instruction);
             break;
         case VKD3DSIH_IMAD:
             spirv_compiler_emit_imad(compiler, instruction);
             break;
+        case VKD3DSIH_IDIV:
         case VKD3DSIH_UDIV:
-            spirv_compiler_emit_udiv(compiler, instruction);
+            spirv_compiler_emit_int_div(compiler, instruction);
             break;
-        case VKD3DSIH_DEQ:
-        case VKD3DSIH_DGE:
+        case VKD3DSIH_DTOI:
+        case VKD3DSIH_FTOI:
+            spirv_compiler_emit_ftoi(compiler, instruction);
+            break;
+        case VKD3DSIH_DTOU:
+        case VKD3DSIH_FTOU:
+            spirv_compiler_emit_ftou(compiler, instruction);
+            break;
+        case VKD3DSIH_DEQO:
+        case VKD3DSIH_DGEO:
         case VKD3DSIH_DLT:
         case VKD3DSIH_DNE:
-        case VKD3DSIH_EQ:
-        case VKD3DSIH_GE:
+        case VKD3DSIH_EQO:
+        case VKD3DSIH_EQU:
+        case VKD3DSIH_GEO:
+        case VKD3DSIH_GEU:
         case VKD3DSIH_IEQ:
         case VKD3DSIH_IGE:
         case VKD3DSIH_ILT:
         case VKD3DSIH_INE:
-        case VKD3DSIH_LT:
-        case VKD3DSIH_NE:
+        case VKD3DSIH_LTO:
+        case VKD3DSIH_LTU:
+        case VKD3DSIH_NEO:
+        case VKD3DSIH_NEU:
         case VKD3DSIH_UGE:
         case VKD3DSIH_ULT:
             spirv_compiler_emit_comparison_instruction(compiler, instruction);
@@ -9467,6 +9712,7 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_DCL:
         case VKD3DSIH_DCL_CONSTANT_BUFFER:
         case VKD3DSIH_DCL_HS_MAX_TESSFACTOR:
+        case VKD3DSIH_DCL_INPUT_CONTROL_POINT_COUNT:
         case VKD3DSIH_DCL_RESOURCE_RAW:
         case VKD3DSIH_DCL_RESOURCE_STRUCTURED:
         case VKD3DSIH_DCL_SAMPLER:
@@ -9480,6 +9726,9 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
             break;
         default:
             FIXME("Unhandled instruction %#x.\n", instruction->handler_idx);
+            spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_INVALID_HANDLER,
+                    "Encountered invalid/unhandled instruction handler %#x.", instruction->handler_idx);
+            break;
     }
 
     return ret;
@@ -9543,6 +9792,8 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
 
     if (parser->shader_desc.temp_count)
         spirv_compiler_emit_temps(compiler, parser->shader_desc.temp_count);
+    if (parser->shader_desc.ssa_count)
+        spirv_compiler_allocate_ssa_register_ids(compiler, parser->shader_desc.ssa_count);
 
     spirv_compiler_emit_descriptor_declarations(compiler);
 
@@ -9561,6 +9812,10 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
     memset(&shader_desc->input_signature, 0, sizeof(shader_desc->input_signature));
     memset(&shader_desc->output_signature, 0, sizeof(shader_desc->output_signature));
     memset(&shader_desc->patch_constant_signature, 0, sizeof(shader_desc->patch_constant_signature));
+    compiler->use_vocp = parser->shader_desc.use_vocp;
+
+    compiler->input_control_point_count = shader_desc->input_control_point_count;
+    compiler->output_control_point_count = shader_desc->output_control_point_count;
 
     if (compiler->shader_type != VKD3D_SHADER_TYPE_HULL)
         spirv_compiler_emit_shader_signature_outputs(compiler);
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index 045fb6c5f64..61d14e30d3c 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -146,6 +146,9 @@ STATIC_ASSERT(SM4_MAX_SRC_COUNT <= SPIRV_MAX_SRC_COUNT);
 #define VKD3D_SM4_SWIZZLE_SHIFT               4
 #define VKD3D_SM4_SWIZZLE_MASK                (0xffu << VKD3D_SM4_SWIZZLE_SHIFT)
 
+#define VKD3D_SM4_SCALAR_DIM_SHIFT            4
+#define VKD3D_SM4_SCALAR_DIM_MASK             (0x3u << VKD3D_SM4_SCALAR_DIM_SHIFT)
+
 #define VKD3D_SM4_VERSION_MAJOR(version)      (((version) >> 4) & 0xf)
 #define VKD3D_SM4_VERSION_MINOR(version)      (((version) >> 0) & 0xf)
 
@@ -383,6 +386,8 @@ enum vkd3d_sm4_opcode
     VKD3D_SM5_OP_SAMPLE_GRAD_CL_S                 = 0xe8,
     VKD3D_SM5_OP_SAMPLE_C_CL_S                    = 0xe9,
     VKD3D_SM5_OP_CHECK_ACCESS_FULLY_MAPPED        = 0xea,
+
+    VKD3D_SM4_OP_COUNT,
 };
 
 enum vkd3d_sm4_instruction_modifier
@@ -510,6 +515,9 @@ enum vkd3d_sm4_swizzle_type
     VKD3D_SM4_SWIZZLE_NONE            = 0x0, /* swizzle bitfield contains a mask */
     VKD3D_SM4_SWIZZLE_VEC4            = 0x1,
     VKD3D_SM4_SWIZZLE_SCALAR          = 0x2,
+
+    VKD3D_SM4_SWIZZLE_DEFAULT         = ~0u - 1,
+    VKD3D_SM4_SWIZZLE_INVALID         = ~0u,
 };
 
 enum vkd3d_sm4_dimension
@@ -519,6 +527,38 @@ enum vkd3d_sm4_dimension
     VKD3D_SM4_DIMENSION_VEC4    = 0x2,
 };
 
+static enum vsir_dimension vsir_dimension_from_sm4_dimension(enum vkd3d_sm4_dimension dim)
+{
+    switch (dim)
+    {
+        case VKD3D_SM4_DIMENSION_NONE:
+            return VSIR_DIMENSION_NONE;
+        case VKD3D_SM4_DIMENSION_SCALAR:
+            return VSIR_DIMENSION_SCALAR;
+        case VKD3D_SM4_DIMENSION_VEC4:
+            return VSIR_DIMENSION_VEC4;
+        default:
+            FIXME("Unknown SM4 dimension %#x.\n", dim);
+            return VSIR_DIMENSION_NONE;
+    }
+}
+
+static enum vkd3d_sm4_dimension sm4_dimension_from_vsir_dimension(enum vsir_dimension dim)
+{
+    switch (dim)
+    {
+        case VSIR_DIMENSION_NONE:
+            return VKD3D_SM4_DIMENSION_NONE;
+        case VSIR_DIMENSION_SCALAR:
+            return VKD3D_SM4_DIMENSION_SCALAR;
+        case VSIR_DIMENSION_VEC4:
+            return VKD3D_SM4_DIMENSION_VEC4;
+        case VSIR_DIMENSION_COUNT:
+            vkd3d_unreachable();
+    }
+    vkd3d_unreachable();
+}
+
 enum vkd3d_sm4_resource_type
 {
     VKD3D_SM4_RESOURCE_BUFFER             = 0x1,
@@ -575,6 +615,7 @@ struct sm4_index_range_array
 
 struct vkd3d_sm4_lookup_tables
 {
+    const struct vkd3d_sm4_opcode_info *opcode_info_from_sm4[VKD3D_SM4_OP_COUNT];
     const struct vkd3d_sm4_register_type_info *register_type_info_from_sm4[VKD3D_SM4_REGISTER_TYPE_COUNT];
     const struct vkd3d_sm4_register_type_info *register_type_info_from_vkd3d[VKD3DSPR_COUNT];
 };
@@ -583,8 +624,6 @@ struct vkd3d_shader_sm4_parser
 {
     const uint32_t *start, *end, *ptr;
 
-    unsigned int output_map[MAX_REG_OUTPUT];
-
     enum vkd3d_shader_opcode phase;
     bool has_control_point_phase;
     unsigned int input_register_masks[MAX_REG_OUTPUT];
@@ -620,16 +659,18 @@ static const enum vkd3d_primitive_type output_primitive_type_table[] =
     /* VKD3D_SM4_OUTPUT_PT_TRIANGLESTRIP */   VKD3D_PT_TRIANGLESTRIP,
 };
 
-static const enum vkd3d_primitive_type input_primitive_type_table[] =
+static const struct
 {
-    /* UNKNOWN */                             VKD3D_PT_UNDEFINED,
-    /* VKD3D_SM4_INPUT_PT_POINT */            VKD3D_PT_POINTLIST,
-    /* VKD3D_SM4_INPUT_PT_LINE */             VKD3D_PT_LINELIST,
-    /* VKD3D_SM4_INPUT_PT_TRIANGLE */         VKD3D_PT_TRIANGLELIST,
-    /* UNKNOWN */                             VKD3D_PT_UNDEFINED,
-    /* UNKNOWN */                             VKD3D_PT_UNDEFINED,
-    /* VKD3D_SM4_INPUT_PT_LINEADJ */          VKD3D_PT_LINELIST_ADJ,
-    /* VKD3D_SM4_INPUT_PT_TRIANGLEADJ */      VKD3D_PT_TRIANGLELIST_ADJ,
+    unsigned int control_point_count;
+    enum vkd3d_primitive_type vkd3d_type;
+}
+input_primitive_type_table[] =
+{
+    [VKD3D_SM4_INPUT_PT_POINT]          = {1, VKD3D_PT_POINTLIST},
+    [VKD3D_SM4_INPUT_PT_LINE]           = {2, VKD3D_PT_LINELIST},
+    [VKD3D_SM4_INPUT_PT_TRIANGLE]       = {3, VKD3D_PT_TRIANGLELIST},
+    [VKD3D_SM4_INPUT_PT_LINEADJ]        = {4, VKD3D_PT_LINELIST_ADJ},
+    [VKD3D_SM4_INPUT_PT_TRIANGLEADJ]    = {6, VKD3D_PT_TRIANGLELIST_ADJ},
 };
 
 static const enum vkd3d_shader_resource_type resource_type_table[] =
@@ -751,7 +792,9 @@ static void shader_sm4_read_shader_data(struct vkd3d_shader_instruction *ins, ui
         ins->handler_idx = VKD3DSIH_INVALID;
         return;
     }
-    icb->vec4_count = icb_size / 4;
+    icb->data_type = VKD3D_DATA_FLOAT;
+    icb->component_count = VKD3D_VEC4_SIZE;
+    icb->element_count = icb_size / VKD3D_VEC4_SIZE;
     memcpy(icb->data, tokens, sizeof(*tokens) * icb_size);
     shader_instruction_array_add_icb(&priv->p.instructions, icb);
     ins->declaration.icb = icb;
@@ -849,6 +892,8 @@ static void shader_sm4_read_dcl_constant_buffer(struct vkd3d_shader_instruction
         ins->declaration.cb.size = *tokens++;
         shader_sm4_read_register_space(priv, &tokens, end, &ins->declaration.cb.range.space);
     }
+
+    ins->declaration.cb.size *= VKD3D_VEC4_SIZE * sizeof(float);
 }
 
 static void shader_sm4_read_dcl_sampler(struct vkd3d_shader_instruction *ins, uint32_t opcode, uint32_t opcode_token,
@@ -994,6 +1039,7 @@ static void shader_sm4_read_dcl_input_primitive(struct vkd3d_shader_instruction
     {
         ins->declaration.primitive_type.type = VKD3D_PT_PATCH;
         ins->declaration.primitive_type.patch_vertex_count = primitive_type - VKD3D_SM5_INPUT_PT_PATCH1 + 1;
+        priv->p.shader_desc.input_control_point_count = ins->declaration.primitive_type.patch_vertex_count;
     }
     else if (primitive_type >= ARRAY_SIZE(input_primitive_type_table))
     {
@@ -1001,7 +1047,8 @@ static void shader_sm4_read_dcl_input_primitive(struct vkd3d_shader_instruction
     }
     else
     {
-        ins->declaration.primitive_type.type = input_primitive_type_table[primitive_type];
+        ins->declaration.primitive_type.type = input_primitive_type_table[primitive_type].vkd3d_type;
+        priv->p.shader_desc.input_control_point_count = input_primitive_type_table[primitive_type].control_point_count;
     }
 
     if (ins->declaration.primitive_type.type == VKD3D_PT_UNDEFINED)
@@ -1033,16 +1080,31 @@ static void shader_sm4_read_declaration_register_semantic(struct vkd3d_shader_in
 static void shader_sm4_read_dcl_input_ps(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
+    struct vkd3d_shader_dst_param *dst = &ins->declaration.dst;
+
     ins->flags = (opcode_token & VKD3D_SM4_INTERPOLATION_MODE_MASK) >> VKD3D_SM4_INTERPOLATION_MODE_SHIFT;
-    shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_FLOAT, &ins->declaration.dst);
+    if (shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_FLOAT, dst))
+    {
+        struct signature_element *e = vsir_signature_find_element_for_reg(
+                &priv->p.shader_desc.input_signature, dst->reg.idx[dst->reg.idx_count - 1].offset, dst->write_mask);
+
+        e->interpolation_mode = ins->flags;
+    }
 }
 
 static void shader_sm4_read_dcl_input_ps_siv(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
+    struct vkd3d_shader_dst_param *dst = &ins->declaration.register_semantic.reg;
+
     ins->flags = (opcode_token & VKD3D_SM4_INTERPOLATION_MODE_MASK) >> VKD3D_SM4_INTERPOLATION_MODE_SHIFT;
-    shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_FLOAT,
-            &ins->declaration.register_semantic.reg);
+    if (shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_FLOAT, dst))
+    {
+        struct signature_element *e = vsir_signature_find_element_for_reg(
+                &priv->p.shader_desc.input_signature, dst->reg.idx[dst->reg.idx_count - 1].offset, dst->write_mask);
+
+        e->interpolation_mode = ins->flags;
+    }
     ins->declaration.register_semantic.sysval_semantic = *tokens;
 }
 
@@ -1051,13 +1113,15 @@ static void shader_sm4_read_dcl_indexable_temp(struct vkd3d_shader_instruction *
 {
     ins->declaration.indexable_temp.register_idx = *tokens++;
     ins->declaration.indexable_temp.register_size = *tokens++;
+    ins->declaration.indexable_temp.alignment = 0;
+    ins->declaration.indexable_temp.data_type = VKD3D_DATA_FLOAT;
     ins->declaration.indexable_temp.component_count = *tokens;
 }
 
 static void shader_sm4_read_dcl_global_flags(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
-    ins->flags = (opcode_token & VKD3D_SM4_GLOBAL_FLAGS_MASK) >> VKD3D_SM4_GLOBAL_FLAGS_SHIFT;
+    ins->declaration.global_flags = (opcode_token & VKD3D_SM4_GLOBAL_FLAGS_MASK) >> VKD3D_SM4_GLOBAL_FLAGS_SHIFT;
 }
 
 static void shader_sm5_read_fcall(struct vkd3d_shader_instruction *ins, uint32_t opcode, uint32_t opcode_token,
@@ -1096,6 +1160,11 @@ static void shader_sm5_read_control_point_count(struct vkd3d_shader_instruction
 {
     ins->declaration.count = (opcode_token & VKD3D_SM5_CONTROL_POINT_COUNT_MASK)
             >> VKD3D_SM5_CONTROL_POINT_COUNT_SHIFT;
+
+    if (opcode == VKD3D_SM5_OP_DCL_INPUT_CONTROL_POINT_COUNT)
+        priv->p.shader_desc.input_control_point_count = ins->declaration.count;
+    else
+        priv->p.shader_desc.output_control_point_count = ins->declaration.count;
 }
 
 static void shader_sm5_read_dcl_tessellator_domain(struct vkd3d_shader_instruction *ins, uint32_t opcode,
@@ -1211,291 +1280,13 @@ static void shader_sm5_read_sync(struct vkd3d_shader_instruction *ins, uint32_t
     ins->flags = (opcode_token & VKD3D_SM5_SYNC_FLAGS_MASK) >> VKD3D_SM5_SYNC_FLAGS_SHIFT;
 }
 
-/*
- * d -> VKD3D_DATA_DOUBLE
- * f -> VKD3D_DATA_FLOAT
- * i -> VKD3D_DATA_INT
- * u -> VKD3D_DATA_UINT
- * O -> VKD3D_DATA_OPAQUE
- * R -> VKD3D_DATA_RESOURCE
- * S -> VKD3D_DATA_SAMPLER
- * U -> VKD3D_DATA_UAV
- */
-static const struct vkd3d_sm4_opcode_info opcode_table[] =
-{
-    {VKD3D_SM4_OP_ADD,                              VKD3DSIH_ADD,                              "f",    "ff"},
-    {VKD3D_SM4_OP_AND,                              VKD3DSIH_AND,                              "u",    "uu"},
-    {VKD3D_SM4_OP_BREAK,                            VKD3DSIH_BREAK,                            "",     ""},
-    {VKD3D_SM4_OP_BREAKC,                           VKD3DSIH_BREAKP,                           "",     "u",
-            shader_sm4_read_conditional_op},
-    {VKD3D_SM4_OP_CASE,                             VKD3DSIH_CASE,                             "",     "u",
-            shader_sm4_read_case_condition},
-    {VKD3D_SM4_OP_CONTINUE,                         VKD3DSIH_CONTINUE,                         "",     ""},
-    {VKD3D_SM4_OP_CONTINUEC,                        VKD3DSIH_CONTINUEP,                        "",     "u",
-            shader_sm4_read_conditional_op},
-    {VKD3D_SM4_OP_CUT,                              VKD3DSIH_CUT,                              "",     ""},
-    {VKD3D_SM4_OP_DEFAULT,                          VKD3DSIH_DEFAULT,                          "",     ""},
-    {VKD3D_SM4_OP_DERIV_RTX,                        VKD3DSIH_DSX,                              "f",    "f"},
-    {VKD3D_SM4_OP_DERIV_RTY,                        VKD3DSIH_DSY,                              "f",    "f"},
-    {VKD3D_SM4_OP_DISCARD,                          VKD3DSIH_DISCARD,                          "",     "u",
-            shader_sm4_read_conditional_op},
-    {VKD3D_SM4_OP_DIV,                              VKD3DSIH_DIV,                              "f",    "ff"},
-    {VKD3D_SM4_OP_DP2,                              VKD3DSIH_DP2,                              "f",    "ff"},
-    {VKD3D_SM4_OP_DP3,                              VKD3DSIH_DP3,                              "f",    "ff"},
-    {VKD3D_SM4_OP_DP4,                              VKD3DSIH_DP4,                              "f",    "ff"},
-    {VKD3D_SM4_OP_ELSE,                             VKD3DSIH_ELSE,                             "",     ""},
-    {VKD3D_SM4_OP_EMIT,                             VKD3DSIH_EMIT,                             "",     ""},
-    {VKD3D_SM4_OP_ENDIF,                            VKD3DSIH_ENDIF,                            "",     ""},
-    {VKD3D_SM4_OP_ENDLOOP,                          VKD3DSIH_ENDLOOP,                          "",     ""},
-    {VKD3D_SM4_OP_ENDSWITCH,                        VKD3DSIH_ENDSWITCH,                        "",     ""},
-    {VKD3D_SM4_OP_EQ,                               VKD3DSIH_EQ,                               "u",    "ff"},
-    {VKD3D_SM4_OP_EXP,                              VKD3DSIH_EXP,                              "f",    "f"},
-    {VKD3D_SM4_OP_FRC,                              VKD3DSIH_FRC,                              "f",    "f"},
-    {VKD3D_SM4_OP_FTOI,                             VKD3DSIH_FTOI,                             "i",    "f"},
-    {VKD3D_SM4_OP_FTOU,                             VKD3DSIH_FTOU,                             "u",    "f"},
-    {VKD3D_SM4_OP_GE,                               VKD3DSIH_GE,                               "u",    "ff"},
-    {VKD3D_SM4_OP_IADD,                             VKD3DSIH_IADD,                             "i",    "ii"},
-    {VKD3D_SM4_OP_IF,                               VKD3DSIH_IF,                               "",     "u",
-            shader_sm4_read_conditional_op},
-    {VKD3D_SM4_OP_IEQ,                              VKD3DSIH_IEQ,                              "u",    "ii"},
-    {VKD3D_SM4_OP_IGE,                              VKD3DSIH_IGE,                              "u",    "ii"},
-    {VKD3D_SM4_OP_ILT,                              VKD3DSIH_ILT,                              "u",    "ii"},
-    {VKD3D_SM4_OP_IMAD,                             VKD3DSIH_IMAD,                             "i",    "iii"},
-    {VKD3D_SM4_OP_IMAX,                             VKD3DSIH_IMAX,                             "i",    "ii"},
-    {VKD3D_SM4_OP_IMIN,                             VKD3DSIH_IMIN,                             "i",    "ii"},
-    {VKD3D_SM4_OP_IMUL,                             VKD3DSIH_IMUL,                             "ii",   "ii"},
-    {VKD3D_SM4_OP_INE,                              VKD3DSIH_INE,                              "u",    "ii"},
-    {VKD3D_SM4_OP_INEG,                             VKD3DSIH_INEG,                             "i",    "i"},
-    {VKD3D_SM4_OP_ISHL,                             VKD3DSIH_ISHL,                             "i",    "ii"},
-    {VKD3D_SM4_OP_ISHR,                             VKD3DSIH_ISHR,                             "i",    "ii"},
-    {VKD3D_SM4_OP_ITOF,                             VKD3DSIH_ITOF,                             "f",    "i"},
-    {VKD3D_SM4_OP_LABEL,                            VKD3DSIH_LABEL,                            "",     "O"},
-    {VKD3D_SM4_OP_LD,                               VKD3DSIH_LD,                               "u",    "iR"},
-    {VKD3D_SM4_OP_LD2DMS,                           VKD3DSIH_LD2DMS,                           "u",    "iRi"},
-    {VKD3D_SM4_OP_LOG,                              VKD3DSIH_LOG,                              "f",    "f"},
-    {VKD3D_SM4_OP_LOOP,                             VKD3DSIH_LOOP,                             "",     ""},
-    {VKD3D_SM4_OP_LT,                               VKD3DSIH_LT,                               "u",    "ff"},
-    {VKD3D_SM4_OP_MAD,                              VKD3DSIH_MAD,                              "f",    "fff"},
-    {VKD3D_SM4_OP_MIN,                              VKD3DSIH_MIN,                              "f",    "ff"},
-    {VKD3D_SM4_OP_MAX,                              VKD3DSIH_MAX,                              "f",    "ff"},
-    {VKD3D_SM4_OP_SHADER_DATA,                      VKD3DSIH_DCL_IMMEDIATE_CONSTANT_BUFFER,    "",     "",
-            shader_sm4_read_shader_data},
-    {VKD3D_SM4_OP_MOV,                              VKD3DSIH_MOV,                              "f",    "f"},
-    {VKD3D_SM4_OP_MOVC,                             VKD3DSIH_MOVC,                             "f",    "uff"},
-    {VKD3D_SM4_OP_MUL,                              VKD3DSIH_MUL,                              "f",    "ff"},
-    {VKD3D_SM4_OP_NE,                               VKD3DSIH_NE,                               "u",    "ff"},
-    {VKD3D_SM4_OP_NOP,                              VKD3DSIH_NOP,                              "",     ""},
-    {VKD3D_SM4_OP_NOT,                              VKD3DSIH_NOT,                              "u",    "u"},
-    {VKD3D_SM4_OP_OR,                               VKD3DSIH_OR,                               "u",    "uu"},
-    {VKD3D_SM4_OP_RESINFO,                          VKD3DSIH_RESINFO,                          "f",    "iR"},
-    {VKD3D_SM4_OP_RET,                              VKD3DSIH_RET,                              "",     ""},
-    {VKD3D_SM4_OP_RETC,                             VKD3DSIH_RETP,                             "",     "u",
-            shader_sm4_read_conditional_op},
-    {VKD3D_SM4_OP_ROUND_NE,                         VKD3DSIH_ROUND_NE,                         "f",    "f"},
-    {VKD3D_SM4_OP_ROUND_NI,                         VKD3DSIH_ROUND_NI,                         "f",    "f"},
-    {VKD3D_SM4_OP_ROUND_PI,                         VKD3DSIH_ROUND_PI,                         "f",    "f"},
-    {VKD3D_SM4_OP_ROUND_Z,                          VKD3DSIH_ROUND_Z,                          "f",    "f"},
-    {VKD3D_SM4_OP_RSQ,                              VKD3DSIH_RSQ,                              "f",    "f"},
-    {VKD3D_SM4_OP_SAMPLE,                           VKD3DSIH_SAMPLE,                           "u",    "fRS"},
-    {VKD3D_SM4_OP_SAMPLE_C,                         VKD3DSIH_SAMPLE_C,                         "f",    "fRSf"},
-    {VKD3D_SM4_OP_SAMPLE_C_LZ,                      VKD3DSIH_SAMPLE_C_LZ,                      "f",    "fRSf"},
-    {VKD3D_SM4_OP_SAMPLE_LOD,                       VKD3DSIH_SAMPLE_LOD,                       "u",    "fRSf"},
-    {VKD3D_SM4_OP_SAMPLE_GRAD,                      VKD3DSIH_SAMPLE_GRAD,                      "u",    "fRSff"},
-    {VKD3D_SM4_OP_SAMPLE_B,                         VKD3DSIH_SAMPLE_B,                         "u",    "fRSf"},
-    {VKD3D_SM4_OP_SQRT,                             VKD3DSIH_SQRT,                             "f",    "f"},
-    {VKD3D_SM4_OP_SWITCH,                           VKD3DSIH_SWITCH,                           "",     "i"},
-    {VKD3D_SM4_OP_SINCOS,                           VKD3DSIH_SINCOS,                           "ff",   "f"},
-    {VKD3D_SM4_OP_UDIV,                             VKD3DSIH_UDIV,                             "uu",   "uu"},
-    {VKD3D_SM4_OP_ULT,                              VKD3DSIH_ULT,                              "u",    "uu"},
-    {VKD3D_SM4_OP_UGE,                              VKD3DSIH_UGE,                              "u",    "uu"},
-    {VKD3D_SM4_OP_UMUL,                             VKD3DSIH_UMUL,                             "uu",   "uu"},
-    {VKD3D_SM4_OP_UMAX,                             VKD3DSIH_UMAX,                             "u",    "uu"},
-    {VKD3D_SM4_OP_UMIN,                             VKD3DSIH_UMIN,                             "u",    "uu"},
-    {VKD3D_SM4_OP_USHR,                             VKD3DSIH_USHR,                             "u",    "uu"},
-    {VKD3D_SM4_OP_UTOF,                             VKD3DSIH_UTOF,                             "f",    "u"},
-    {VKD3D_SM4_OP_XOR,                              VKD3DSIH_XOR,                              "u",    "uu"},
-    {VKD3D_SM4_OP_DCL_RESOURCE,                     VKD3DSIH_DCL,                              "",     "",
-            shader_sm4_read_dcl_resource},
-    {VKD3D_SM4_OP_DCL_CONSTANT_BUFFER,              VKD3DSIH_DCL_CONSTANT_BUFFER,              "",     "",
-            shader_sm4_read_dcl_constant_buffer},
-    {VKD3D_SM4_OP_DCL_SAMPLER,                      VKD3DSIH_DCL_SAMPLER,                      "",     "",
-            shader_sm4_read_dcl_sampler},
-    {VKD3D_SM4_OP_DCL_INDEX_RANGE,                  VKD3DSIH_DCL_INDEX_RANGE,                  "",     "",
-            shader_sm4_read_dcl_index_range},
-    {VKD3D_SM4_OP_DCL_OUTPUT_TOPOLOGY,              VKD3DSIH_DCL_OUTPUT_TOPOLOGY,              "",     "",
-            shader_sm4_read_dcl_output_topology},
-    {VKD3D_SM4_OP_DCL_INPUT_PRIMITIVE,              VKD3DSIH_DCL_INPUT_PRIMITIVE,              "",     "",
-            shader_sm4_read_dcl_input_primitive},
-    {VKD3D_SM4_OP_DCL_VERTICES_OUT,                 VKD3DSIH_DCL_VERTICES_OUT,                 "",     "",
-            shader_sm4_read_declaration_count},
-    {VKD3D_SM4_OP_DCL_INPUT,                        VKD3DSIH_DCL_INPUT,                        "",     "",
-            shader_sm4_read_declaration_dst},
-    {VKD3D_SM4_OP_DCL_INPUT_SGV,                    VKD3DSIH_DCL_INPUT_SGV,                    "",     "",
-            shader_sm4_read_declaration_register_semantic},
-    {VKD3D_SM4_OP_DCL_INPUT_SIV,                    VKD3DSIH_DCL_INPUT_SIV,                    "",     "",
-            shader_sm4_read_declaration_register_semantic},
-    {VKD3D_SM4_OP_DCL_INPUT_PS,                     VKD3DSIH_DCL_INPUT_PS,                     "",     "",
-            shader_sm4_read_dcl_input_ps},
-    {VKD3D_SM4_OP_DCL_INPUT_PS_SGV,                 VKD3DSIH_DCL_INPUT_PS_SGV,                 "",     "",
-            shader_sm4_read_declaration_register_semantic},
-    {VKD3D_SM4_OP_DCL_INPUT_PS_SIV,                 VKD3DSIH_DCL_INPUT_PS_SIV,                 "",     "",
-            shader_sm4_read_dcl_input_ps_siv},
-    {VKD3D_SM4_OP_DCL_OUTPUT,                       VKD3DSIH_DCL_OUTPUT,                       "",     "",
-            shader_sm4_read_declaration_dst},
-    {VKD3D_SM4_OP_DCL_OUTPUT_SIV,                   VKD3DSIH_DCL_OUTPUT_SIV,                   "",     "",
-            shader_sm4_read_declaration_register_semantic},
-    {VKD3D_SM4_OP_DCL_TEMPS,                        VKD3DSIH_DCL_TEMPS,                        "",     "",
-            shader_sm4_read_declaration_count},
-    {VKD3D_SM4_OP_DCL_INDEXABLE_TEMP,               VKD3DSIH_DCL_INDEXABLE_TEMP,               "",     "",
-            shader_sm4_read_dcl_indexable_temp},
-    {VKD3D_SM4_OP_DCL_GLOBAL_FLAGS,                 VKD3DSIH_DCL_GLOBAL_FLAGS,                 "",     "",
-            shader_sm4_read_dcl_global_flags},
-    {VKD3D_SM4_OP_LOD,                              VKD3DSIH_LOD,                              "f",    "fRS"},
-    {VKD3D_SM4_OP_GATHER4,                          VKD3DSIH_GATHER4,                          "u",    "fRS"},
-    {VKD3D_SM4_OP_SAMPLE_POS,                       VKD3DSIH_SAMPLE_POS,                       "f",    "Ru"},
-    {VKD3D_SM4_OP_SAMPLE_INFO,                      VKD3DSIH_SAMPLE_INFO,                      "f",    "R"},
-    {VKD3D_SM5_OP_HS_DECLS,                         VKD3DSIH_HS_DECLS,                         "",     ""},
-    {VKD3D_SM5_OP_HS_CONTROL_POINT_PHASE,           VKD3DSIH_HS_CONTROL_POINT_PHASE,           "",     ""},
-    {VKD3D_SM5_OP_HS_FORK_PHASE,                    VKD3DSIH_HS_FORK_PHASE,                    "",     ""},
-    {VKD3D_SM5_OP_HS_JOIN_PHASE,                    VKD3DSIH_HS_JOIN_PHASE,                    "",     ""},
-    {VKD3D_SM5_OP_EMIT_STREAM,                      VKD3DSIH_EMIT_STREAM,                      "",     "f"},
-    {VKD3D_SM5_OP_CUT_STREAM,                       VKD3DSIH_CUT_STREAM,                       "",     "f"},
-    {VKD3D_SM5_OP_FCALL,                            VKD3DSIH_FCALL,                            "",     "O",
-            shader_sm5_read_fcall},
-    {VKD3D_SM5_OP_BUFINFO,                          VKD3DSIH_BUFINFO,                          "i",    "U"},
-    {VKD3D_SM5_OP_DERIV_RTX_COARSE,                 VKD3DSIH_DSX_COARSE,                       "f",    "f"},
-    {VKD3D_SM5_OP_DERIV_RTX_FINE,                   VKD3DSIH_DSX_FINE,                         "f",    "f"},
-    {VKD3D_SM5_OP_DERIV_RTY_COARSE,                 VKD3DSIH_DSY_COARSE,                       "f",    "f"},
-    {VKD3D_SM5_OP_DERIV_RTY_FINE,                   VKD3DSIH_DSY_FINE,                         "f",    "f"},
-    {VKD3D_SM5_OP_GATHER4_C,                        VKD3DSIH_GATHER4_C,                        "f",    "fRSf"},
-    {VKD3D_SM5_OP_GATHER4_PO,                       VKD3DSIH_GATHER4_PO,                       "f",    "fiRS"},
-    {VKD3D_SM5_OP_GATHER4_PO_C,                     VKD3DSIH_GATHER4_PO_C,                     "f",    "fiRSf"},
-    {VKD3D_SM5_OP_RCP,                              VKD3DSIH_RCP,                              "f",    "f"},
-    {VKD3D_SM5_OP_F32TOF16,                         VKD3DSIH_F32TOF16,                         "u",    "f"},
-    {VKD3D_SM5_OP_F16TOF32,                         VKD3DSIH_F16TOF32,                         "f",    "u"},
-    {VKD3D_SM5_OP_COUNTBITS,                        VKD3DSIH_COUNTBITS,                        "u",    "u"},
-    {VKD3D_SM5_OP_FIRSTBIT_HI,                      VKD3DSIH_FIRSTBIT_HI,                      "u",    "u"},
-    {VKD3D_SM5_OP_FIRSTBIT_LO,                      VKD3DSIH_FIRSTBIT_LO,                      "u",    "u"},
-    {VKD3D_SM5_OP_FIRSTBIT_SHI,                     VKD3DSIH_FIRSTBIT_SHI,                     "u",    "i"},
-    {VKD3D_SM5_OP_UBFE,                             VKD3DSIH_UBFE,                             "u",    "iiu"},
-    {VKD3D_SM5_OP_IBFE,                             VKD3DSIH_IBFE,                             "i",    "iii"},
-    {VKD3D_SM5_OP_BFI,                              VKD3DSIH_BFI,                              "u",    "iiuu"},
-    {VKD3D_SM5_OP_BFREV,                            VKD3DSIH_BFREV,                            "u",    "u"},
-    {VKD3D_SM5_OP_SWAPC,                            VKD3DSIH_SWAPC,                            "ff",   "uff"},
-    {VKD3D_SM5_OP_DCL_STREAM,                       VKD3DSIH_DCL_STREAM,                       "",     "O"},
-    {VKD3D_SM5_OP_DCL_FUNCTION_BODY,                VKD3DSIH_DCL_FUNCTION_BODY,                "",     "",
-            shader_sm5_read_dcl_function_body},
-    {VKD3D_SM5_OP_DCL_FUNCTION_TABLE,               VKD3DSIH_DCL_FUNCTION_TABLE,               "",     "",
-            shader_sm5_read_dcl_function_table},
-    {VKD3D_SM5_OP_DCL_INTERFACE,                    VKD3DSIH_DCL_INTERFACE,                    "",     "",
-            shader_sm5_read_dcl_interface},
-    {VKD3D_SM5_OP_DCL_INPUT_CONTROL_POINT_COUNT,    VKD3DSIH_DCL_INPUT_CONTROL_POINT_COUNT,    "",     "",
-            shader_sm5_read_control_point_count},
-    {VKD3D_SM5_OP_DCL_OUTPUT_CONTROL_POINT_COUNT,   VKD3DSIH_DCL_OUTPUT_CONTROL_POINT_COUNT,   "",     "",
-            shader_sm5_read_control_point_count},
-    {VKD3D_SM5_OP_DCL_TESSELLATOR_DOMAIN,           VKD3DSIH_DCL_TESSELLATOR_DOMAIN,           "",     "",
-            shader_sm5_read_dcl_tessellator_domain},
-    {VKD3D_SM5_OP_DCL_TESSELLATOR_PARTITIONING,     VKD3DSIH_DCL_TESSELLATOR_PARTITIONING,     "",     "",
-            shader_sm5_read_dcl_tessellator_partitioning},
-    {VKD3D_SM5_OP_DCL_TESSELLATOR_OUTPUT_PRIMITIVE, VKD3DSIH_DCL_TESSELLATOR_OUTPUT_PRIMITIVE, "",     "",
-            shader_sm5_read_dcl_tessellator_output_primitive},
-    {VKD3D_SM5_OP_DCL_HS_MAX_TESSFACTOR,            VKD3DSIH_DCL_HS_MAX_TESSFACTOR,            "",     "",
-            shader_sm5_read_dcl_hs_max_tessfactor},
-    {VKD3D_SM5_OP_DCL_HS_FORK_PHASE_INSTANCE_COUNT, VKD3DSIH_DCL_HS_FORK_PHASE_INSTANCE_COUNT, "",     "",
-            shader_sm4_read_declaration_count},
-    {VKD3D_SM5_OP_DCL_HS_JOIN_PHASE_INSTANCE_COUNT, VKD3DSIH_DCL_HS_JOIN_PHASE_INSTANCE_COUNT, "",     "",
-            shader_sm4_read_declaration_count},
-    {VKD3D_SM5_OP_DCL_THREAD_GROUP,                 VKD3DSIH_DCL_THREAD_GROUP,                 "",     "",
-            shader_sm5_read_dcl_thread_group},
-    {VKD3D_SM5_OP_DCL_UAV_TYPED,                    VKD3DSIH_DCL_UAV_TYPED,                    "",     "",
-            shader_sm4_read_dcl_resource},
-    {VKD3D_SM5_OP_DCL_UAV_RAW,                      VKD3DSIH_DCL_UAV_RAW,                      "",     "",
-            shader_sm5_read_dcl_uav_raw},
-    {VKD3D_SM5_OP_DCL_UAV_STRUCTURED,               VKD3DSIH_DCL_UAV_STRUCTURED,               "",     "",
-            shader_sm5_read_dcl_uav_structured},
-    {VKD3D_SM5_OP_DCL_TGSM_RAW,                     VKD3DSIH_DCL_TGSM_RAW,                     "",     "",
-            shader_sm5_read_dcl_tgsm_raw},
-    {VKD3D_SM5_OP_DCL_TGSM_STRUCTURED,              VKD3DSIH_DCL_TGSM_STRUCTURED,              "",     "",
-            shader_sm5_read_dcl_tgsm_structured},
-    {VKD3D_SM5_OP_DCL_RESOURCE_RAW,                 VKD3DSIH_DCL_RESOURCE_RAW,                 "",     "",
-            shader_sm5_read_dcl_resource_raw},
-    {VKD3D_SM5_OP_DCL_RESOURCE_STRUCTURED,          VKD3DSIH_DCL_RESOURCE_STRUCTURED,          "",     "",
-            shader_sm5_read_dcl_resource_structured},
-    {VKD3D_SM5_OP_LD_UAV_TYPED,                     VKD3DSIH_LD_UAV_TYPED,                     "u",    "iU"},
-    {VKD3D_SM5_OP_STORE_UAV_TYPED,                  VKD3DSIH_STORE_UAV_TYPED,                  "U",    "iu"},
-    {VKD3D_SM5_OP_LD_RAW,                           VKD3DSIH_LD_RAW,                           "u",    "iU"},
-    {VKD3D_SM5_OP_STORE_RAW,                        VKD3DSIH_STORE_RAW,                        "U",    "uu"},
-    {VKD3D_SM5_OP_LD_STRUCTURED,                    VKD3DSIH_LD_STRUCTURED,                    "u",    "iiR"},
-    {VKD3D_SM5_OP_STORE_STRUCTURED,                 VKD3DSIH_STORE_STRUCTURED,                 "U",    "iiu"},
-    {VKD3D_SM5_OP_ATOMIC_AND,                       VKD3DSIH_ATOMIC_AND,                       "U",    "iu"},
-    {VKD3D_SM5_OP_ATOMIC_OR,                        VKD3DSIH_ATOMIC_OR,                        "U",    "iu"},
-    {VKD3D_SM5_OP_ATOMIC_XOR,                       VKD3DSIH_ATOMIC_XOR,                       "U",    "iu"},
-    {VKD3D_SM5_OP_ATOMIC_CMP_STORE,                 VKD3DSIH_ATOMIC_CMP_STORE,                 "U",    "iuu"},
-    {VKD3D_SM5_OP_ATOMIC_IADD,                      VKD3DSIH_ATOMIC_IADD,                      "U",    "ii"},
-    {VKD3D_SM5_OP_ATOMIC_IMAX,                      VKD3DSIH_ATOMIC_IMAX,                      "U",    "ii"},
-    {VKD3D_SM5_OP_ATOMIC_IMIN,                      VKD3DSIH_ATOMIC_IMIN,                      "U",    "ii"},
-    {VKD3D_SM5_OP_ATOMIC_UMAX,                      VKD3DSIH_ATOMIC_UMAX,                      "U",    "iu"},
-    {VKD3D_SM5_OP_ATOMIC_UMIN,                      VKD3DSIH_ATOMIC_UMIN,                      "U",    "iu"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_ALLOC,                 VKD3DSIH_IMM_ATOMIC_ALLOC,                 "u",    "U"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_CONSUME,               VKD3DSIH_IMM_ATOMIC_CONSUME,               "u",    "U"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_IADD,                  VKD3DSIH_IMM_ATOMIC_IADD,                  "uU",   "ii"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_AND,                   VKD3DSIH_IMM_ATOMIC_AND,                   "uU",   "iu"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_OR,                    VKD3DSIH_IMM_ATOMIC_OR,                    "uU",   "iu"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_XOR,                   VKD3DSIH_IMM_ATOMIC_XOR,                   "uU",   "iu"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_EXCH,                  VKD3DSIH_IMM_ATOMIC_EXCH,                  "uU",   "iu"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_CMP_EXCH,              VKD3DSIH_IMM_ATOMIC_CMP_EXCH,              "uU",   "iuu"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_IMAX,                  VKD3DSIH_IMM_ATOMIC_IMAX,                  "iU",   "ii"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_IMIN,                  VKD3DSIH_IMM_ATOMIC_IMIN,                  "iU",   "ii"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_UMAX,                  VKD3DSIH_IMM_ATOMIC_UMAX,                  "uU",   "iu"},
-    {VKD3D_SM5_OP_IMM_ATOMIC_UMIN,                  VKD3DSIH_IMM_ATOMIC_UMIN,                  "uU",   "iu"},
-    {VKD3D_SM5_OP_SYNC,                             VKD3DSIH_SYNC,                             "",     "",
-            shader_sm5_read_sync},
-    {VKD3D_SM5_OP_DADD,                             VKD3DSIH_DADD,                             "d",    "dd"},
-    {VKD3D_SM5_OP_DMAX,                             VKD3DSIH_DMAX,                             "d",    "dd"},
-    {VKD3D_SM5_OP_DMIN,                             VKD3DSIH_DMIN,                             "d",    "dd"},
-    {VKD3D_SM5_OP_DMUL,                             VKD3DSIH_DMUL,                             "d",    "dd"},
-    {VKD3D_SM5_OP_DEQ,                              VKD3DSIH_DEQ,                              "u",    "dd"},
-    {VKD3D_SM5_OP_DGE,                              VKD3DSIH_DGE,                              "u",    "dd"},
-    {VKD3D_SM5_OP_DLT,                              VKD3DSIH_DLT,                              "u",    "dd"},
-    {VKD3D_SM5_OP_DNE,                              VKD3DSIH_DNE,                              "u",    "dd"},
-    {VKD3D_SM5_OP_DMOV,                             VKD3DSIH_DMOV,                             "d",    "d"},
-    {VKD3D_SM5_OP_DMOVC,                            VKD3DSIH_DMOVC,                            "d",    "udd"},
-    {VKD3D_SM5_OP_DTOF,                             VKD3DSIH_DTOF,                             "f",    "d"},
-    {VKD3D_SM5_OP_FTOD,                             VKD3DSIH_FTOD,                             "d",    "f"},
-    {VKD3D_SM5_OP_EVAL_SAMPLE_INDEX,                VKD3DSIH_EVAL_SAMPLE_INDEX,                "f",    "fi"},
-    {VKD3D_SM5_OP_EVAL_CENTROID,                    VKD3DSIH_EVAL_CENTROID,                    "f",    "f"},
-    {VKD3D_SM5_OP_DCL_GS_INSTANCES,                 VKD3DSIH_DCL_GS_INSTANCES,                 "",     "",
-            shader_sm4_read_declaration_count},
-    {VKD3D_SM5_OP_DDIV,                             VKD3DSIH_DDIV,                             "d",    "dd"},
-    {VKD3D_SM5_OP_DFMA,                             VKD3DSIH_DFMA,                             "d",    "ddd"},
-    {VKD3D_SM5_OP_DRCP,                             VKD3DSIH_DRCP,                             "d",    "d"},
-    {VKD3D_SM5_OP_MSAD,                             VKD3DSIH_MSAD,                             "u",    "uuu"},
-    {VKD3D_SM5_OP_DTOI,                             VKD3DSIH_DTOI,                             "i",    "d"},
-    {VKD3D_SM5_OP_DTOU,                             VKD3DSIH_DTOU,                             "u",    "d"},
-    {VKD3D_SM5_OP_ITOD,                             VKD3DSIH_ITOD,                             "d",    "i"},
-    {VKD3D_SM5_OP_UTOD,                             VKD3DSIH_UTOD,                             "d",    "u"},
-    {VKD3D_SM5_OP_GATHER4_S,                        VKD3DSIH_GATHER4_S,                        "uu",   "fRS"},
-    {VKD3D_SM5_OP_GATHER4_C_S,                      VKD3DSIH_GATHER4_C_S,                      "fu",   "fRSf"},
-    {VKD3D_SM5_OP_GATHER4_PO_S,                     VKD3DSIH_GATHER4_PO_S,                     "fu",   "fiRS"},
-    {VKD3D_SM5_OP_GATHER4_PO_C_S,                   VKD3DSIH_GATHER4_PO_C_S,                   "fu",   "fiRSf"},
-    {VKD3D_SM5_OP_LD_S,                             VKD3DSIH_LD_S,                             "uu",   "iR"},
-    {VKD3D_SM5_OP_LD2DMS_S,                         VKD3DSIH_LD2DMS_S,                         "uu",   "iRi"},
-    {VKD3D_SM5_OP_LD_UAV_TYPED_S,                   VKD3DSIH_LD_UAV_TYPED_S,                   "uu",   "iU"},
-    {VKD3D_SM5_OP_LD_RAW_S,                         VKD3DSIH_LD_RAW_S,                         "uu",   "iU"},
-    {VKD3D_SM5_OP_LD_STRUCTURED_S,                  VKD3DSIH_LD_STRUCTURED_S,                  "uu",   "iiR"},
-    {VKD3D_SM5_OP_SAMPLE_LOD_S,                     VKD3DSIH_SAMPLE_LOD_S,                     "uu",   "fRSf"},
-    {VKD3D_SM5_OP_SAMPLE_C_LZ_S,                    VKD3DSIH_SAMPLE_C_LZ_S,                    "fu",   "fRSf"},
-    {VKD3D_SM5_OP_SAMPLE_CL_S,                      VKD3DSIH_SAMPLE_CL_S,                      "uu",   "fRSf"},
-    {VKD3D_SM5_OP_SAMPLE_B_CL_S,                    VKD3DSIH_SAMPLE_B_CL_S,                    "uu",   "fRSff"},
-    {VKD3D_SM5_OP_SAMPLE_GRAD_CL_S,                 VKD3DSIH_SAMPLE_GRAD_CL_S,                 "uu",   "fRSfff"},
-    {VKD3D_SM5_OP_SAMPLE_C_CL_S,                    VKD3DSIH_SAMPLE_C_CL_S,                    "fu",   "fRSff"},
-    {VKD3D_SM5_OP_CHECK_ACCESS_FULLY_MAPPED,        VKD3DSIH_CHECK_ACCESS_FULLY_MAPPED,        "u",    "u"},
-};
-
 struct vkd3d_sm4_register_type_info
 {
     enum vkd3d_sm4_register_type sm4_type;
     enum vkd3d_shader_register_type vkd3d_type;
+
+    /* Swizzle type to be used for src registers when their dimension is VKD3D_SM4_DIMENSION_VEC4. */
+    enum vkd3d_sm4_swizzle_type default_src_swizzle_type;
 };
 
 static const enum vkd3d_shader_register_precision register_precision_table[] =
@@ -1515,69 +1306,344 @@ struct tpf_writer
     struct vkd3d_sm4_lookup_tables lookup;
 };
 
-static const struct vkd3d_sm4_opcode_info *get_opcode_info(enum vkd3d_sm4_opcode opcode)
-{
-    unsigned int i;
-
-    for (i = 0; i < sizeof(opcode_table) / sizeof(*opcode_table); ++i)
-    {
-        if (opcode == opcode_table[i].opcode)
-            return &opcode_table[i];
-    }
-
-    return NULL;
-}
-
 static void init_sm4_lookup_tables(struct vkd3d_sm4_lookup_tables *lookup)
 {
-    const struct vkd3d_sm4_register_type_info *info;
     unsigned int i;
 
+    /*
+     * d -> VKD3D_DATA_DOUBLE
+     * f -> VKD3D_DATA_FLOAT
+     * i -> VKD3D_DATA_INT
+     * u -> VKD3D_DATA_UINT
+     * O -> VKD3D_DATA_OPAQUE
+     * R -> VKD3D_DATA_RESOURCE
+     * S -> VKD3D_DATA_SAMPLER
+     * U -> VKD3D_DATA_UAV
+     */
+    static const struct vkd3d_sm4_opcode_info opcode_table[] =
+    {
+        {VKD3D_SM4_OP_ADD,                              VKD3DSIH_ADD,                              "f",    "ff"},
+        {VKD3D_SM4_OP_AND,                              VKD3DSIH_AND,                              "u",    "uu"},
+        {VKD3D_SM4_OP_BREAK,                            VKD3DSIH_BREAK,                            "",     ""},
+        {VKD3D_SM4_OP_BREAKC,                           VKD3DSIH_BREAKP,                           "",     "u",
+                shader_sm4_read_conditional_op},
+        {VKD3D_SM4_OP_CASE,                             VKD3DSIH_CASE,                             "",     "u",
+                shader_sm4_read_case_condition},
+        {VKD3D_SM4_OP_CONTINUE,                         VKD3DSIH_CONTINUE,                         "",     ""},
+        {VKD3D_SM4_OP_CONTINUEC,                        VKD3DSIH_CONTINUEP,                        "",     "u",
+                shader_sm4_read_conditional_op},
+        {VKD3D_SM4_OP_CUT,                              VKD3DSIH_CUT,                              "",     ""},
+        {VKD3D_SM4_OP_DEFAULT,                          VKD3DSIH_DEFAULT,                          "",     ""},
+        {VKD3D_SM4_OP_DERIV_RTX,                        VKD3DSIH_DSX,                              "f",    "f"},
+        {VKD3D_SM4_OP_DERIV_RTY,                        VKD3DSIH_DSY,                              "f",    "f"},
+        {VKD3D_SM4_OP_DISCARD,                          VKD3DSIH_DISCARD,                          "",     "u",
+                shader_sm4_read_conditional_op},
+        {VKD3D_SM4_OP_DIV,                              VKD3DSIH_DIV,                              "f",    "ff"},
+        {VKD3D_SM4_OP_DP2,                              VKD3DSIH_DP2,                              "f",    "ff"},
+        {VKD3D_SM4_OP_DP3,                              VKD3DSIH_DP3,                              "f",    "ff"},
+        {VKD3D_SM4_OP_DP4,                              VKD3DSIH_DP4,                              "f",    "ff"},
+        {VKD3D_SM4_OP_ELSE,                             VKD3DSIH_ELSE,                             "",     ""},
+        {VKD3D_SM4_OP_EMIT,                             VKD3DSIH_EMIT,                             "",     ""},
+        {VKD3D_SM4_OP_ENDIF,                            VKD3DSIH_ENDIF,                            "",     ""},
+        {VKD3D_SM4_OP_ENDLOOP,                          VKD3DSIH_ENDLOOP,                          "",     ""},
+        {VKD3D_SM4_OP_ENDSWITCH,                        VKD3DSIH_ENDSWITCH,                        "",     ""},
+        {VKD3D_SM4_OP_EQ,                               VKD3DSIH_EQO,                              "u",    "ff"},
+        {VKD3D_SM4_OP_EXP,                              VKD3DSIH_EXP,                              "f",    "f"},
+        {VKD3D_SM4_OP_FRC,                              VKD3DSIH_FRC,                              "f",    "f"},
+        {VKD3D_SM4_OP_FTOI,                             VKD3DSIH_FTOI,                             "i",    "f"},
+        {VKD3D_SM4_OP_FTOU,                             VKD3DSIH_FTOU,                             "u",    "f"},
+        {VKD3D_SM4_OP_GE,                               VKD3DSIH_GEO,                              "u",    "ff"},
+        {VKD3D_SM4_OP_IADD,                             VKD3DSIH_IADD,                             "i",    "ii"},
+        {VKD3D_SM4_OP_IF,                               VKD3DSIH_IF,                               "",     "u",
+                shader_sm4_read_conditional_op},
+        {VKD3D_SM4_OP_IEQ,                              VKD3DSIH_IEQ,                              "u",    "ii"},
+        {VKD3D_SM4_OP_IGE,                              VKD3DSIH_IGE,                              "u",    "ii"},
+        {VKD3D_SM4_OP_ILT,                              VKD3DSIH_ILT,                              "u",    "ii"},
+        {VKD3D_SM4_OP_IMAD,                             VKD3DSIH_IMAD,                             "i",    "iii"},
+        {VKD3D_SM4_OP_IMAX,                             VKD3DSIH_IMAX,                             "i",    "ii"},
+        {VKD3D_SM4_OP_IMIN,                             VKD3DSIH_IMIN,                             "i",    "ii"},
+        {VKD3D_SM4_OP_IMUL,                             VKD3DSIH_IMUL,                             "ii",   "ii"},
+        {VKD3D_SM4_OP_INE,                              VKD3DSIH_INE,                              "u",    "ii"},
+        {VKD3D_SM4_OP_INEG,                             VKD3DSIH_INEG,                             "i",    "i"},
+        {VKD3D_SM4_OP_ISHL,                             VKD3DSIH_ISHL,                             "i",    "ii"},
+        {VKD3D_SM4_OP_ISHR,                             VKD3DSIH_ISHR,                             "i",    "ii"},
+        {VKD3D_SM4_OP_ITOF,                             VKD3DSIH_ITOF,                             "f",    "i"},
+        {VKD3D_SM4_OP_LABEL,                            VKD3DSIH_LABEL,                            "",     "O"},
+        {VKD3D_SM4_OP_LD,                               VKD3DSIH_LD,                               "u",    "iR"},
+        {VKD3D_SM4_OP_LD2DMS,                           VKD3DSIH_LD2DMS,                           "u",    "iRi"},
+        {VKD3D_SM4_OP_LOG,                              VKD3DSIH_LOG,                              "f",    "f"},
+        {VKD3D_SM4_OP_LOOP,                             VKD3DSIH_LOOP,                             "",     ""},
+        {VKD3D_SM4_OP_LT,                               VKD3DSIH_LTO,                              "u",    "ff"},
+        {VKD3D_SM4_OP_MAD,                              VKD3DSIH_MAD,                              "f",    "fff"},
+        {VKD3D_SM4_OP_MIN,                              VKD3DSIH_MIN,                              "f",    "ff"},
+        {VKD3D_SM4_OP_MAX,                              VKD3DSIH_MAX,                              "f",    "ff"},
+        {VKD3D_SM4_OP_SHADER_DATA,                      VKD3DSIH_DCL_IMMEDIATE_CONSTANT_BUFFER,    "",     "",
+                shader_sm4_read_shader_data},
+        {VKD3D_SM4_OP_MOV,                              VKD3DSIH_MOV,                              "f",    "f"},
+        {VKD3D_SM4_OP_MOVC,                             VKD3DSIH_MOVC,                             "f",    "uff"},
+        {VKD3D_SM4_OP_MUL,                              VKD3DSIH_MUL,                              "f",    "ff"},
+        {VKD3D_SM4_OP_NE,                               VKD3DSIH_NEU,                              "u",    "ff"},
+        {VKD3D_SM4_OP_NOP,                              VKD3DSIH_NOP,                              "",     ""},
+        {VKD3D_SM4_OP_NOT,                              VKD3DSIH_NOT,                              "u",    "u"},
+        {VKD3D_SM4_OP_OR,                               VKD3DSIH_OR,                               "u",    "uu"},
+        {VKD3D_SM4_OP_RESINFO,                          VKD3DSIH_RESINFO,                          "f",    "iR"},
+        {VKD3D_SM4_OP_RET,                              VKD3DSIH_RET,                              "",     ""},
+        {VKD3D_SM4_OP_RETC,                             VKD3DSIH_RETP,                             "",     "u",
+                shader_sm4_read_conditional_op},
+        {VKD3D_SM4_OP_ROUND_NE,                         VKD3DSIH_ROUND_NE,                         "f",    "f"},
+        {VKD3D_SM4_OP_ROUND_NI,                         VKD3DSIH_ROUND_NI,                         "f",    "f"},
+        {VKD3D_SM4_OP_ROUND_PI,                         VKD3DSIH_ROUND_PI,                         "f",    "f"},
+        {VKD3D_SM4_OP_ROUND_Z,                          VKD3DSIH_ROUND_Z,                          "f",    "f"},
+        {VKD3D_SM4_OP_RSQ,                              VKD3DSIH_RSQ,                              "f",    "f"},
+        {VKD3D_SM4_OP_SAMPLE,                           VKD3DSIH_SAMPLE,                           "u",    "fRS"},
+        {VKD3D_SM4_OP_SAMPLE_C,                         VKD3DSIH_SAMPLE_C,                         "f",    "fRSf"},
+        {VKD3D_SM4_OP_SAMPLE_C_LZ,                      VKD3DSIH_SAMPLE_C_LZ,                      "f",    "fRSf"},
+        {VKD3D_SM4_OP_SAMPLE_LOD,                       VKD3DSIH_SAMPLE_LOD,                       "u",    "fRSf"},
+        {VKD3D_SM4_OP_SAMPLE_GRAD,                      VKD3DSIH_SAMPLE_GRAD,                      "u",    "fRSff"},
+        {VKD3D_SM4_OP_SAMPLE_B,                         VKD3DSIH_SAMPLE_B,                         "u",    "fRSf"},
+        {VKD3D_SM4_OP_SQRT,                             VKD3DSIH_SQRT,                             "f",    "f"},
+        {VKD3D_SM4_OP_SWITCH,                           VKD3DSIH_SWITCH,                           "",     "i"},
+        {VKD3D_SM4_OP_SINCOS,                           VKD3DSIH_SINCOS,                           "ff",   "f"},
+        {VKD3D_SM4_OP_UDIV,                             VKD3DSIH_UDIV,                             "uu",   "uu"},
+        {VKD3D_SM4_OP_ULT,                              VKD3DSIH_ULT,                              "u",    "uu"},
+        {VKD3D_SM4_OP_UGE,                              VKD3DSIH_UGE,                              "u",    "uu"},
+        {VKD3D_SM4_OP_UMUL,                             VKD3DSIH_UMUL,                             "uu",   "uu"},
+        {VKD3D_SM4_OP_UMAX,                             VKD3DSIH_UMAX,                             "u",    "uu"},
+        {VKD3D_SM4_OP_UMIN,                             VKD3DSIH_UMIN,                             "u",    "uu"},
+        {VKD3D_SM4_OP_USHR,                             VKD3DSIH_USHR,                             "u",    "uu"},
+        {VKD3D_SM4_OP_UTOF,                             VKD3DSIH_UTOF,                             "f",    "u"},
+        {VKD3D_SM4_OP_XOR,                              VKD3DSIH_XOR,                              "u",    "uu"},
+        {VKD3D_SM4_OP_DCL_RESOURCE,                     VKD3DSIH_DCL,                              "",     "",
+                shader_sm4_read_dcl_resource},
+        {VKD3D_SM4_OP_DCL_CONSTANT_BUFFER,              VKD3DSIH_DCL_CONSTANT_BUFFER,              "",     "",
+                shader_sm4_read_dcl_constant_buffer},
+        {VKD3D_SM4_OP_DCL_SAMPLER,                      VKD3DSIH_DCL_SAMPLER,                      "",     "",
+                shader_sm4_read_dcl_sampler},
+        {VKD3D_SM4_OP_DCL_INDEX_RANGE,                  VKD3DSIH_DCL_INDEX_RANGE,                  "",     "",
+                shader_sm4_read_dcl_index_range},
+        {VKD3D_SM4_OP_DCL_OUTPUT_TOPOLOGY,              VKD3DSIH_DCL_OUTPUT_TOPOLOGY,              "",     "",
+                shader_sm4_read_dcl_output_topology},
+        {VKD3D_SM4_OP_DCL_INPUT_PRIMITIVE,              VKD3DSIH_DCL_INPUT_PRIMITIVE,              "",     "",
+                shader_sm4_read_dcl_input_primitive},
+        {VKD3D_SM4_OP_DCL_VERTICES_OUT,                 VKD3DSIH_DCL_VERTICES_OUT,                 "",     "",
+                shader_sm4_read_declaration_count},
+        {VKD3D_SM4_OP_DCL_INPUT,                        VKD3DSIH_DCL_INPUT,                        "",     "",
+                shader_sm4_read_declaration_dst},
+        {VKD3D_SM4_OP_DCL_INPUT_SGV,                    VKD3DSIH_DCL_INPUT_SGV,                    "",     "",
+                shader_sm4_read_declaration_register_semantic},
+        {VKD3D_SM4_OP_DCL_INPUT_SIV,                    VKD3DSIH_DCL_INPUT_SIV,                    "",     "",
+                shader_sm4_read_declaration_register_semantic},
+        {VKD3D_SM4_OP_DCL_INPUT_PS,                     VKD3DSIH_DCL_INPUT_PS,                     "",     "",
+                shader_sm4_read_dcl_input_ps},
+        {VKD3D_SM4_OP_DCL_INPUT_PS_SGV,                 VKD3DSIH_DCL_INPUT_PS_SGV,                 "",     "",
+                shader_sm4_read_declaration_register_semantic},
+        {VKD3D_SM4_OP_DCL_INPUT_PS_SIV,                 VKD3DSIH_DCL_INPUT_PS_SIV,                 "",     "",
+                shader_sm4_read_dcl_input_ps_siv},
+        {VKD3D_SM4_OP_DCL_OUTPUT,                       VKD3DSIH_DCL_OUTPUT,                       "",     "",
+                shader_sm4_read_declaration_dst},
+        {VKD3D_SM4_OP_DCL_OUTPUT_SIV,                   VKD3DSIH_DCL_OUTPUT_SIV,                   "",     "",
+                shader_sm4_read_declaration_register_semantic},
+        {VKD3D_SM4_OP_DCL_TEMPS,                        VKD3DSIH_DCL_TEMPS,                        "",     "",
+                shader_sm4_read_declaration_count},
+        {VKD3D_SM4_OP_DCL_INDEXABLE_TEMP,               VKD3DSIH_DCL_INDEXABLE_TEMP,               "",     "",
+                shader_sm4_read_dcl_indexable_temp},
+        {VKD3D_SM4_OP_DCL_GLOBAL_FLAGS,                 VKD3DSIH_DCL_GLOBAL_FLAGS,                 "",     "",
+                shader_sm4_read_dcl_global_flags},
+        {VKD3D_SM4_OP_LOD,                              VKD3DSIH_LOD,                              "f",    "fRS"},
+        {VKD3D_SM4_OP_GATHER4,                          VKD3DSIH_GATHER4,                          "u",    "fRS"},
+        {VKD3D_SM4_OP_SAMPLE_POS,                       VKD3DSIH_SAMPLE_POS,                       "f",    "Ru"},
+        {VKD3D_SM4_OP_SAMPLE_INFO,                      VKD3DSIH_SAMPLE_INFO,                      "f",    "R"},
+        {VKD3D_SM5_OP_HS_DECLS,                         VKD3DSIH_HS_DECLS,                         "",     ""},
+        {VKD3D_SM5_OP_HS_CONTROL_POINT_PHASE,           VKD3DSIH_HS_CONTROL_POINT_PHASE,           "",     ""},
+        {VKD3D_SM5_OP_HS_FORK_PHASE,                    VKD3DSIH_HS_FORK_PHASE,                    "",     ""},
+        {VKD3D_SM5_OP_HS_JOIN_PHASE,                    VKD3DSIH_HS_JOIN_PHASE,                    "",     ""},
+        {VKD3D_SM5_OP_EMIT_STREAM,                      VKD3DSIH_EMIT_STREAM,                      "",     "f"},
+        {VKD3D_SM5_OP_CUT_STREAM,                       VKD3DSIH_CUT_STREAM,                       "",     "f"},
+        {VKD3D_SM5_OP_FCALL,                            VKD3DSIH_FCALL,                            "",     "O",
+                shader_sm5_read_fcall},
+        {VKD3D_SM5_OP_BUFINFO,                          VKD3DSIH_BUFINFO,                          "i",    "U"},
+        {VKD3D_SM5_OP_DERIV_RTX_COARSE,                 VKD3DSIH_DSX_COARSE,                       "f",    "f"},
+        {VKD3D_SM5_OP_DERIV_RTX_FINE,                   VKD3DSIH_DSX_FINE,                         "f",    "f"},
+        {VKD3D_SM5_OP_DERIV_RTY_COARSE,                 VKD3DSIH_DSY_COARSE,                       "f",    "f"},
+        {VKD3D_SM5_OP_DERIV_RTY_FINE,                   VKD3DSIH_DSY_FINE,                         "f",    "f"},
+        {VKD3D_SM5_OP_GATHER4_C,                        VKD3DSIH_GATHER4_C,                        "f",    "fRSf"},
+        {VKD3D_SM5_OP_GATHER4_PO,                       VKD3DSIH_GATHER4_PO,                       "f",    "fiRS"},
+        {VKD3D_SM5_OP_GATHER4_PO_C,                     VKD3DSIH_GATHER4_PO_C,                     "f",    "fiRSf"},
+        {VKD3D_SM5_OP_RCP,                              VKD3DSIH_RCP,                              "f",    "f"},
+        {VKD3D_SM5_OP_F32TOF16,                         VKD3DSIH_F32TOF16,                         "u",    "f"},
+        {VKD3D_SM5_OP_F16TOF32,                         VKD3DSIH_F16TOF32,                         "f",    "u"},
+        {VKD3D_SM5_OP_COUNTBITS,                        VKD3DSIH_COUNTBITS,                        "u",    "u"},
+        {VKD3D_SM5_OP_FIRSTBIT_HI,                      VKD3DSIH_FIRSTBIT_HI,                      "u",    "u"},
+        {VKD3D_SM5_OP_FIRSTBIT_LO,                      VKD3DSIH_FIRSTBIT_LO,                      "u",    "u"},
+        {VKD3D_SM5_OP_FIRSTBIT_SHI,                     VKD3DSIH_FIRSTBIT_SHI,                     "u",    "i"},
+        {VKD3D_SM5_OP_UBFE,                             VKD3DSIH_UBFE,                             "u",    "iiu"},
+        {VKD3D_SM5_OP_IBFE,                             VKD3DSIH_IBFE,                             "i",    "iii"},
+        {VKD3D_SM5_OP_BFI,                              VKD3DSIH_BFI,                              "u",    "iiuu"},
+        {VKD3D_SM5_OP_BFREV,                            VKD3DSIH_BFREV,                            "u",    "u"},
+        {VKD3D_SM5_OP_SWAPC,                            VKD3DSIH_SWAPC,                            "ff",   "uff"},
+        {VKD3D_SM5_OP_DCL_STREAM,                       VKD3DSIH_DCL_STREAM,                       "",     "O"},
+        {VKD3D_SM5_OP_DCL_FUNCTION_BODY,                VKD3DSIH_DCL_FUNCTION_BODY,                "",     "",
+                shader_sm5_read_dcl_function_body},
+        {VKD3D_SM5_OP_DCL_FUNCTION_TABLE,               VKD3DSIH_DCL_FUNCTION_TABLE,               "",     "",
+                shader_sm5_read_dcl_function_table},
+        {VKD3D_SM5_OP_DCL_INTERFACE,                    VKD3DSIH_DCL_INTERFACE,                    "",     "",
+                shader_sm5_read_dcl_interface},
+        {VKD3D_SM5_OP_DCL_INPUT_CONTROL_POINT_COUNT,    VKD3DSIH_DCL_INPUT_CONTROL_POINT_COUNT,    "",     "",
+                shader_sm5_read_control_point_count},
+        {VKD3D_SM5_OP_DCL_OUTPUT_CONTROL_POINT_COUNT,   VKD3DSIH_DCL_OUTPUT_CONTROL_POINT_COUNT,   "",     "",
+                shader_sm5_read_control_point_count},
+        {VKD3D_SM5_OP_DCL_TESSELLATOR_DOMAIN,           VKD3DSIH_DCL_TESSELLATOR_DOMAIN,           "",     "",
+                shader_sm5_read_dcl_tessellator_domain},
+        {VKD3D_SM5_OP_DCL_TESSELLATOR_PARTITIONING,     VKD3DSIH_DCL_TESSELLATOR_PARTITIONING,     "",     "",
+                shader_sm5_read_dcl_tessellator_partitioning},
+        {VKD3D_SM5_OP_DCL_TESSELLATOR_OUTPUT_PRIMITIVE, VKD3DSIH_DCL_TESSELLATOR_OUTPUT_PRIMITIVE, "",     "",
+                shader_sm5_read_dcl_tessellator_output_primitive},
+        {VKD3D_SM5_OP_DCL_HS_MAX_TESSFACTOR,            VKD3DSIH_DCL_HS_MAX_TESSFACTOR,            "",     "",
+                shader_sm5_read_dcl_hs_max_tessfactor},
+        {VKD3D_SM5_OP_DCL_HS_FORK_PHASE_INSTANCE_COUNT, VKD3DSIH_DCL_HS_FORK_PHASE_INSTANCE_COUNT, "",     "",
+                shader_sm4_read_declaration_count},
+        {VKD3D_SM5_OP_DCL_HS_JOIN_PHASE_INSTANCE_COUNT, VKD3DSIH_DCL_HS_JOIN_PHASE_INSTANCE_COUNT, "",     "",
+                shader_sm4_read_declaration_count},
+        {VKD3D_SM5_OP_DCL_THREAD_GROUP,                 VKD3DSIH_DCL_THREAD_GROUP,                 "",     "",
+                shader_sm5_read_dcl_thread_group},
+        {VKD3D_SM5_OP_DCL_UAV_TYPED,                    VKD3DSIH_DCL_UAV_TYPED,                    "",     "",
+                shader_sm4_read_dcl_resource},
+        {VKD3D_SM5_OP_DCL_UAV_RAW,                      VKD3DSIH_DCL_UAV_RAW,                      "",     "",
+                shader_sm5_read_dcl_uav_raw},
+        {VKD3D_SM5_OP_DCL_UAV_STRUCTURED,               VKD3DSIH_DCL_UAV_STRUCTURED,               "",     "",
+                shader_sm5_read_dcl_uav_structured},
+        {VKD3D_SM5_OP_DCL_TGSM_RAW,                     VKD3DSIH_DCL_TGSM_RAW,                     "",     "",
+                shader_sm5_read_dcl_tgsm_raw},
+        {VKD3D_SM5_OP_DCL_TGSM_STRUCTURED,              VKD3DSIH_DCL_TGSM_STRUCTURED,              "",     "",
+                shader_sm5_read_dcl_tgsm_structured},
+        {VKD3D_SM5_OP_DCL_RESOURCE_RAW,                 VKD3DSIH_DCL_RESOURCE_RAW,                 "",     "",
+                shader_sm5_read_dcl_resource_raw},
+        {VKD3D_SM5_OP_DCL_RESOURCE_STRUCTURED,          VKD3DSIH_DCL_RESOURCE_STRUCTURED,          "",     "",
+                shader_sm5_read_dcl_resource_structured},
+        {VKD3D_SM5_OP_LD_UAV_TYPED,                     VKD3DSIH_LD_UAV_TYPED,                     "u",    "iU"},
+        {VKD3D_SM5_OP_STORE_UAV_TYPED,                  VKD3DSIH_STORE_UAV_TYPED,                  "U",    "iu"},
+        {VKD3D_SM5_OP_LD_RAW,                           VKD3DSIH_LD_RAW,                           "u",    "iU"},
+        {VKD3D_SM5_OP_STORE_RAW,                        VKD3DSIH_STORE_RAW,                        "U",    "uu"},
+        {VKD3D_SM5_OP_LD_STRUCTURED,                    VKD3DSIH_LD_STRUCTURED,                    "u",    "iiR"},
+        {VKD3D_SM5_OP_STORE_STRUCTURED,                 VKD3DSIH_STORE_STRUCTURED,                 "U",    "iiu"},
+        {VKD3D_SM5_OP_ATOMIC_AND,                       VKD3DSIH_ATOMIC_AND,                       "U",    "iu"},
+        {VKD3D_SM5_OP_ATOMIC_OR,                        VKD3DSIH_ATOMIC_OR,                        "U",    "iu"},
+        {VKD3D_SM5_OP_ATOMIC_XOR,                       VKD3DSIH_ATOMIC_XOR,                       "U",    "iu"},
+        {VKD3D_SM5_OP_ATOMIC_CMP_STORE,                 VKD3DSIH_ATOMIC_CMP_STORE,                 "U",    "iuu"},
+        {VKD3D_SM5_OP_ATOMIC_IADD,                      VKD3DSIH_ATOMIC_IADD,                      "U",    "ii"},
+        {VKD3D_SM5_OP_ATOMIC_IMAX,                      VKD3DSIH_ATOMIC_IMAX,                      "U",    "ii"},
+        {VKD3D_SM5_OP_ATOMIC_IMIN,                      VKD3DSIH_ATOMIC_IMIN,                      "U",    "ii"},
+        {VKD3D_SM5_OP_ATOMIC_UMAX,                      VKD3DSIH_ATOMIC_UMAX,                      "U",    "iu"},
+        {VKD3D_SM5_OP_ATOMIC_UMIN,                      VKD3DSIH_ATOMIC_UMIN,                      "U",    "iu"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_ALLOC,                 VKD3DSIH_IMM_ATOMIC_ALLOC,                 "u",    "U"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_CONSUME,               VKD3DSIH_IMM_ATOMIC_CONSUME,               "u",    "U"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_IADD,                  VKD3DSIH_IMM_ATOMIC_IADD,                  "uU",   "ii"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_AND,                   VKD3DSIH_IMM_ATOMIC_AND,                   "uU",   "iu"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_OR,                    VKD3DSIH_IMM_ATOMIC_OR,                    "uU",   "iu"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_XOR,                   VKD3DSIH_IMM_ATOMIC_XOR,                   "uU",   "iu"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_EXCH,                  VKD3DSIH_IMM_ATOMIC_EXCH,                  "uU",   "iu"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_CMP_EXCH,              VKD3DSIH_IMM_ATOMIC_CMP_EXCH,              "uU",   "iuu"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_IMAX,                  VKD3DSIH_IMM_ATOMIC_IMAX,                  "iU",   "ii"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_IMIN,                  VKD3DSIH_IMM_ATOMIC_IMIN,                  "iU",   "ii"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_UMAX,                  VKD3DSIH_IMM_ATOMIC_UMAX,                  "uU",   "iu"},
+        {VKD3D_SM5_OP_IMM_ATOMIC_UMIN,                  VKD3DSIH_IMM_ATOMIC_UMIN,                  "uU",   "iu"},
+        {VKD3D_SM5_OP_SYNC,                             VKD3DSIH_SYNC,                             "",     "",
+                shader_sm5_read_sync},
+        {VKD3D_SM5_OP_DADD,                             VKD3DSIH_DADD,                             "d",    "dd"},
+        {VKD3D_SM5_OP_DMAX,                             VKD3DSIH_DMAX,                             "d",    "dd"},
+        {VKD3D_SM5_OP_DMIN,                             VKD3DSIH_DMIN,                             "d",    "dd"},
+        {VKD3D_SM5_OP_DMUL,                             VKD3DSIH_DMUL,                             "d",    "dd"},
+        {VKD3D_SM5_OP_DEQ,                              VKD3DSIH_DEQO,                             "u",    "dd"},
+        {VKD3D_SM5_OP_DGE,                              VKD3DSIH_DGEO,                             "u",    "dd"},
+        {VKD3D_SM5_OP_DLT,                              VKD3DSIH_DLT,                              "u",    "dd"},
+        {VKD3D_SM5_OP_DNE,                              VKD3DSIH_DNE,                              "u",    "dd"},
+        {VKD3D_SM5_OP_DMOV,                             VKD3DSIH_DMOV,                             "d",    "d"},
+        {VKD3D_SM5_OP_DMOVC,                            VKD3DSIH_DMOVC,                            "d",    "udd"},
+        {VKD3D_SM5_OP_DTOF,                             VKD3DSIH_DTOF,                             "f",    "d"},
+        {VKD3D_SM5_OP_FTOD,                             VKD3DSIH_FTOD,                             "d",    "f"},
+        {VKD3D_SM5_OP_EVAL_SAMPLE_INDEX,                VKD3DSIH_EVAL_SAMPLE_INDEX,                "f",    "fi"},
+        {VKD3D_SM5_OP_EVAL_CENTROID,                    VKD3DSIH_EVAL_CENTROID,                    "f",    "f"},
+        {VKD3D_SM5_OP_DCL_GS_INSTANCES,                 VKD3DSIH_DCL_GS_INSTANCES,                 "",     "",
+                shader_sm4_read_declaration_count},
+        {VKD3D_SM5_OP_DDIV,                             VKD3DSIH_DDIV,                             "d",    "dd"},
+        {VKD3D_SM5_OP_DFMA,                             VKD3DSIH_DFMA,                             "d",    "ddd"},
+        {VKD3D_SM5_OP_DRCP,                             VKD3DSIH_DRCP,                             "d",    "d"},
+        {VKD3D_SM5_OP_MSAD,                             VKD3DSIH_MSAD,                             "u",    "uuu"},
+        {VKD3D_SM5_OP_DTOI,                             VKD3DSIH_DTOI,                             "i",    "d"},
+        {VKD3D_SM5_OP_DTOU,                             VKD3DSIH_DTOU,                             "u",    "d"},
+        {VKD3D_SM5_OP_ITOD,                             VKD3DSIH_ITOD,                             "d",    "i"},
+        {VKD3D_SM5_OP_UTOD,                             VKD3DSIH_UTOD,                             "d",    "u"},
+        {VKD3D_SM5_OP_GATHER4_S,                        VKD3DSIH_GATHER4_S,                        "uu",   "fRS"},
+        {VKD3D_SM5_OP_GATHER4_C_S,                      VKD3DSIH_GATHER4_C_S,                      "fu",   "fRSf"},
+        {VKD3D_SM5_OP_GATHER4_PO_S,                     VKD3DSIH_GATHER4_PO_S,                     "fu",   "fiRS"},
+        {VKD3D_SM5_OP_GATHER4_PO_C_S,                   VKD3DSIH_GATHER4_PO_C_S,                   "fu",   "fiRSf"},
+        {VKD3D_SM5_OP_LD_S,                             VKD3DSIH_LD_S,                             "uu",   "iR"},
+        {VKD3D_SM5_OP_LD2DMS_S,                         VKD3DSIH_LD2DMS_S,                         "uu",   "iRi"},
+        {VKD3D_SM5_OP_LD_UAV_TYPED_S,                   VKD3DSIH_LD_UAV_TYPED_S,                   "uu",   "iU"},
+        {VKD3D_SM5_OP_LD_RAW_S,                         VKD3DSIH_LD_RAW_S,                         "uu",   "iU"},
+        {VKD3D_SM5_OP_LD_STRUCTURED_S,                  VKD3DSIH_LD_STRUCTURED_S,                  "uu",   "iiR"},
+        {VKD3D_SM5_OP_SAMPLE_LOD_S,                     VKD3DSIH_SAMPLE_LOD_S,                     "uu",   "fRSf"},
+        {VKD3D_SM5_OP_SAMPLE_C_LZ_S,                    VKD3DSIH_SAMPLE_C_LZ_S,                    "fu",   "fRSf"},
+        {VKD3D_SM5_OP_SAMPLE_CL_S,                      VKD3DSIH_SAMPLE_CL_S,                      "uu",   "fRSf"},
+        {VKD3D_SM5_OP_SAMPLE_B_CL_S,                    VKD3DSIH_SAMPLE_B_CL_S,                    "uu",   "fRSff"},
+        {VKD3D_SM5_OP_SAMPLE_GRAD_CL_S,                 VKD3DSIH_SAMPLE_GRAD_CL_S,                 "uu",   "fRSfff"},
+        {VKD3D_SM5_OP_SAMPLE_C_CL_S,                    VKD3DSIH_SAMPLE_C_CL_S,                    "fu",   "fRSff"},
+        {VKD3D_SM5_OP_CHECK_ACCESS_FULLY_MAPPED,        VKD3DSIH_CHECK_ACCESS_FULLY_MAPPED,        "u",    "u"},
+    };
+
     static const struct vkd3d_sm4_register_type_info register_type_table[] =
     {
-        {VKD3D_SM4_RT_TEMP,                    VKD3DSPR_TEMP},
-        {VKD3D_SM4_RT_INPUT,                   VKD3DSPR_INPUT},
-        {VKD3D_SM4_RT_OUTPUT,                  VKD3DSPR_OUTPUT},
-        {VKD3D_SM4_RT_INDEXABLE_TEMP,          VKD3DSPR_IDXTEMP},
-        {VKD3D_SM4_RT_IMMCONST,                VKD3DSPR_IMMCONST},
-        {VKD3D_SM4_RT_IMMCONST64,              VKD3DSPR_IMMCONST64},
-        {VKD3D_SM4_RT_SAMPLER,                 VKD3DSPR_SAMPLER},
-        {VKD3D_SM4_RT_RESOURCE,                VKD3DSPR_RESOURCE},
-        {VKD3D_SM4_RT_CONSTBUFFER,             VKD3DSPR_CONSTBUFFER},
-        {VKD3D_SM4_RT_IMMCONSTBUFFER,          VKD3DSPR_IMMCONSTBUFFER},
-        {VKD3D_SM4_RT_PRIMID,                  VKD3DSPR_PRIMID},
-        {VKD3D_SM4_RT_DEPTHOUT,                VKD3DSPR_DEPTHOUT},
-        {VKD3D_SM4_RT_NULL,                    VKD3DSPR_NULL},
-        {VKD3D_SM4_RT_RASTERIZER,              VKD3DSPR_RASTERIZER},
-        {VKD3D_SM4_RT_OMASK,                   VKD3DSPR_SAMPLEMASK},
-        {VKD3D_SM5_RT_STREAM,                  VKD3DSPR_STREAM},
-        {VKD3D_SM5_RT_FUNCTION_BODY,           VKD3DSPR_FUNCTIONBODY},
-        {VKD3D_SM5_RT_FUNCTION_POINTER,        VKD3DSPR_FUNCTIONPOINTER},
-        {VKD3D_SM5_RT_OUTPUT_CONTROL_POINT_ID, VKD3DSPR_OUTPOINTID},
-        {VKD3D_SM5_RT_FORK_INSTANCE_ID,        VKD3DSPR_FORKINSTID},
-        {VKD3D_SM5_RT_JOIN_INSTANCE_ID,        VKD3DSPR_JOININSTID},
-        {VKD3D_SM5_RT_INPUT_CONTROL_POINT,     VKD3DSPR_INCONTROLPOINT},
-        {VKD3D_SM5_RT_OUTPUT_CONTROL_POINT,    VKD3DSPR_OUTCONTROLPOINT},
-        {VKD3D_SM5_RT_PATCH_CONSTANT_DATA,     VKD3DSPR_PATCHCONST},
-        {VKD3D_SM5_RT_DOMAIN_LOCATION,         VKD3DSPR_TESSCOORD},
-        {VKD3D_SM5_RT_UAV,                     VKD3DSPR_UAV},
-        {VKD3D_SM5_RT_SHARED_MEMORY,           VKD3DSPR_GROUPSHAREDMEM},
-        {VKD3D_SM5_RT_THREAD_ID,               VKD3DSPR_THREADID},
-        {VKD3D_SM5_RT_THREAD_GROUP_ID,         VKD3DSPR_THREADGROUPID},
-        {VKD3D_SM5_RT_LOCAL_THREAD_ID,         VKD3DSPR_LOCALTHREADID},
-        {VKD3D_SM5_RT_COVERAGE,                VKD3DSPR_COVERAGE},
-        {VKD3D_SM5_RT_LOCAL_THREAD_INDEX,      VKD3DSPR_LOCALTHREADINDEX},
-        {VKD3D_SM5_RT_GS_INSTANCE_ID,          VKD3DSPR_GSINSTID},
-        {VKD3D_SM5_RT_DEPTHOUT_GREATER_EQUAL,  VKD3DSPR_DEPTHOUTGE},
-        {VKD3D_SM5_RT_DEPTHOUT_LESS_EQUAL,     VKD3DSPR_DEPTHOUTLE},
-        {VKD3D_SM5_RT_OUTPUT_STENCIL_REF,      VKD3DSPR_OUTSTENCILREF},
+        {VKD3D_SM4_RT_TEMP,                    VKD3DSPR_TEMP,            VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM4_RT_INPUT,                   VKD3DSPR_INPUT,           VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM4_RT_OUTPUT,                  VKD3DSPR_OUTPUT,          VKD3D_SM4_SWIZZLE_INVALID},
+        {VKD3D_SM4_RT_INDEXABLE_TEMP,          VKD3DSPR_IDXTEMP,         VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM4_RT_IMMCONST,                VKD3DSPR_IMMCONST,        VKD3D_SM4_SWIZZLE_NONE},
+        {VKD3D_SM4_RT_IMMCONST64,              VKD3DSPR_IMMCONST64,      VKD3D_SM4_SWIZZLE_NONE},
+        {VKD3D_SM4_RT_SAMPLER,                 VKD3DSPR_SAMPLER,         VKD3D_SM4_SWIZZLE_SCALAR},
+        {VKD3D_SM4_RT_RESOURCE,                VKD3DSPR_RESOURCE,        VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM4_RT_CONSTBUFFER,             VKD3DSPR_CONSTBUFFER,     VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM4_RT_IMMCONSTBUFFER,          VKD3DSPR_IMMCONSTBUFFER,  VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM4_RT_PRIMID,                  VKD3DSPR_PRIMID,          VKD3D_SM4_SWIZZLE_NONE},
+        {VKD3D_SM4_RT_DEPTHOUT,                VKD3DSPR_DEPTHOUT,        VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM4_RT_NULL,                    VKD3DSPR_NULL,            VKD3D_SM4_SWIZZLE_INVALID},
+        {VKD3D_SM4_RT_RASTERIZER,              VKD3DSPR_RASTERIZER,      VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM4_RT_OMASK,                   VKD3DSPR_SAMPLEMASK,      VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_STREAM,                  VKD3DSPR_STREAM,          VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_FUNCTION_BODY,           VKD3DSPR_FUNCTIONBODY,    VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_FUNCTION_POINTER,        VKD3DSPR_FUNCTIONPOINTER, VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_OUTPUT_CONTROL_POINT_ID, VKD3DSPR_OUTPOINTID,      VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_FORK_INSTANCE_ID,        VKD3DSPR_FORKINSTID,      VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_JOIN_INSTANCE_ID,        VKD3DSPR_JOININSTID,      VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_INPUT_CONTROL_POINT,     VKD3DSPR_INCONTROLPOINT,  VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_OUTPUT_CONTROL_POINT,    VKD3DSPR_OUTCONTROLPOINT, VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_PATCH_CONSTANT_DATA,     VKD3DSPR_PATCHCONST,      VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_DOMAIN_LOCATION,         VKD3DSPR_TESSCOORD,       VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_UAV,                     VKD3DSPR_UAV,             VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_SHARED_MEMORY,           VKD3DSPR_GROUPSHAREDMEM,  VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_THREAD_ID,               VKD3DSPR_THREADID,        VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_THREAD_GROUP_ID,         VKD3DSPR_THREADGROUPID,   VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_LOCAL_THREAD_ID,         VKD3DSPR_LOCALTHREADID,   VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_COVERAGE,                VKD3DSPR_COVERAGE,        VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_LOCAL_THREAD_INDEX,      VKD3DSPR_LOCALTHREADINDEX,VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_GS_INSTANCE_ID,          VKD3DSPR_GSINSTID,        VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_DEPTHOUT_GREATER_EQUAL,  VKD3DSPR_DEPTHOUTGE,      VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_DEPTHOUT_LESS_EQUAL,     VKD3DSPR_DEPTHOUTLE,      VKD3D_SM4_SWIZZLE_VEC4},
+        {VKD3D_SM5_RT_OUTPUT_STENCIL_REF,      VKD3DSPR_OUTSTENCILREF,   VKD3D_SM4_SWIZZLE_VEC4},
     };
 
     memset(lookup, 0, sizeof(*lookup));
 
+    for (i = 0; i < ARRAY_SIZE(opcode_table); ++i)
+    {
+        const struct vkd3d_sm4_opcode_info *info = &opcode_table[i];
+
+        lookup->opcode_info_from_sm4[info->opcode] = info;
+    }
+
     for (i = 0; i < ARRAY_SIZE(register_type_table); ++i)
     {
-        info = &register_type_table[i];
+        const struct vkd3d_sm4_register_type_info *info = &register_type_table[i];
+
         lookup->register_type_info_from_sm4[info->sm4_type] = info;
         lookup->register_type_info_from_vkd3d[info->vkd3d_type] = info;
     }
@@ -1590,6 +1656,14 @@ static void tpf_writer_init(struct tpf_writer *tpf, struct hlsl_ctx *ctx, struct
     init_sm4_lookup_tables(&tpf->lookup);
 }
 
+static const struct vkd3d_sm4_opcode_info *get_info_from_sm4_opcode(
+        const struct vkd3d_sm4_lookup_tables *lookup, enum vkd3d_sm4_opcode sm4_opcode)
+{
+    if (sm4_opcode >= VKD3D_SM4_OP_COUNT)
+        return NULL;
+    return lookup->opcode_info_from_sm4[sm4_opcode];
+}
+
 static const struct vkd3d_sm4_register_type_info *get_info_from_sm4_register_type(
         const struct vkd3d_sm4_lookup_tables *lookup, enum vkd3d_sm4_register_type sm4_type)
 {
@@ -1606,29 +1680,14 @@ static const struct vkd3d_sm4_register_type_info *get_info_from_vkd3d_register_t
     return lookup->register_type_info_from_vkd3d[vkd3d_type];
 }
 
-static void map_register(const struct vkd3d_shader_sm4_parser *sm4, struct vkd3d_shader_register *reg)
+static enum vkd3d_sm4_swizzle_type vkd3d_sm4_get_default_swizzle_type(
+        const struct vkd3d_sm4_lookup_tables *lookup, enum vkd3d_shader_register_type vkd3d_type)
 {
-    switch (sm4->p.shader_version.type)
-    {
-        case VKD3D_SHADER_TYPE_PIXEL:
-            if (reg->type == VKD3DSPR_OUTPUT)
-            {
-                unsigned int reg_idx = reg->idx[0].offset;
+    const struct vkd3d_sm4_register_type_info *register_type_info =
+            get_info_from_vkd3d_register_type(lookup, vkd3d_type);
 
-                if (reg_idx >= ARRAY_SIZE(sm4->output_map))
-                {
-                    /* Validated later */
-                    break;
-                }
-
-                reg->type = VKD3DSPR_COLOROUT;
-                reg->idx[0].offset = sm4->output_map[reg_idx];
-            }
-            break;
-
-        default:
-            break;
-    }
+    assert(register_type_info);
+    return register_type_info->default_src_swizzle_type;
 }
 
 static enum vkd3d_data_type map_data_type(char t)
@@ -1694,29 +1753,16 @@ static bool shader_sm4_read_reg_idx(struct vkd3d_shader_sm4_parser *priv, const
     return true;
 }
 
-static bool sm4_register_is_descriptor(enum vkd3d_sm4_register_type register_type)
-{
-    switch (register_type)
-    {
-        case VKD3D_SM4_RT_SAMPLER:
-        case VKD3D_SM4_RT_RESOURCE:
-        case VKD3D_SM4_RT_CONSTBUFFER:
-        case VKD3D_SM5_RT_UAV:
-            return true;
-
-        default:
-            return false;
-    }
-}
-
 static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const uint32_t **ptr, const uint32_t *end,
         enum vkd3d_data_type data_type, struct vkd3d_shader_register *param, enum vkd3d_shader_src_modifier *modifier)
 {
     const struct vkd3d_sm4_register_type_info *register_type_info;
+    enum vkd3d_shader_register_type vsir_register_type;
     enum vkd3d_sm4_register_precision precision;
     enum vkd3d_sm4_register_type register_type;
     enum vkd3d_sm4_extended_operand_type type;
     enum vkd3d_sm4_register_modifier m;
+    enum vkd3d_sm4_dimension sm4_dimension;
     uint32_t token, order, extended;
 
     if (*ptr >= end)
@@ -1731,15 +1777,18 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
     if (!register_type_info)
     {
         FIXME("Unhandled register type %#x.\n", register_type);
-        param->type = VKD3DSPR_TEMP;
+        vsir_register_type = VKD3DSPR_TEMP;
     }
     else
     {
-        param->type = register_type_info->vkd3d_type;
+        vsir_register_type = register_type_info->vkd3d_type;
     }
+
+    order = (token & VKD3D_SM4_REGISTER_ORDER_MASK) >> VKD3D_SM4_REGISTER_ORDER_SHIFT;
+
+    vsir_register_init(param, vsir_register_type, data_type, order);
     param->precision = VKD3D_SHADER_REGISTER_PRECISION_DEFAULT;
     param->non_uniform = false;
-    param->data_type = data_type;
 
     *modifier = VKD3DSPSM_NONE;
     if (token & VKD3D_SM4_EXTENDED_OPERAND)
@@ -1775,10 +1824,11 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
                     *modifier = VKD3DSPSM_ABSNEG;
                     break;
 
+                case VKD3D_SM4_REGISTER_MODIFIER_NONE:
+                    break;
+
                 default:
                     FIXME("Unhandled register modifier %#x.\n", m);
-                    /* fall-through */
-                case VKD3D_SM4_REGISTER_MODIFIER_NONE:
                     break;
             }
 
@@ -1809,14 +1859,7 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
         }
     }
 
-    order = (token & VKD3D_SM4_REGISTER_ORDER_MASK) >> VKD3D_SM4_REGISTER_ORDER_SHIFT;
-
-    if (order < 1)
-    {
-        param->idx[0].offset = ~0u;
-        param->idx[0].rel_addr = NULL;
-    }
-    else
+    if (order >= 1)
     {
         DWORD addressing = (token & VKD3D_SM4_ADDRESSING_MASK0) >> VKD3D_SM4_ADDRESSING_SHIFT0;
         if (!(shader_sm4_read_reg_idx(priv, ptr, end, addressing, &param->idx[0])))
@@ -1826,12 +1869,7 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
         }
     }
 
-    if (order < 2)
-    {
-        param->idx[1].offset = ~0u;
-        param->idx[1].rel_addr = NULL;
-    }
-    else
+    if (order >= 2)
     {
         DWORD addressing = (token & VKD3D_SM4_ADDRESSING_MASK1) >> VKD3D_SM4_ADDRESSING_SHIFT1;
         if (!(shader_sm4_read_reg_idx(priv, ptr, end, addressing, &param->idx[1])))
@@ -1841,12 +1879,7 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
         }
     }
 
-    if (order < 3)
-    {
-        param->idx[2].offset = ~0u;
-        param->idx[2].rel_addr = NULL;
-    }
-    else
+    if (order >= 3)
     {
         DWORD addressing = (token & VKD3D_SM4_ADDRESSING_MASK2) >> VKD3D_SM4_ADDRESSING_SHIFT2;
         if (!(shader_sm4_read_reg_idx(priv, ptr, end, addressing, &param->idx[2])))
@@ -1862,17 +1895,16 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
         return false;
     }
 
-    param->idx_count = order;
+    sm4_dimension = (token & VKD3D_SM4_DIMENSION_MASK) >> VKD3D_SM4_DIMENSION_SHIFT;
+    param->dimension = vsir_dimension_from_sm4_dimension(sm4_dimension);
 
     if (register_type == VKD3D_SM4_RT_IMMCONST || register_type == VKD3D_SM4_RT_IMMCONST64)
     {
-        enum vkd3d_sm4_dimension dimension = (token & VKD3D_SM4_DIMENSION_MASK) >> VKD3D_SM4_DIMENSION_SHIFT;
         unsigned int dword_count;
 
-        switch (dimension)
+        switch (param->dimension)
         {
-            case VKD3D_SM4_DIMENSION_SCALAR:
-                param->immconst_type = VKD3D_IMMCONST_SCALAR;
+            case VSIR_DIMENSION_SCALAR:
                 dword_count = 1 + (register_type == VKD3D_SM4_RT_IMMCONST64);
                 if (end - *ptr < dword_count)
                 {
@@ -1883,8 +1915,7 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
                 *ptr += dword_count;
                 break;
 
-            case VKD3D_SM4_DIMENSION_VEC4:
-                param->immconst_type = VKD3D_IMMCONST_VEC4;
+            case VSIR_DIMENSION_VEC4:
                 if (end - *ptr < VKD3D_VEC4_SIZE)
                 {
                     WARN("Invalid ptr %p, end %p.\n", *ptr, end);
@@ -1895,11 +1926,11 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
                 break;
 
             default:
-                FIXME("Unhandled dimension %#x.\n", dimension);
+                FIXME("Unhandled dimension %#x.\n", param->dimension);
                 break;
         }
     }
-    else if (!shader_is_sm_5_1(priv) && sm4_register_is_descriptor(register_type))
+    else if (!shader_is_sm_5_1(priv) && vsir_register_is_descriptor(param))
     {
         /* SM5.1 places a symbol identifier in idx[0] and moves
          * other values up one slot. Normalize to SM5.1. */
@@ -1908,8 +1939,6 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
         ++param->idx_count;
     }
 
-    map_register(priv, param);
-
     return true;
 }
 
@@ -1938,6 +1967,16 @@ static uint32_t swizzle_from_sm4(uint32_t s)
     return vkd3d_shader_create_swizzle(s & 0x3, (s >> 2) & 0x3, (s >> 4) & 0x3, (s >> 6) & 0x3);
 }
 
+static uint32_t swizzle_to_sm4(uint32_t s)
+{
+    uint32_t ret = 0;
+    ret |= ((vkd3d_swizzle_get_component(s, 0)) & 0x3);
+    ret |= ((vkd3d_swizzle_get_component(s, 1)) & 0x3) << 2;
+    ret |= ((vkd3d_swizzle_get_component(s, 2)) & 0x3) << 4;
+    ret |= ((vkd3d_swizzle_get_component(s, 3)) & 0x3) << 6;
+    return ret;
+}
+
 static bool register_is_input_output(const struct vkd3d_shader_register *reg)
 {
     switch (reg->type)
@@ -2319,7 +2358,7 @@ static void shader_sm4_read_instruction(struct vkd3d_shader_sm4_parser *sm4, str
     }
     --len;
 
-    if (!(opcode_info = get_opcode_info(opcode)))
+    if (!(opcode_info = get_info_from_sm4_opcode(&sm4->lookup, opcode)))
     {
         FIXME("Unrecognized opcode %#x, opcode_token 0x%08x.\n", opcode, opcode_token);
         ins->handler_idx = VKD3DSIH_INVALID;
@@ -2327,7 +2366,7 @@ static void shader_sm4_read_instruction(struct vkd3d_shader_sm4_parser *sm4, str
         return;
     }
 
-    ins->handler_idx = opcode_info->handler_idx;
+    vsir_instruction_init(ins, &sm4->p.location, opcode_info->handler_idx);
     if (ins->handler_idx == VKD3DSIH_HS_CONTROL_POINT_PHASE || ins->handler_idx == VKD3DSIH_HS_FORK_PHASE
             || ins->handler_idx == VKD3DSIH_HS_JOIN_PHASE)
         sm4->phase = ins->handler_idx;
@@ -2430,7 +2469,6 @@ static bool shader_sm4_init(struct vkd3d_shader_sm4_parser *sm4, const uint32_t
 {
     struct vkd3d_shader_version version;
     uint32_t version_token, token_count;
-    unsigned int i;
 
     if (byte_code_size / sizeof(*byte_code) < 2)
     {
@@ -2490,23 +2528,6 @@ static bool shader_sm4_init(struct vkd3d_shader_sm4_parser *sm4, const uint32_t
         return false;
     sm4->ptr = sm4->start;
 
-    memset(sm4->output_map, 0xff, sizeof(sm4->output_map));
-    for (i = 0; i < output_signature->element_count; ++i)
-    {
-        struct signature_element *e = &output_signature->elements[i];
-
-        if (version.type == VKD3D_SHADER_TYPE_PIXEL
-                && ascii_strcasecmp(e->semantic_name, "SV_Target"))
-            continue;
-        if (e->register_index >= ARRAY_SIZE(sm4->output_map))
-        {
-            WARN("Invalid output index %u.\n", e->register_index);
-            continue;
-        }
-
-        sm4->output_map[e->register_index] = e->semantic_index;
-    }
-
     init_sm4_lookup_tables(&sm4->lookup);
 
     return true;
@@ -2642,9 +2663,19 @@ int vkd3d_shader_sm4_parser_create(const struct vkd3d_shader_compile_info *compi
     if (sm4->p.shader_version.type == VKD3D_SHADER_TYPE_HULL && !sm4->has_control_point_phase && !sm4->p.failed)
         shader_sm4_validate_default_phase_index_ranges(sm4);
 
+    if (!sm4->p.failed)
+        vsir_validate(&sm4->p);
+
+    if (sm4->p.failed)
+    {
+        WARN("Failed to parse shader.\n");
+        shader_sm4_destroy(&sm4->p);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
     *parser = &sm4->p;
 
-    return sm4->p.failed ? VKD3D_ERROR_INVALID_SHADER : VKD3D_OK;
+    return VKD3D_OK;
 }
 
 static void write_sm4_block(const struct tpf_writer *tpf, const struct hlsl_block *block);
@@ -2664,7 +2695,7 @@ static bool type_is_integer(const struct hlsl_type *type)
 }
 
 bool hlsl_sm4_register_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_semantic *semantic,
-        bool output, enum vkd3d_shader_register_type *type, enum vkd3d_sm4_swizzle_type *swizzle_type, bool *has_idx)
+        bool output, enum vkd3d_shader_register_type *type, bool *has_idx)
 {
     unsigned int i;
 
@@ -2673,25 +2704,24 @@ bool hlsl_sm4_register_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_sem
         const char *semantic;
         bool output;
         enum vkd3d_shader_type shader_type;
-        enum vkd3d_sm4_swizzle_type swizzle_type;
         enum vkd3d_shader_register_type type;
         bool has_idx;
     }
     register_table[] =
     {
-        {"sv_dispatchthreadid", false, VKD3D_SHADER_TYPE_COMPUTE,   VKD3D_SM4_SWIZZLE_VEC4, VKD3DSPR_THREADID,          false},
-        {"sv_groupid",          false, VKD3D_SHADER_TYPE_COMPUTE,   VKD3D_SM4_SWIZZLE_VEC4, VKD3DSPR_THREADGROUPID,     false},
-        {"sv_groupthreadid",    false, VKD3D_SHADER_TYPE_COMPUTE,   VKD3D_SM4_SWIZZLE_VEC4, VKD3DSPR_LOCALTHREADID,     false},
+        {"sv_dispatchthreadid", false, VKD3D_SHADER_TYPE_COMPUTE,  VKD3DSPR_THREADID,      false},
+        {"sv_groupid",          false, VKD3D_SHADER_TYPE_COMPUTE,  VKD3DSPR_THREADGROUPID, false},
+        {"sv_groupthreadid",    false, VKD3D_SHADER_TYPE_COMPUTE,  VKD3DSPR_LOCALTHREADID, false},
 
-        {"sv_primitiveid",      false, VKD3D_SHADER_TYPE_GEOMETRY,  VKD3D_SM4_SWIZZLE_NONE, VKD3DSPR_PRIMID,            false},
+        {"sv_primitiveid",      false, VKD3D_SHADER_TYPE_GEOMETRY, VKD3DSPR_PRIMID,        false},
 
         /* Put sv_target in this table, instead of letting it fall through to
          * default varying allocation, so that the register index matches the
          * usage index. */
-        {"color",               true,  VKD3D_SHADER_TYPE_PIXEL,     VKD3D_SM4_SWIZZLE_VEC4, VKD3DSPR_OUTPUT,            true},
-        {"depth",               true,  VKD3D_SHADER_TYPE_PIXEL,     VKD3D_SM4_SWIZZLE_VEC4, VKD3DSPR_DEPTHOUT,          false},
-        {"sv_depth",            true,  VKD3D_SHADER_TYPE_PIXEL,     VKD3D_SM4_SWIZZLE_VEC4, VKD3DSPR_DEPTHOUT,          false},
-        {"sv_target",           true,  VKD3D_SHADER_TYPE_PIXEL,     VKD3D_SM4_SWIZZLE_VEC4, VKD3DSPR_OUTPUT,            true},
+        {"color",               true,  VKD3D_SHADER_TYPE_PIXEL,    VKD3DSPR_OUTPUT,        true},
+        {"depth",               true,  VKD3D_SHADER_TYPE_PIXEL,    VKD3DSPR_DEPTHOUT,      false},
+        {"sv_depth",            true,  VKD3D_SHADER_TYPE_PIXEL,    VKD3DSPR_DEPTHOUT,      false},
+        {"sv_target",           true,  VKD3D_SHADER_TYPE_PIXEL,    VKD3DSPR_OUTPUT,        true},
     };
 
     for (i = 0; i < ARRAY_SIZE(register_table); ++i)
@@ -2702,8 +2732,6 @@ bool hlsl_sm4_register_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_sem
         {
             if (type)
                 *type = register_table[i].type;
-            if (swizzle_type)
-                *swizzle_type = register_table[i].swizzle_type;
             *has_idx = register_table[i].has_idx;
             return true;
         }
@@ -2722,7 +2750,7 @@ bool hlsl_sm4_usage_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_semant
         const char *name;
         bool output;
         enum vkd3d_shader_type shader_type;
-        D3DDECLUSAGE usage;
+        D3D_NAME usage;
     }
     semantics[] =
     {
@@ -2753,20 +2781,21 @@ bool hlsl_sm4_usage_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_semant
         {"position",                    true,  VKD3D_SHADER_TYPE_VERTEX,    D3D_NAME_POSITION},
         {"sv_position",                 true,  VKD3D_SHADER_TYPE_VERTEX,    D3D_NAME_POSITION},
     };
+    bool needs_compat_mapping = ascii_strncasecmp(semantic->name, "sv_", 3);
 
     for (i = 0; i < ARRAY_SIZE(semantics); ++i)
     {
         if (!ascii_strcasecmp(semantic->name, semantics[i].name)
                 && output == semantics[i].output
-                && ctx->profile->type == semantics[i].shader_type
-                && !ascii_strncasecmp(semantic->name, "sv_", 3))
+                && (ctx->semantic_compat_mapping == needs_compat_mapping || !needs_compat_mapping)
+                && ctx->profile->type == semantics[i].shader_type)
         {
             *usage = semantics[i].usage;
             return true;
         }
     }
 
-    if (!ascii_strncasecmp(semantic->name, "sv_", 3))
+    if (!needs_compat_mapping)
         return false;
 
     *usage = D3D_NAME_UNDEFINED;
@@ -2815,7 +2844,7 @@ static void write_sm4_signature(struct hlsl_ctx *ctx, struct dxbc_writer *dxbc,
             continue;
         usage_idx = var->semantic.index;
 
-        if (hlsl_sm4_register_from_semantic(ctx, &var->semantic, output, NULL, NULL, &has_idx))
+        if (hlsl_sm4_register_from_semantic(ctx, &var->semantic, output, NULL, &has_idx))
         {
             reg_idx = has_idx ? var->semantic.index : ~0u;
         }
@@ -3202,8 +3231,7 @@ static struct extern_resource *sm4_get_extern_resources(struct hlsl_ctx *ctx, un
                 if (!hlsl_type_is_resource(component_type))
                     continue;
 
-                regset = hlsl_type_get_regset(component_type);
-                regset_offset = hlsl_type_get_component_offset(ctx, var->data_type, regset, k);
+                regset_offset = hlsl_type_get_component_offset(ctx, var->data_type, k, &regset);
 
                 if (regset_offset > var->regs[regset].allocation_size)
                     continue;
@@ -3249,38 +3277,43 @@ static struct extern_resource *sm4_get_extern_resources(struct hlsl_ctx *ctx, un
         }
         else
         {
+            unsigned int r;
+
             if (!hlsl_type_is_resource(var->data_type))
                 continue;
-            regset = hlsl_type_get_regset(var->data_type);
-            if (!var->regs[regset].allocated)
-                continue;
 
-            if (!(hlsl_array_reserve(ctx, (void **)&extern_resources, &capacity, *count + 1,
-                    sizeof(*extern_resources))))
+            for (r = 0; r <= HLSL_REGSET_LAST; ++r)
             {
-                sm4_free_extern_resources(extern_resources, *count);
-                *count = 0;
-                return NULL;
-            }
+                if (!var->regs[r].allocated)
+                    continue;
 
-            if (!(name = hlsl_strdup(ctx, string_skip_tag(var->name))))
-            {
-                sm4_free_extern_resources(extern_resources, *count);
-                *count = 0;
-                return NULL;
-            }
+                if (!(hlsl_array_reserve(ctx, (void **)&extern_resources, &capacity, *count + 1,
+                        sizeof(*extern_resources))))
+                {
+                    sm4_free_extern_resources(extern_resources, *count);
+                    *count = 0;
+                    return NULL;
+                }
+
+                if (!(name = hlsl_strdup(ctx, string_skip_tag(var->name))))
+                {
+                    sm4_free_extern_resources(extern_resources, *count);
+                    *count = 0;
+                    return NULL;
+                }
 
-            extern_resources[*count].var = var;
+                extern_resources[*count].var = var;
 
-            extern_resources[*count].name = name;
-            extern_resources[*count].data_type = var->data_type;
-            extern_resources[*count].is_user_packed = !!var->reg_reservation.reg_type;
+                extern_resources[*count].name = name;
+                extern_resources[*count].data_type = var->data_type;
+                extern_resources[*count].is_user_packed = !!var->reg_reservation.reg_type;
 
-            extern_resources[*count].regset = regset;
-            extern_resources[*count].id = var->regs[regset].id;
-            extern_resources[*count].bind_count = var->bind_count[regset];
+                extern_resources[*count].regset = r;
+                extern_resources[*count].id = var->regs[r].id;
+                extern_resources[*count].bind_count = var->bind_count[r];
 
-            ++*count;
+                ++*count;
+            }
         }
     }
 
@@ -3427,7 +3460,8 @@ static void write_sm4_rdef(struct hlsl_ctx *ctx, struct dxbc_writer *dxbc)
 
         LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
         {
-            if (var->is_uniform && var->buffer == cbuffer)
+            if (var->is_uniform && var->buffer == cbuffer
+                    && var->data_type->class != HLSL_CLASS_OBJECT)
                 ++var_count;
         }
 
@@ -3461,7 +3495,8 @@ static void write_sm4_rdef(struct hlsl_ctx *ctx, struct dxbc_writer *dxbc)
 
         LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
         {
-            if (var->is_uniform && var->buffer == cbuffer)
+            if (var->is_uniform && var->buffer == cbuffer
+                    && var->data_type->class != HLSL_CLASS_OBJECT)
             {
                 uint32_t flags = 0;
 
@@ -3488,7 +3523,8 @@ static void write_sm4_rdef(struct hlsl_ctx *ctx, struct dxbc_writer *dxbc)
         j = 0;
         LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
         {
-            if (var->is_uniform && var->buffer == cbuffer)
+            if (var->is_uniform && var->buffer == cbuffer
+                    && var->data_type->class != HLSL_CLASS_OBJECT)
             {
                 const unsigned int var_size = (profile->major_version >= 5 ? 10 : 6);
                 size_t var_offset = vars_start + j * var_size * sizeof(uint32_t);
@@ -3577,61 +3613,100 @@ static uint32_t sm4_encode_instruction_modifier(const struct sm4_instruction_mod
     return word;
 }
 
-struct sm4_register
-{
-    enum vkd3d_shader_register_type type;
-    struct vkd3d_shader_register_index idx[2];
-    unsigned int idx_count;
-    enum vkd3d_sm4_dimension dim;
-    uint32_t immconst_uint[4];
-    unsigned int mod;
-};
-
 struct sm4_instruction
 {
     enum vkd3d_sm4_opcode opcode;
+    uint32_t extra_bits;
 
     struct sm4_instruction_modifier modifiers[1];
     unsigned int modifier_count;
 
-    struct sm4_dst_register
-    {
-        struct sm4_register reg;
-        unsigned int writemask;
-    } dsts[2];
+    struct vkd3d_shader_dst_param dsts[2];
     unsigned int dst_count;
 
-    struct sm4_src_register
-    {
-        struct sm4_register reg;
-        enum vkd3d_sm4_swizzle_type swizzle_type;
-        unsigned int swizzle;
-    } srcs[5];
+    struct vkd3d_shader_src_param srcs[5];
     unsigned int src_count;
 
     unsigned int byte_stride;
 
     uint32_t idx[3];
     unsigned int idx_count;
+
+    struct vkd3d_shader_src_param idx_srcs[7];
+    unsigned int idx_src_count;
 };
 
-static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *reg,
-        unsigned int *writemask, enum vkd3d_sm4_swizzle_type *swizzle_type,
-        const struct hlsl_deref *deref)
+static void sm4_register_from_node(struct vkd3d_shader_register *reg, uint32_t *writemask,
+        const struct hlsl_ir_node *instr)
+{
+    assert(instr->reg.allocated);
+    reg->type = VKD3DSPR_TEMP;
+    reg->dimension = VSIR_DIMENSION_VEC4;
+    reg->idx[0].offset = instr->reg.id;
+    reg->idx_count = 1;
+    *writemask = instr->reg.writemask;
+}
+
+static void sm4_numeric_register_from_deref(struct hlsl_ctx *ctx, struct vkd3d_shader_register *reg,
+        enum vkd3d_shader_register_type type, uint32_t *writemask, const struct hlsl_deref *deref,
+        struct sm4_instruction *sm4_instr)
+{
+    const struct hlsl_ir_var *var = deref->var;
+    unsigned int offset_const_deref;
+
+    reg->type = type;
+    reg->idx[0].offset = var->regs[HLSL_REGSET_NUMERIC].id;
+    reg->dimension = VSIR_DIMENSION_VEC4;
+
+    assert(var->regs[HLSL_REGSET_NUMERIC].allocated);
+
+    if (!var->indexable)
+    {
+        offset_const_deref = hlsl_offset_from_deref_safe(ctx, deref);
+        reg->idx[0].offset += offset_const_deref / 4;
+        reg->idx_count = 1;
+    }
+    else
+    {
+        offset_const_deref = deref->const_offset;
+        reg->idx[1].offset = offset_const_deref / 4;
+        reg->idx_count = 2;
+
+        if (deref->rel_offset.node)
+        {
+            struct vkd3d_shader_src_param *idx_src;
+            unsigned int idx_writemask;
+
+            assert(sm4_instr->idx_src_count < ARRAY_SIZE(sm4_instr->idx_srcs));
+            idx_src = &sm4_instr->idx_srcs[sm4_instr->idx_src_count++];
+            memset(idx_src, 0, sizeof(*idx_src));
+
+            reg->idx[1].rel_addr = idx_src;
+            sm4_register_from_node(&idx_src->reg, &idx_writemask, deref->rel_offset.node);
+            assert(idx_writemask != 0);
+            idx_src->swizzle = swizzle_from_sm4(hlsl_swizzle_from_writemask(idx_writemask));
+        }
+    }
+
+    *writemask = 0xf & (0xf << (offset_const_deref % 4));
+    if (var->regs[HLSL_REGSET_NUMERIC].writemask)
+        *writemask = hlsl_combine_writemasks(var->regs[HLSL_REGSET_NUMERIC].writemask, *writemask);
+}
+
+static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct vkd3d_shader_register *reg,
+        uint32_t *writemask, const struct hlsl_deref *deref, struct sm4_instruction *sm4_instr)
 {
     const struct hlsl_type *data_type = hlsl_deref_get_type(ctx, deref);
     const struct hlsl_ir_var *var = deref->var;
 
     if (var->is_uniform)
     {
-        enum hlsl_regset regset = hlsl_type_get_regset(data_type);
+        enum hlsl_regset regset = hlsl_deref_get_regset(ctx, deref);
 
         if (regset == HLSL_REGSET_TEXTURES)
         {
             reg->type = VKD3DSPR_RESOURCE;
-            reg->dim = VKD3D_SM4_DIMENSION_VEC4;
-            if (swizzle_type)
-                *swizzle_type = VKD3D_SM4_SWIZZLE_VEC4;
+            reg->dimension = VSIR_DIMENSION_VEC4;
             reg->idx[0].offset = var->regs[HLSL_REGSET_TEXTURES].id;
             reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
             assert(regset == HLSL_REGSET_TEXTURES);
@@ -3641,9 +3716,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *r
         else if (regset == HLSL_REGSET_UAVS)
         {
             reg->type = VKD3DSPR_UAV;
-            reg->dim = VKD3D_SM4_DIMENSION_VEC4;
-            if (swizzle_type)
-                *swizzle_type = VKD3D_SM4_SWIZZLE_VEC4;
+            reg->dimension = VSIR_DIMENSION_VEC4;
             reg->idx[0].offset = var->regs[HLSL_REGSET_UAVS].id;
             reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
             assert(regset == HLSL_REGSET_UAVS);
@@ -3653,9 +3726,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *r
         else if (regset == HLSL_REGSET_SAMPLERS)
         {
             reg->type = VKD3DSPR_SAMPLER;
-            reg->dim = VKD3D_SM4_DIMENSION_NONE;
-            if (swizzle_type)
-                *swizzle_type = VKD3D_SM4_SWIZZLE_NONE;
+            reg->dimension = VSIR_DIMENSION_NONE;
             reg->idx[0].offset = var->regs[HLSL_REGSET_SAMPLERS].id;
             reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
             assert(regset == HLSL_REGSET_SAMPLERS);
@@ -3668,9 +3739,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *r
 
             assert(data_type->class <= HLSL_CLASS_VECTOR);
             reg->type = VKD3DSPR_CONSTBUFFER;
-            reg->dim = VKD3D_SM4_DIMENSION_VEC4;
-            if (swizzle_type)
-                *swizzle_type = VKD3D_SM4_SWIZZLE_VEC4;
+            reg->dimension = VSIR_DIMENSION_VEC4;
             reg->idx[0].offset = var->buffer->reg.id;
             reg->idx[1].offset = offset / 4;
             reg->idx_count = 2;
@@ -3681,7 +3750,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *r
     {
         bool has_idx;
 
-        if (hlsl_sm4_register_from_semantic(ctx, &var->semantic, false, &reg->type, swizzle_type, &has_idx))
+        if (hlsl_sm4_register_from_semantic(ctx, &var->semantic, false, &reg->type, &has_idx))
         {
             unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref);
 
@@ -3691,7 +3760,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *r
                 reg->idx_count = 1;
             }
 
-            reg->dim = VKD3D_SM4_DIMENSION_VEC4;
+            reg->dimension = VSIR_DIMENSION_VEC4;
             *writemask = ((1u << data_type->dimx) - 1) << (offset % 4);
         }
         else
@@ -3700,9 +3769,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *r
 
             assert(hlsl_reg.allocated);
             reg->type = VKD3DSPR_INPUT;
-            reg->dim = VKD3D_SM4_DIMENSION_VEC4;
-            if (swizzle_type)
-                *swizzle_type = VKD3D_SM4_SWIZZLE_VEC4;
+            reg->dimension = VSIR_DIMENSION_VEC4;
             reg->idx[0].offset = hlsl_reg.id;
             reg->idx_count = 1;
             *writemask = hlsl_reg.writemask;
@@ -3712,7 +3779,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *r
     {
         bool has_idx;
 
-        if (hlsl_sm4_register_from_semantic(ctx, &var->semantic, true, &reg->type, swizzle_type, &has_idx))
+        if (hlsl_sm4_register_from_semantic(ctx, &var->semantic, true, &reg->type, &has_idx))
         {
             unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref);
 
@@ -3723,9 +3790,9 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *r
             }
 
             if (reg->type == VKD3DSPR_DEPTHOUT)
-                reg->dim = VKD3D_SM4_DIMENSION_SCALAR;
+                reg->dimension = VSIR_DIMENSION_SCALAR;
             else
-                reg->dim = VKD3D_SM4_DIMENSION_VEC4;
+                reg->dimension = VSIR_DIMENSION_VEC4;
             *writemask = ((1u << data_type->dimx) - 1) << (offset % 4);
         }
         else
@@ -3734,7 +3801,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *r
 
             assert(hlsl_reg.allocated);
             reg->type = VKD3DSPR_OUTPUT;
-            reg->dim = VKD3D_SM4_DIMENSION_VEC4;
+            reg->dimension = VSIR_DIMENSION_VEC4;
             reg->idx[0].offset = hlsl_reg.id;
             reg->idx_count = 1;
             *writemask = hlsl_reg.writemask;
@@ -3742,77 +3809,61 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct sm4_register *r
     }
     else
     {
-        struct hlsl_reg hlsl_reg = hlsl_reg_from_deref(ctx, deref);
+        enum vkd3d_shader_register_type type = deref->var->indexable ? VKD3DSPR_IDXTEMP : VKD3DSPR_TEMP;
 
-        assert(hlsl_reg.allocated);
-        reg->type = VKD3DSPR_TEMP;
-        reg->dim = VKD3D_SM4_DIMENSION_VEC4;
-        if (swizzle_type)
-            *swizzle_type = VKD3D_SM4_SWIZZLE_VEC4;
-        reg->idx[0].offset = hlsl_reg.id;
-        reg->idx_count = 1;
-        *writemask = hlsl_reg.writemask;
+        sm4_numeric_register_from_deref(ctx, reg, type, writemask, deref, sm4_instr);
     }
 }
 
-static void sm4_src_from_deref(struct hlsl_ctx *ctx, struct sm4_src_register *src,
-        const struct hlsl_deref *deref, unsigned int map_writemask)
+static void sm4_src_from_deref(const struct tpf_writer *tpf, struct vkd3d_shader_src_param *src,
+        const struct hlsl_deref *deref, unsigned int map_writemask, struct sm4_instruction *sm4_instr)
 {
-    unsigned int writemask;
+    unsigned int hlsl_swizzle;
+    uint32_t writemask;
 
-    sm4_register_from_deref(ctx, &src->reg, &writemask, &src->swizzle_type, deref);
-    if (src->swizzle_type == VKD3D_SM4_SWIZZLE_VEC4)
-        src->swizzle = hlsl_map_swizzle(hlsl_swizzle_from_writemask(writemask), map_writemask);
-}
-
-static void sm4_register_from_node(struct sm4_register *reg, unsigned int *writemask,
-        enum vkd3d_sm4_swizzle_type *swizzle_type, const struct hlsl_ir_node *instr)
-{
-    assert(instr->reg.allocated);
-    reg->type = VKD3DSPR_TEMP;
-    reg->dim = VKD3D_SM4_DIMENSION_VEC4;
-    *swizzle_type = VKD3D_SM4_SWIZZLE_VEC4;
-    reg->idx[0].offset = instr->reg.id;
-    reg->idx_count = 1;
-    *writemask = instr->reg.writemask;
+    sm4_register_from_deref(tpf->ctx, &src->reg, &writemask, deref, sm4_instr);
+    if (vkd3d_sm4_get_default_swizzle_type(&tpf->lookup, src->reg.type) == VKD3D_SM4_SWIZZLE_VEC4)
+    {
+        hlsl_swizzle = hlsl_map_swizzle(hlsl_swizzle_from_writemask(writemask), map_writemask);
+        src->swizzle = swizzle_from_sm4(hlsl_swizzle);
+    }
 }
 
-static void sm4_dst_from_node(struct sm4_dst_register *dst, const struct hlsl_ir_node *instr)
+static void sm4_dst_from_node(struct vkd3d_shader_dst_param *dst, const struct hlsl_ir_node *instr)
 {
-    unsigned int swizzle_type;
-
-    sm4_register_from_node(&dst->reg, &dst->writemask, &swizzle_type, instr);
+    sm4_register_from_node(&dst->reg, &dst->write_mask, instr);
 }
 
-static void sm4_src_from_constant_value(struct sm4_src_register *src,
+static void sm4_src_from_constant_value(struct vkd3d_shader_src_param *src,
         const struct hlsl_constant_value *value, unsigned int width, unsigned int map_writemask)
 {
-    src->swizzle_type = VKD3D_SM4_SWIZZLE_NONE;
+    src->swizzle = 0;
     src->reg.type = VKD3DSPR_IMMCONST;
     if (width == 1)
     {
-        src->reg.dim = VKD3D_SM4_DIMENSION_SCALAR;
-        src->reg.immconst_uint[0] = value->u[0].u;
+        src->reg.dimension = VSIR_DIMENSION_SCALAR;
+        src->reg.u.immconst_uint[0] = value->u[0].u;
     }
     else
     {
         unsigned int i, j = 0;
 
-        src->reg.dim = VKD3D_SM4_DIMENSION_VEC4;
+        src->reg.dimension = VSIR_DIMENSION_VEC4;
         for (i = 0; i < 4; ++i)
         {
             if ((map_writemask & (1u << i)) && (j < width))
-                src->reg.immconst_uint[i] = value->u[j++].u;
+                src->reg.u.immconst_uint[i] = value->u[j++].u;
             else
-                src->reg.immconst_uint[i] = 0;
+                src->reg.u.immconst_uint[i] = 0;
         }
     }
 }
 
-static void sm4_src_from_node(struct sm4_src_register *src,
-        const struct hlsl_ir_node *instr, unsigned int map_writemask)
+static void sm4_src_from_node(const struct tpf_writer *tpf, struct vkd3d_shader_src_param *src,
+        const struct hlsl_ir_node *instr, uint32_t map_writemask)
 {
-    unsigned int writemask;
+    unsigned int hlsl_swizzle;
+    uint32_t writemask;
 
     if (instr->type == HLSL_IR_CONSTANT)
     {
@@ -3822,139 +3873,211 @@ static void sm4_src_from_node(struct sm4_src_register *src,
         return;
     }
 
-    sm4_register_from_node(&src->reg, &writemask, &src->swizzle_type, instr);
-    if (src->swizzle_type == VKD3D_SM4_SWIZZLE_VEC4)
-        src->swizzle = hlsl_map_swizzle(hlsl_swizzle_from_writemask(writemask), map_writemask);
+    sm4_register_from_node(&src->reg, &writemask, instr);
+    if (vkd3d_sm4_get_default_swizzle_type(&tpf->lookup, src->reg.type) == VKD3D_SM4_SWIZZLE_VEC4)
+    {
+        hlsl_swizzle = hlsl_map_swizzle(hlsl_swizzle_from_writemask(writemask), map_writemask);
+        src->swizzle = swizzle_from_sm4(hlsl_swizzle);
+    }
 }
 
-static void sm4_write_dst_register(const struct tpf_writer *tpf, const struct sm4_dst_register *dst)
+static unsigned int sm4_get_index_addressing_from_reg(const struct vkd3d_shader_register *reg,
+        unsigned int i)
+{
+    if (reg->idx[i].rel_addr)
+    {
+        if (reg->idx[i].offset == 0)
+            return VKD3D_SM4_ADDRESSING_RELATIVE;
+        else
+            return VKD3D_SM4_ADDRESSING_RELATIVE | VKD3D_SM4_ADDRESSING_OFFSET;
+    }
+
+    return 0;
+}
+
+static uint32_t sm4_encode_register(const struct tpf_writer *tpf, const struct vkd3d_shader_register *reg,
+        enum vkd3d_sm4_swizzle_type sm4_swizzle_type, uint32_t sm4_swizzle)
 {
     const struct vkd3d_sm4_register_type_info *register_type_info;
-    struct vkd3d_bytecode_buffer *buffer = tpf->buffer;
-    uint32_t sm4_reg_type, reg_dim;
+    uint32_t sm4_reg_type, sm4_reg_dim;
     uint32_t token = 0;
-    unsigned int j;
 
-    register_type_info = get_info_from_vkd3d_register_type(&tpf->lookup, dst->reg.type);
+    register_type_info = get_info_from_vkd3d_register_type(&tpf->lookup, reg->type);
     if (!register_type_info)
     {
-        FIXME("Unhandled vkd3d-shader register type %#x.\n", dst->reg.type);
+        FIXME("Unhandled vkd3d-shader register type %#x.\n", reg->type);
         sm4_reg_type = VKD3D_SM4_RT_TEMP;
+        if (sm4_swizzle_type == VKD3D_SM4_SWIZZLE_DEFAULT)
+            sm4_swizzle_type = VKD3D_SM4_SWIZZLE_VEC4;
     }
     else
     {
         sm4_reg_type = register_type_info->sm4_type;
+        if (sm4_swizzle_type == VKD3D_SM4_SWIZZLE_DEFAULT)
+            sm4_swizzle_type = register_type_info->default_src_swizzle_type;
     }
-
-    reg_dim = dst->reg.dim;
+    sm4_reg_dim = sm4_dimension_from_vsir_dimension(reg->dimension);
 
     token |= sm4_reg_type << VKD3D_SM4_REGISTER_TYPE_SHIFT;
-    token |= dst->reg.idx_count << VKD3D_SM4_REGISTER_ORDER_SHIFT;
-    token |= reg_dim << VKD3D_SM4_DIMENSION_SHIFT;
-    if (reg_dim == VKD3D_SM4_DIMENSION_VEC4)
-        token |= dst->writemask << VKD3D_SM4_WRITEMASK_SHIFT;
-    put_u32(buffer, token);
+    token |= reg->idx_count << VKD3D_SM4_REGISTER_ORDER_SHIFT;
+    token |= sm4_reg_dim << VKD3D_SM4_DIMENSION_SHIFT;
+    if (reg->idx_count > 0)
+        token |= sm4_get_index_addressing_from_reg(reg, 0) << VKD3D_SM4_ADDRESSING_SHIFT0;
+    if (reg->idx_count > 1)
+        token |= sm4_get_index_addressing_from_reg(reg, 1) << VKD3D_SM4_ADDRESSING_SHIFT1;
+    if (reg->idx_count > 2)
+        token |= sm4_get_index_addressing_from_reg(reg, 2) << VKD3D_SM4_ADDRESSING_SHIFT2;
 
-    for (j = 0; j < dst->reg.idx_count; ++j)
+    if (sm4_reg_dim == VKD3D_SM4_DIMENSION_VEC4)
     {
-        put_u32(buffer, dst->reg.idx[j].offset);
-        assert(!dst->reg.idx[j].rel_addr);
+        token |= (uint32_t)sm4_swizzle_type << VKD3D_SM4_SWIZZLE_TYPE_SHIFT;
+
+        switch (sm4_swizzle_type)
+        {
+            case VKD3D_SM4_SWIZZLE_NONE:
+                assert(sm4_swizzle || register_is_constant(reg));
+                token |= (sm4_swizzle << VKD3D_SM4_WRITEMASK_SHIFT) & VKD3D_SM4_WRITEMASK_MASK;
+                break;
+
+            case VKD3D_SM4_SWIZZLE_VEC4:
+                token |= (sm4_swizzle << VKD3D_SM4_SWIZZLE_SHIFT) & VKD3D_SM4_SWIZZLE_MASK;
+                break;
+
+            case VKD3D_SM4_SWIZZLE_SCALAR:
+                token |= (sm4_swizzle << VKD3D_SM4_SCALAR_DIM_SHIFT) & VKD3D_SM4_SCALAR_DIM_MASK;
+                break;
+
+            default:
+                vkd3d_unreachable();
+        }
     }
+
+    return token;
 }
 
-static void sm4_write_src_register(const struct tpf_writer *tpf, const struct sm4_src_register *src)
+static void sm4_write_register_index(const struct tpf_writer *tpf, const struct vkd3d_shader_register *reg,
+        unsigned int j)
 {
-    const struct vkd3d_sm4_register_type_info *register_type_info;
+    unsigned int addressing = sm4_get_index_addressing_from_reg(reg, j);
     struct vkd3d_bytecode_buffer *buffer = tpf->buffer;
-    uint32_t sm4_reg_type, reg_dim;
-    uint32_t token = 0;
-    unsigned int j;
+    unsigned int k;
 
-    register_type_info = get_info_from_vkd3d_register_type(&tpf->lookup, src->reg.type);
-    if (!register_type_info)
+    if (addressing & VKD3D_SM4_ADDRESSING_RELATIVE)
     {
-        FIXME("Unhandled vkd3d-shader register type %#x.\n", src->reg.type);
-        sm4_reg_type = VKD3D_SM4_RT_TEMP;
+        const struct vkd3d_shader_src_param *idx_src = reg->idx[j].rel_addr;
+        uint32_t idx_src_token;
+
+        assert(idx_src);
+        assert(!idx_src->modifiers);
+        assert(idx_src->reg.type != VKD3DSPR_IMMCONST);
+        idx_src_token = sm4_encode_register(tpf, &idx_src->reg, VKD3D_SM4_SWIZZLE_SCALAR, idx_src->swizzle);
+
+        put_u32(buffer, idx_src_token);
+        for (k = 0; k < idx_src->reg.idx_count; ++k)
+        {
+            put_u32(buffer, idx_src->reg.idx[k].offset);
+            assert(!idx_src->reg.idx[k].rel_addr);
+        }
     }
     else
     {
-        sm4_reg_type = register_type_info->sm4_type;
+        put_u32(tpf->buffer, reg->idx[j].offset);
     }
+}
 
-    reg_dim = src->reg.dim;
+static void sm4_write_dst_register(const struct tpf_writer *tpf, const struct vkd3d_shader_dst_param *dst)
+{
+    struct vkd3d_bytecode_buffer *buffer = tpf->buffer;
+    uint32_t token = 0;
+    unsigned int j;
 
-    token |= sm4_reg_type << VKD3D_SM4_REGISTER_TYPE_SHIFT;
-    token |= src->reg.idx_count << VKD3D_SM4_REGISTER_ORDER_SHIFT;
-    token |= reg_dim << VKD3D_SM4_DIMENSION_SHIFT;
-    if (reg_dim == VKD3D_SM4_DIMENSION_VEC4)
-    {
-        token |= (uint32_t)src->swizzle_type << VKD3D_SM4_SWIZZLE_TYPE_SHIFT;
-        token |= src->swizzle << VKD3D_SM4_SWIZZLE_SHIFT;
-    }
-    if (src->reg.mod)
-        token |= VKD3D_SM4_EXTENDED_OPERAND;
+    token = sm4_encode_register(tpf, &dst->reg, VKD3D_SM4_SWIZZLE_NONE, dst->write_mask);
     put_u32(buffer, token);
 
-    if (src->reg.mod)
-        put_u32(buffer, (src->reg.mod << VKD3D_SM4_REGISTER_MODIFIER_SHIFT)
-                | VKD3D_SM4_EXTENDED_OPERAND_MODIFIER);
+    for (j = 0; j < dst->reg.idx_count; ++j)
+        sm4_write_register_index(tpf, &dst->reg, j);
+}
 
-    for (j = 0; j < src->reg.idx_count; ++j)
+static void sm4_write_src_register(const struct tpf_writer *tpf, const struct vkd3d_shader_src_param *src)
+{
+    struct vkd3d_bytecode_buffer *buffer = tpf->buffer;
+    uint32_t token = 0, mod_token = 0;
+    unsigned int j;
+
+    token = sm4_encode_register(tpf, &src->reg, VKD3D_SM4_SWIZZLE_DEFAULT, swizzle_to_sm4(src->swizzle));
+
+    switch (src->modifiers)
     {
-        put_u32(buffer, src->reg.idx[j].offset);
-        assert(!src->reg.idx[j].rel_addr);
+        case VKD3DSPSM_NONE:
+            mod_token = VKD3D_SM4_REGISTER_MODIFIER_NONE;
+            break;
+
+        case VKD3DSPSM_ABS:
+            mod_token = (VKD3D_SM4_REGISTER_MODIFIER_ABS << VKD3D_SM4_REGISTER_MODIFIER_SHIFT)
+                    | VKD3D_SM4_EXTENDED_OPERAND_MODIFIER;
+            break;
+
+        case VKD3DSPSM_NEG:
+            mod_token = (VKD3D_SM4_REGISTER_MODIFIER_NEGATE << VKD3D_SM4_REGISTER_MODIFIER_SHIFT)
+                    | VKD3D_SM4_EXTENDED_OPERAND_MODIFIER;
+            break;
+
+        case VKD3DSPSM_ABSNEG:
+            mod_token = (VKD3D_SM4_REGISTER_MODIFIER_ABS_NEGATE << VKD3D_SM4_REGISTER_MODIFIER_SHIFT)
+                    | VKD3D_SM4_EXTENDED_OPERAND_MODIFIER;
+            break;
+
+        default:
+            ERR("Unhandled register modifier %#x.\n", src->modifiers);
+            vkd3d_unreachable();
+            break;
     }
 
+    if (src->modifiers)
+    {
+        token |= VKD3D_SM4_EXTENDED_OPERAND;
+        put_u32(buffer, token);
+        put_u32(buffer, mod_token);
+    }
+    else
+    {
+        put_u32(buffer, token);
+    }
+
+    for (j = 0; j < src->reg.idx_count; ++j)
+        sm4_write_register_index(tpf, &src->reg, j);
+
     if (src->reg.type == VKD3DSPR_IMMCONST)
     {
-        put_u32(buffer, src->reg.immconst_uint[0]);
-        if (reg_dim == VKD3D_SM4_DIMENSION_VEC4)
+        put_u32(buffer, src->reg.u.immconst_uint[0]);
+        if (src->reg.dimension == VSIR_DIMENSION_VEC4)
         {
-            put_u32(buffer, src->reg.immconst_uint[1]);
-            put_u32(buffer, src->reg.immconst_uint[2]);
-            put_u32(buffer, src->reg.immconst_uint[3]);
+            put_u32(buffer, src->reg.u.immconst_uint[1]);
+            put_u32(buffer, src->reg.u.immconst_uint[2]);
+            put_u32(buffer, src->reg.u.immconst_uint[3]);
         }
     }
 }
 
-static uint32_t sm4_register_order(const struct sm4_register *reg)
-{
-    uint32_t order = 1;
-    if (reg->type == VKD3DSPR_IMMCONST)
-        order += reg->dim == VKD3D_SM4_DIMENSION_VEC4 ? 4 : 1;
-    order += reg->idx_count;
-    if (reg->mod)
-        ++order;
-    return order;
-}
-
 static void write_sm4_instruction(const struct tpf_writer *tpf, const struct sm4_instruction *instr)
 {
     struct vkd3d_bytecode_buffer *buffer = tpf->buffer;
-    uint32_t token = instr->opcode;
-    unsigned int size = 1, i, j;
-
-    size += instr->modifier_count;
-    for (i = 0; i < instr->dst_count; ++i)
-        size += sm4_register_order(&instr->dsts[i].reg);
-    for (i = 0; i < instr->src_count; ++i)
-        size += sm4_register_order(&instr->srcs[i].reg);
-    size += instr->idx_count;
-    if (instr->byte_stride)
-        ++size;
-
-    token |= (size << VKD3D_SM4_INSTRUCTION_LENGTH_SHIFT);
+    uint32_t token = instr->opcode | instr->extra_bits;
+    unsigned int size, i, j;
+    size_t token_position;
 
     if (instr->modifier_count > 0)
         token |= VKD3D_SM4_INSTRUCTION_MODIFIER;
-    put_u32(buffer, token);
+
+    token_position = put_u32(buffer, 0);
 
     for (i = 0; i < instr->modifier_count; ++i)
     {
-        token = sm4_encode_instruction_modifier(&instr->modifiers[i]);
+        uint32_t modifier_token = sm4_encode_instruction_modifier(&instr->modifiers[i]);
+
         if (instr->modifier_count > i + 1)
-            token |= VKD3D_SM4_INSTRUCTION_MODIFIER;
-        put_u32(buffer, token);
+            modifier_token |= VKD3D_SM4_INSTRUCTION_MODIFIER;
+        put_u32(buffer, modifier_token);
     }
 
     for (i = 0; i < instr->dst_count; ++i)
@@ -3968,6 +4091,10 @@ static void write_sm4_instruction(const struct tpf_writer *tpf, const struct sm4
 
     for (j = 0; j < instr->idx_count; ++j)
         put_u32(buffer, instr->idx[j]);
+
+    size = (bytecode_get_size(buffer) - token_position) / sizeof(uint32_t);
+    token |= (size << VKD3D_SM4_INSTRUCTION_LENGTH_SHIFT);
+    set_u32(buffer, token_position, token);
 }
 
 static bool encode_texel_offset_as_aoffimmi(struct sm4_instruction *instr,
@@ -4003,13 +4130,12 @@ static void write_sm4_dcl_constant_buffer(const struct tpf_writer *tpf, const st
     {
         .opcode = VKD3D_SM4_OP_DCL_CONSTANT_BUFFER,
 
-        .srcs[0].reg.dim = VKD3D_SM4_DIMENSION_VEC4,
+        .srcs[0].reg.dimension = VSIR_DIMENSION_VEC4,
         .srcs[0].reg.type = VKD3DSPR_CONSTBUFFER,
         .srcs[0].reg.idx[0].offset = cbuffer->reg.id,
         .srcs[0].reg.idx[1].offset = (cbuffer->used_size + 3) / 4,
         .srcs[0].reg.idx_count = 2,
-        .srcs[0].swizzle_type = VKD3D_SM4_SWIZZLE_VEC4,
-        .srcs[0].swizzle = HLSL_SWIZZLE(X, Y, Z, W),
+        .srcs[0].swizzle = VKD3D_SHADER_NO_SWIZZLE,
         .src_count = 1,
     };
     write_sm4_instruction(tpf, &instr);
@@ -4031,7 +4157,7 @@ static void write_sm4_dcl_samplers(const struct tpf_writer *tpf, const struct ex
     component_type = hlsl_type_get_component_type(tpf->ctx, resource->data_type, 0);
 
     if (component_type->sampler_dim == HLSL_SAMPLER_DIM_COMPARISON)
-        instr.opcode |= VKD3D_SM4_SAMPLER_COMPARISON << VKD3D_SM4_SAMPLER_MODE_SHIFT;
+        instr.extra_bits |= VKD3D_SM4_SAMPLER_COMPARISON << VKD3D_SM4_SAMPLER_MODE_SHIFT;
 
     assert(resource->regset == HLSL_REGSET_SAMPLERS);
 
@@ -4090,12 +4216,12 @@ static void write_sm4_dcl_textures(const struct tpf_writer *tpf, const struct ex
         {
             instr.opcode = VKD3D_SM4_OP_DCL_RESOURCE;
         }
-        instr.opcode |= (sm4_resource_dimension(component_type) << VKD3D_SM4_RESOURCE_TYPE_SHIFT);
+        instr.extra_bits |= (sm4_resource_dimension(component_type) << VKD3D_SM4_RESOURCE_TYPE_SHIFT);
 
         if (component_type->sampler_dim == HLSL_SAMPLER_DIM_2DMS
                 || component_type->sampler_dim == HLSL_SAMPLER_DIM_2DMSARRAY)
         {
-            instr.opcode |= component_type->sample_count << VKD3D_SM4_RESOURCE_SAMPLE_COUNT_SHIFT;
+            instr.extra_bits |= component_type->sample_count << VKD3D_SM4_RESOURCE_SAMPLE_COUNT_SHIFT;
         }
 
         write_sm4_instruction(tpf, &instr);
@@ -4111,11 +4237,11 @@ static void write_sm4_dcl_semantic(const struct tpf_writer *tpf, const struct hl
 
     struct sm4_instruction instr =
     {
-        .dsts[0].reg.dim = VKD3D_SM4_DIMENSION_VEC4,
+        .dsts[0].reg.dimension = VSIR_DIMENSION_VEC4,
         .dst_count = 1,
     };
 
-    if (hlsl_sm4_register_from_semantic(tpf->ctx, &var->semantic, output, &instr.dsts[0].reg.type, NULL, &has_idx))
+    if (hlsl_sm4_register_from_semantic(tpf->ctx, &var->semantic, output, &instr.dsts[0].reg.type, &has_idx))
     {
         if (has_idx)
         {
@@ -4126,18 +4252,18 @@ static void write_sm4_dcl_semantic(const struct tpf_writer *tpf, const struct hl
         {
             instr.dsts[0].reg.idx_count = 0;
         }
-        instr.dsts[0].writemask = (1 << var->data_type->dimx) - 1;
+        instr.dsts[0].write_mask = (1 << var->data_type->dimx) - 1;
     }
     else
     {
         instr.dsts[0].reg.type = output ? VKD3DSPR_OUTPUT : VKD3DSPR_INPUT;
         instr.dsts[0].reg.idx[0].offset = var->regs[HLSL_REGSET_NUMERIC].id;
         instr.dsts[0].reg.idx_count = 1;
-        instr.dsts[0].writemask = var->regs[HLSL_REGSET_NUMERIC].writemask;
+        instr.dsts[0].write_mask = var->regs[HLSL_REGSET_NUMERIC].writemask;
     }
 
     if (instr.dsts[0].reg.type == VKD3DSPR_DEPTHOUT)
-        instr.dsts[0].reg.dim = VKD3D_SM4_DIMENSION_SCALAR;
+        instr.dsts[0].reg.dimension = VSIR_DIMENSION_SCALAR;
 
     hlsl_sm4_usage_from_semantic(tpf->ctx, &var->semantic, output, &usage);
     if (usage == ~0u)
@@ -4170,9 +4296,35 @@ static void write_sm4_dcl_semantic(const struct tpf_writer *tpf, const struct hl
             enum vkd3d_shader_interpolation_mode mode = VKD3DSIM_LINEAR;
 
             if ((var->storage_modifiers & HLSL_STORAGE_NOINTERPOLATION) || type_is_integer(var->data_type))
+            {
                 mode = VKD3DSIM_CONSTANT;
+            }
+            else
+            {
+                static const struct
+                {
+                    unsigned int modifiers;
+                    enum vkd3d_shader_interpolation_mode mode;
+                }
+                modes[] =
+                {
+                    { HLSL_STORAGE_CENTROID | HLSL_STORAGE_NOPERSPECTIVE, VKD3DSIM_LINEAR_NOPERSPECTIVE_CENTROID },
+                    { HLSL_STORAGE_NOPERSPECTIVE, VKD3DSIM_LINEAR_NOPERSPECTIVE },
+                    { HLSL_STORAGE_CENTROID, VKD3DSIM_LINEAR_CENTROID },
+                };
+                unsigned int i;
 
-            instr.opcode |= mode << VKD3D_SM4_INTERPOLATION_MODE_SHIFT;
+                for (i = 0; i < ARRAY_SIZE(modes); ++i)
+                {
+                    if ((var->storage_modifiers & modes[i].modifiers) == modes[i].modifiers)
+                    {
+                        mode = modes[i].mode;
+                        break;
+                    }
+                }
+            }
+
+            instr.extra_bits |= mode << VKD3D_SM4_INTERPOLATION_MODE_SHIFT;
         }
     }
     else
@@ -4215,6 +4367,20 @@ static void write_sm4_dcl_temps(const struct tpf_writer *tpf, uint32_t temp_coun
     write_sm4_instruction(tpf, &instr);
 }
 
+static void write_sm4_dcl_indexable_temp(const struct tpf_writer *tpf, uint32_t idx,
+        uint32_t size, uint32_t comp_count)
+{
+    struct sm4_instruction instr =
+    {
+        .opcode = VKD3D_SM4_OP_DCL_INDEXABLE_TEMP,
+
+        .idx = {idx, size, comp_count},
+        .idx_count = 3,
+    };
+
+    write_sm4_instruction(tpf, &instr);
+}
+
 static void write_sm4_dcl_thread_group(const struct tpf_writer *tpf, const uint32_t thread_count[3])
 {
     struct sm4_instruction instr =
@@ -4241,7 +4407,7 @@ static void write_sm4_ret(const struct tpf_writer *tpf)
 }
 
 static void write_sm4_unary_op(const struct tpf_writer *tpf, enum vkd3d_sm4_opcode opcode,
-        const struct hlsl_ir_node *dst, const struct hlsl_ir_node *src, unsigned int src_mod)
+        const struct hlsl_ir_node *dst, const struct hlsl_ir_node *src, enum vkd3d_shader_src_modifier src_mod)
 {
     struct sm4_instruction instr;
 
@@ -4251,8 +4417,8 @@ static void write_sm4_unary_op(const struct tpf_writer *tpf, enum vkd3d_sm4_opco
     sm4_dst_from_node(&instr.dsts[0], dst);
     instr.dst_count = 1;
 
-    sm4_src_from_node(&instr.srcs[0], src, instr.dsts[0].writemask);
-    instr.srcs[0].reg.mod = src_mod;
+    sm4_src_from_node(tpf, &instr.srcs[0], src, instr.dsts[0].write_mask);
+    instr.srcs[0].modifiers = src_mod;
     instr.src_count = 1;
 
     write_sm4_instruction(tpf, &instr);
@@ -4270,11 +4436,11 @@ static void write_sm4_unary_op_with_two_destinations(const struct tpf_writer *tp
     sm4_dst_from_node(&instr.dsts[dst_idx], dst);
     assert(1 - dst_idx >= 0);
     instr.dsts[1 - dst_idx].reg.type = VKD3DSPR_NULL;
-    instr.dsts[1 - dst_idx].reg.dim = VKD3D_SM4_DIMENSION_NONE;
+    instr.dsts[1 - dst_idx].reg.dimension = VSIR_DIMENSION_NONE;
     instr.dsts[1 - dst_idx].reg.idx_count = 0;
     instr.dst_count = 2;
 
-    sm4_src_from_node(&instr.srcs[0], src, instr.dsts[dst_idx].writemask);
+    sm4_src_from_node(tpf, &instr.srcs[0], src, instr.dsts[dst_idx].write_mask);
     instr.src_count = 1;
 
     write_sm4_instruction(tpf, &instr);
@@ -4291,8 +4457,8 @@ static void write_sm4_binary_op(const struct tpf_writer *tpf, enum vkd3d_sm4_opc
     sm4_dst_from_node(&instr.dsts[0], dst);
     instr.dst_count = 1;
 
-    sm4_src_from_node(&instr.srcs[0], src1, instr.dsts[0].writemask);
-    sm4_src_from_node(&instr.srcs[1], src2, instr.dsts[0].writemask);
+    sm4_src_from_node(tpf, &instr.srcs[0], src1, instr.dsts[0].write_mask);
+    sm4_src_from_node(tpf, &instr.srcs[1], src2, instr.dsts[0].write_mask);
     instr.src_count = 2;
 
     write_sm4_instruction(tpf, &instr);
@@ -4310,8 +4476,8 @@ static void write_sm4_binary_op_dot(const struct tpf_writer *tpf, enum vkd3d_sm4
     sm4_dst_from_node(&instr.dsts[0], dst);
     instr.dst_count = 1;
 
-    sm4_src_from_node(&instr.srcs[0], src1, VKD3DSP_WRITEMASK_ALL);
-    sm4_src_from_node(&instr.srcs[1], src2, VKD3DSP_WRITEMASK_ALL);
+    sm4_src_from_node(tpf, &instr.srcs[0], src1, VKD3DSP_WRITEMASK_ALL);
+    sm4_src_from_node(tpf, &instr.srcs[1], src2, VKD3DSP_WRITEMASK_ALL);
     instr.src_count = 2;
 
     write_sm4_instruction(tpf, &instr);
@@ -4330,12 +4496,12 @@ static void write_sm4_binary_op_with_two_destinations(const struct tpf_writer *t
     sm4_dst_from_node(&instr.dsts[dst_idx], dst);
     assert(1 - dst_idx >= 0);
     instr.dsts[1 - dst_idx].reg.type = VKD3DSPR_NULL;
-    instr.dsts[1 - dst_idx].reg.dim = VKD3D_SM4_DIMENSION_NONE;
+    instr.dsts[1 - dst_idx].reg.dimension = VSIR_DIMENSION_NONE;
     instr.dsts[1 - dst_idx].reg.idx_count = 0;
     instr.dst_count = 2;
 
-    sm4_src_from_node(&instr.srcs[0], src1, instr.dsts[dst_idx].writemask);
-    sm4_src_from_node(&instr.srcs[1], src2, instr.dsts[dst_idx].writemask);
+    sm4_src_from_node(tpf, &instr.srcs[0], src1, instr.dsts[dst_idx].write_mask);
+    sm4_src_from_node(tpf, &instr.srcs[1], src2, instr.dsts[dst_idx].write_mask);
     instr.src_count = 2;
 
     write_sm4_instruction(tpf, &instr);
@@ -4353,9 +4519,9 @@ static void write_sm4_ternary_op(const struct tpf_writer *tpf, enum vkd3d_sm4_op
     sm4_dst_from_node(&instr.dsts[0], dst);
     instr.dst_count = 1;
 
-    sm4_src_from_node(&instr.srcs[0], src1, instr.dsts[0].writemask);
-    sm4_src_from_node(&instr.srcs[1], src2, instr.dsts[0].writemask);
-    sm4_src_from_node(&instr.srcs[2], src3, instr.dsts[0].writemask);
+    sm4_src_from_node(tpf, &instr.srcs[0], src1, instr.dsts[0].write_mask);
+    sm4_src_from_node(tpf, &instr.srcs[1], src2, instr.dsts[0].write_mask);
+    sm4_src_from_node(tpf, &instr.srcs[2], src3, instr.dsts[0].write_mask);
     instr.src_count = 3;
 
     write_sm4_instruction(tpf, &instr);
@@ -4369,7 +4535,7 @@ static void write_sm4_ld(const struct tpf_writer *tpf, const struct hlsl_ir_node
     const struct hlsl_type *resource_type = hlsl_deref_get_type(tpf->ctx, resource);
     bool multisampled = resource_type->base_type == HLSL_TYPE_TEXTURE
             && (resource_type->sampler_dim == HLSL_SAMPLER_DIM_2DMS || resource_type->sampler_dim == HLSL_SAMPLER_DIM_2DMSARRAY);
-    bool uav = (hlsl_type_get_regset(resource_type) == HLSL_REGSET_UAVS);
+    bool uav = (hlsl_deref_get_regset(tpf->ctx, resource) == HLSL_REGSET_UAVS);
     unsigned int coords_writemask = VKD3DSP_WRITEMASK_ALL;
     struct sm4_instruction instr;
 
@@ -4404,9 +4570,9 @@ static void write_sm4_ld(const struct tpf_writer *tpf, const struct hlsl_ir_node
             coords_writemask = VKD3DSP_WRITEMASK_0 | VKD3DSP_WRITEMASK_1 | VKD3DSP_WRITEMASK_3;
     }
 
-    sm4_src_from_node(&instr.srcs[0], coords, coords_writemask);
+    sm4_src_from_node(tpf, &instr.srcs[0], coords, coords_writemask);
 
-    sm4_src_from_deref(tpf->ctx, &instr.srcs[1], resource, instr.dsts[0].writemask);
+    sm4_src_from_deref(tpf, &instr.srcs[1], resource, instr.dsts[0].write_mask, &instr);
 
     instr.src_count = 2;
 
@@ -4414,16 +4580,15 @@ static void write_sm4_ld(const struct tpf_writer *tpf, const struct hlsl_ir_node
     {
         if (sample_index->type == HLSL_IR_CONSTANT)
         {
-            struct sm4_register *reg = &instr.srcs[2].reg;
+            struct vkd3d_shader_register *reg = &instr.srcs[2].reg;
             struct hlsl_ir_constant *index;
 
             index = hlsl_ir_constant(sample_index);
 
             memset(&instr.srcs[2], 0, sizeof(instr.srcs[2]));
-            instr.srcs[2].swizzle_type = VKD3D_SM4_SWIZZLE_NONE;
             reg->type = VKD3DSPR_IMMCONST;
-            reg->dim = VKD3D_SM4_DIMENSION_SCALAR;
-            reg->immconst_uint[0] = index->value.u[0].u;
+            reg->dimension = VSIR_DIMENSION_SCALAR;
+            reg->u.immconst_uint[0] = index->value.u[0].u;
         }
         else if (tpf->ctx->profile->major_version == 4 && tpf->ctx->profile->minor_version == 0)
         {
@@ -4431,7 +4596,7 @@ static void write_sm4_ld(const struct tpf_writer *tpf, const struct hlsl_ir_node
         }
         else
         {
-            sm4_src_from_node(&instr.srcs[2], sample_index, 0);
+            sm4_src_from_node(tpf, &instr.srcs[2], sample_index, 0);
         }
 
         ++instr.src_count;
@@ -4493,27 +4658,27 @@ static void write_sm4_sample(const struct tpf_writer *tpf, const struct hlsl_ir_
     sm4_dst_from_node(&instr.dsts[0], dst);
     instr.dst_count = 1;
 
-    sm4_src_from_node(&instr.srcs[0], coords, VKD3DSP_WRITEMASK_ALL);
-    sm4_src_from_deref(tpf->ctx, &instr.srcs[1], resource, instr.dsts[0].writemask);
-    sm4_src_from_deref(tpf->ctx, &instr.srcs[2], sampler, VKD3DSP_WRITEMASK_ALL);
+    sm4_src_from_node(tpf, &instr.srcs[0], coords, VKD3DSP_WRITEMASK_ALL);
+    sm4_src_from_deref(tpf, &instr.srcs[1], resource, instr.dsts[0].write_mask, &instr);
+    sm4_src_from_deref(tpf, &instr.srcs[2], sampler, VKD3DSP_WRITEMASK_ALL, &instr);
     instr.src_count = 3;
 
     if (load->load_type == HLSL_RESOURCE_SAMPLE_LOD
            || load->load_type == HLSL_RESOURCE_SAMPLE_LOD_BIAS)
     {
-        sm4_src_from_node(&instr.srcs[3], load->lod.node, VKD3DSP_WRITEMASK_ALL);
+        sm4_src_from_node(tpf, &instr.srcs[3], load->lod.node, VKD3DSP_WRITEMASK_ALL);
         ++instr.src_count;
     }
     else if (load->load_type == HLSL_RESOURCE_SAMPLE_GRAD)
     {
-        sm4_src_from_node(&instr.srcs[3], load->ddx.node, VKD3DSP_WRITEMASK_ALL);
-        sm4_src_from_node(&instr.srcs[4], load->ddy.node, VKD3DSP_WRITEMASK_ALL);
+        sm4_src_from_node(tpf, &instr.srcs[3], load->ddx.node, VKD3DSP_WRITEMASK_ALL);
+        sm4_src_from_node(tpf, &instr.srcs[4], load->ddy.node, VKD3DSP_WRITEMASK_ALL);
         instr.src_count += 2;
     }
     else if (load->load_type == HLSL_RESOURCE_SAMPLE_CMP
             || load->load_type == HLSL_RESOURCE_SAMPLE_CMP_LZ)
     {
-        sm4_src_from_node(&instr.srcs[3], load->cmp.node, VKD3DSP_WRITEMASK_ALL);
+        sm4_src_from_node(tpf, &instr.srcs[3], load->cmp.node, VKD3DSP_WRITEMASK_ALL);
         ++instr.src_count;
     }
 
@@ -4531,12 +4696,12 @@ static void write_sm4_sampleinfo(const struct tpf_writer *tpf, const struct hlsl
     memset(&instr, 0, sizeof(instr));
     instr.opcode = VKD3D_SM4_OP_SAMPLE_INFO;
     if (dst->data_type->base_type == HLSL_TYPE_UINT)
-        instr.opcode |= VKD3DSI_SAMPLE_INFO_UINT << VKD3D_SM4_INSTRUCTION_FLAGS_SHIFT;
+        instr.extra_bits |= VKD3DSI_SAMPLE_INFO_UINT << VKD3D_SM4_INSTRUCTION_FLAGS_SHIFT;
 
     sm4_dst_from_node(&instr.dsts[0], dst);
     instr.dst_count = 1;
 
-    sm4_src_from_deref(tpf->ctx, &instr.srcs[0], resource, instr.dsts[0].writemask);
+    sm4_src_from_deref(tpf, &instr.srcs[0], resource, instr.dsts[0].write_mask, &instr);
     instr.src_count = 1;
 
     write_sm4_instruction(tpf, &instr);
@@ -4553,13 +4718,13 @@ static void write_sm4_resinfo(const struct tpf_writer *tpf, const struct hlsl_ir
     memset(&instr, 0, sizeof(instr));
     instr.opcode = VKD3D_SM4_OP_RESINFO;
     if (dst->data_type->base_type == HLSL_TYPE_UINT)
-        instr.opcode |= VKD3DSI_RESINFO_UINT << VKD3D_SM4_INSTRUCTION_FLAGS_SHIFT;
+        instr.extra_bits |= VKD3DSI_RESINFO_UINT << VKD3D_SM4_INSTRUCTION_FLAGS_SHIFT;
 
     sm4_dst_from_node(&instr.dsts[0], dst);
     instr.dst_count = 1;
 
-    sm4_src_from_node(&instr.srcs[0], load->lod.node, VKD3DSP_WRITEMASK_ALL);
-    sm4_src_from_deref(tpf->ctx, &instr.srcs[1], resource, instr.dsts[0].writemask);
+    sm4_src_from_node(tpf, &instr.srcs[0], load->lod.node, VKD3DSP_WRITEMASK_ALL);
+    sm4_src_from_deref(tpf, &instr.srcs[1], resource, instr.dsts[0].write_mask, &instr);
     instr.src_count = 2;
 
     write_sm4_instruction(tpf, &instr);
@@ -4581,11 +4746,10 @@ static void write_sm4_cast_from_bool(const struct tpf_writer *tpf, const struct
     sm4_dst_from_node(&instr.dsts[0], &expr->node);
     instr.dst_count = 1;
 
-    sm4_src_from_node(&instr.srcs[0], arg, instr.dsts[0].writemask);
-    instr.srcs[1].swizzle_type = VKD3D_SM4_SWIZZLE_NONE;
+    sm4_src_from_node(tpf, &instr.srcs[0], arg, instr.dsts[0].write_mask);
     instr.srcs[1].reg.type = VKD3DSPR_IMMCONST;
-    instr.srcs[1].reg.dim = VKD3D_SM4_DIMENSION_SCALAR;
-    instr.srcs[1].reg.immconst_uint[0] = mask;
+    instr.srcs[1].reg.dimension = VSIR_DIMENSION_SCALAR;
+    instr.srcs[1].reg.u.immconst_uint[0] = mask;
     instr.src_count = 2;
 
     write_sm4_instruction(tpf, &instr);
@@ -4708,11 +4872,11 @@ static void write_sm4_store_uav_typed(const struct tpf_writer *tpf, const struct
     memset(&instr, 0, sizeof(instr));
     instr.opcode = VKD3D_SM5_OP_STORE_UAV_TYPED;
 
-    sm4_register_from_deref(tpf->ctx, &instr.dsts[0].reg, &instr.dsts[0].writemask, NULL, dst);
+    sm4_register_from_deref(tpf->ctx, &instr.dsts[0].reg, &instr.dsts[0].write_mask, dst, &instr);
     instr.dst_count = 1;
 
-    sm4_src_from_node(&instr.srcs[0], coords, VKD3DSP_WRITEMASK_ALL);
-    sm4_src_from_node(&instr.srcs[1], value, VKD3DSP_WRITEMASK_ALL);
+    sm4_src_from_node(tpf, &instr.srcs[0], coords, VKD3DSP_WRITEMASK_ALL);
+    sm4_src_from_node(tpf, &instr.srcs[1], value, VKD3DSP_WRITEMASK_ALL);
     instr.src_count = 2;
 
     write_sm4_instruction(tpf, &instr);
@@ -4737,7 +4901,7 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
             switch (dst_type->base_type)
             {
                 case HLSL_TYPE_FLOAT:
-                    write_sm4_unary_op(tpf, VKD3D_SM4_OP_MOV, &expr->node, arg1, VKD3D_SM4_REGISTER_MODIFIER_ABS);
+                    write_sm4_unary_op(tpf, VKD3D_SM4_OP_MOV, &expr->node, arg1, VKD3DSPSM_ABS);
                     break;
 
                 default:
@@ -4754,6 +4918,11 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
             write_sm4_cast(tpf, expr);
             break;
 
+        case HLSL_OP1_CEIL:
+            assert(type_is_float(dst_type));
+            write_sm4_unary_op(tpf, VKD3D_SM4_OP_ROUND_PI, &expr->node, arg1, 0);
+            break;
+
         case HLSL_OP1_COS:
             assert(type_is_float(dst_type));
             write_sm4_unary_op_with_two_destinations(tpf, VKD3D_SM4_OP_SINCOS, &expr->node, 1, arg1);
@@ -4818,7 +4987,7 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
             switch (dst_type->base_type)
             {
                 case HLSL_TYPE_FLOAT:
-                    write_sm4_unary_op(tpf, VKD3D_SM4_OP_MOV, &expr->node, arg1, VKD3D_SM4_REGISTER_MODIFIER_NEGATE);
+                    write_sm4_unary_op(tpf, VKD3D_SM4_OP_MOV, &expr->node, arg1, VKD3DSPSM_NEG);
                     break;
 
                 case HLSL_TYPE_INT:
@@ -5169,7 +5338,7 @@ static void write_sm4_if(const struct tpf_writer *tpf, const struct hlsl_ir_if *
 
     assert(iff->condition.node->data_type->dimx == 1);
 
-    sm4_src_from_node(&instr.srcs[0], iff->condition.node, VKD3DSP_WRITEMASK_ALL);
+    sm4_src_from_node(tpf, &instr.srcs[0], iff->condition.node, VKD3DSP_WRITEMASK_ALL);
     write_sm4_instruction(tpf, &instr);
 
     write_sm4_block(tpf, &iff->then_block);
@@ -5198,13 +5367,17 @@ static void write_sm4_jump(const struct tpf_writer *tpf, const struct hlsl_ir_ju
             instr.opcode = VKD3D_SM4_OP_BREAK;
             break;
 
+        case HLSL_IR_JUMP_CONTINUE:
+            instr.opcode = VKD3D_SM4_OP_CONTINUE;
+            break;
+
         case HLSL_IR_JUMP_DISCARD_NZ:
         {
             instr.opcode = VKD3D_SM4_OP_DISCARD | VKD3D_SM4_CONDITIONAL_NZ;
 
             memset(&instr.srcs[0], 0, sizeof(*instr.srcs));
             instr.src_count = 1;
-            sm4_src_from_node(&instr.srcs[0], jump->condition.node, VKD3DSP_WRITEMASK_ALL);
+            sm4_src_from_node(tpf, &instr.srcs[0], jump->condition.node, VKD3DSP_WRITEMASK_ALL);
             break;
         }
 
@@ -5240,7 +5413,7 @@ static void write_sm4_load(const struct tpf_writer *tpf, const struct hlsl_ir_lo
     sm4_dst_from_node(&instr.dsts[0], &load->node);
     instr.dst_count = 1;
 
-    assert(type->class <= HLSL_CLASS_LAST_NUMERIC);
+    assert(hlsl_is_numeric_type(type));
     if (type->base_type == HLSL_TYPE_BOOL && var_is_user_input(tpf->ctx, load->src.var))
     {
         struct hlsl_constant_value value;
@@ -5250,19 +5423,19 @@ static void write_sm4_load(const struct tpf_writer *tpf, const struct hlsl_ir_lo
 
         instr.opcode = VKD3D_SM4_OP_MOVC;
 
-        sm4_src_from_deref(tpf->ctx, &instr.srcs[0], &load->src, instr.dsts[0].writemask);
+        sm4_src_from_deref(tpf, &instr.srcs[0], &load->src, instr.dsts[0].write_mask, &instr);
 
         memset(&value, 0xff, sizeof(value));
-        sm4_src_from_constant_value(&instr.srcs[1], &value, type->dimx, instr.dsts[0].writemask);
+        sm4_src_from_constant_value(&instr.srcs[1], &value, type->dimx, instr.dsts[0].write_mask);
         memset(&value, 0, sizeof(value));
-        sm4_src_from_constant_value(&instr.srcs[2], &value, type->dimx, instr.dsts[0].writemask);
+        sm4_src_from_constant_value(&instr.srcs[2], &value, type->dimx, instr.dsts[0].write_mask);
         instr.src_count = 3;
     }
     else
     {
         instr.opcode = VKD3D_SM4_OP_MOV;
 
-        sm4_src_from_deref(tpf->ctx, &instr.srcs[0], &load->src, instr.dsts[0].writemask);
+        sm4_src_from_deref(tpf, &instr.srcs[0], &load->src, instr.dsts[0].write_mask, &instr);
         instr.src_count = 1;
     }
 
@@ -5285,10 +5458,10 @@ static void write_sm4_loop(const struct tpf_writer *tpf, const struct hlsl_ir_lo
 }
 
 static void write_sm4_gather(const struct tpf_writer *tpf, const struct hlsl_ir_node *dst,
-        const struct hlsl_deref *resource, const struct hlsl_deref *sampler,  const struct hlsl_ir_node *coords,
-        unsigned int swizzle, const struct hlsl_ir_node *texel_offset)
+        const struct hlsl_deref *resource, const struct hlsl_deref *sampler,
+        const struct hlsl_ir_node *coords, DWORD swizzle, const struct hlsl_ir_node *texel_offset)
 {
-    struct sm4_src_register *src;
+    struct vkd3d_shader_src_param *src;
     struct sm4_instruction instr;
 
     memset(&instr, 0, sizeof(instr));
@@ -5298,7 +5471,7 @@ static void write_sm4_gather(const struct tpf_writer *tpf, const struct hlsl_ir_
     sm4_dst_from_node(&instr.dsts[0], dst);
     instr.dst_count = 1;
 
-    sm4_src_from_node(&instr.srcs[instr.src_count++], coords, VKD3DSP_WRITEMASK_ALL);
+    sm4_src_from_node(tpf, &instr.srcs[instr.src_count++], coords, VKD3DSP_WRITEMASK_ALL);
 
     if (texel_offset)
     {
@@ -5311,16 +5484,15 @@ static void write_sm4_gather(const struct tpf_writer *tpf, const struct hlsl_ir_
                 return;
             }
             instr.opcode = VKD3D_SM5_OP_GATHER4_PO;
-            sm4_src_from_node(&instr.srcs[instr.src_count++], texel_offset, VKD3DSP_WRITEMASK_ALL);
+            sm4_src_from_node(tpf, &instr.srcs[instr.src_count++], texel_offset, VKD3DSP_WRITEMASK_ALL);
         }
     }
 
-    sm4_src_from_deref(tpf->ctx, &instr.srcs[instr.src_count++], resource, instr.dsts[0].writemask);
+    sm4_src_from_deref(tpf, &instr.srcs[instr.src_count++], resource, instr.dsts[0].write_mask, &instr);
 
     src = &instr.srcs[instr.src_count++];
-    sm4_src_from_deref(tpf->ctx, src, sampler, VKD3DSP_WRITEMASK_ALL);
-    src->reg.dim = VKD3D_SM4_DIMENSION_VEC4;
-    src->swizzle_type = VKD3D_SM4_SWIZZLE_SCALAR;
+    sm4_src_from_deref(tpf, src, sampler, VKD3DSP_WRITEMASK_ALL, &instr);
+    src->reg.dimension = VSIR_DIMENSION_VEC4;
     src->swizzle = swizzle;
 
     write_sm4_instruction(tpf, &instr);
@@ -5364,22 +5536,22 @@ static void write_sm4_resource_load(const struct tpf_writer *tpf, const struct h
 
         case HLSL_RESOURCE_GATHER_RED:
             write_sm4_gather(tpf, &load->node, &load->resource, &load->sampler, coords,
-                    HLSL_SWIZZLE(X, X, X, X), texel_offset);
+                    VKD3D_SHADER_SWIZZLE(X, X, X, X), texel_offset);
             break;
 
         case HLSL_RESOURCE_GATHER_GREEN:
             write_sm4_gather(tpf, &load->node, &load->resource, &load->sampler, coords,
-                    HLSL_SWIZZLE(Y, Y, Y, Y), texel_offset);
+                    VKD3D_SHADER_SWIZZLE(Y, Y, Y, Y), texel_offset);
             break;
 
         case HLSL_RESOURCE_GATHER_BLUE:
             write_sm4_gather(tpf, &load->node, &load->resource, &load->sampler, coords,
-                    HLSL_SWIZZLE(Z, Z, Z, Z), texel_offset);
+                    VKD3D_SHADER_SWIZZLE(Z, Z, Z, Z), texel_offset);
             break;
 
         case HLSL_RESOURCE_GATHER_ALPHA:
             write_sm4_gather(tpf, &load->node, &load->resource, &load->sampler, coords,
-                    HLSL_SWIZZLE(W, W, W, W), texel_offset);
+                    VKD3D_SHADER_SWIZZLE(W, W, W, W), texel_offset);
             break;
 
         case HLSL_RESOURCE_SAMPLE_INFO:
@@ -5389,6 +5561,9 @@ static void write_sm4_resource_load(const struct tpf_writer *tpf, const struct h
         case HLSL_RESOURCE_RESINFO:
             write_sm4_resinfo(tpf, load);
             break;
+
+        case HLSL_RESOURCE_SAMPLE_PROJ:
+            vkd3d_unreachable();
     }
 }
 
@@ -5415,25 +5590,66 @@ static void write_sm4_store(const struct tpf_writer *tpf, const struct hlsl_ir_s
 {
     const struct hlsl_ir_node *rhs = store->rhs.node;
     struct sm4_instruction instr;
-    unsigned int writemask;
+    uint32_t writemask;
 
     memset(&instr, 0, sizeof(instr));
     instr.opcode = VKD3D_SM4_OP_MOV;
 
-    sm4_register_from_deref(tpf->ctx, &instr.dsts[0].reg, &writemask, NULL, &store->lhs);
-    instr.dsts[0].writemask = hlsl_combine_writemasks(writemask, store->writemask);
+    sm4_register_from_deref(tpf->ctx, &instr.dsts[0].reg, &writemask, &store->lhs, &instr);
+    instr.dsts[0].write_mask = hlsl_combine_writemasks(writemask, store->writemask);
     instr.dst_count = 1;
 
-    sm4_src_from_node(&instr.srcs[0], rhs, instr.dsts[0].writemask);
+    sm4_src_from_node(tpf, &instr.srcs[0], rhs, instr.dsts[0].write_mask);
     instr.src_count = 1;
 
     write_sm4_instruction(tpf, &instr);
 }
 
+static void write_sm4_switch(const struct tpf_writer *tpf, const struct hlsl_ir_switch *s)
+{
+    const struct hlsl_ir_node *selector = s->selector.node;
+    struct hlsl_ir_switch_case *c;
+    struct sm4_instruction instr;
+
+    memset(&instr, 0, sizeof(instr));
+    instr.opcode = VKD3D_SM4_OP_SWITCH;
+
+    sm4_src_from_node(tpf, &instr.srcs[0], selector, VKD3DSP_WRITEMASK_ALL);
+    instr.src_count = 1;
+
+    write_sm4_instruction(tpf, &instr);
+
+    LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
+    {
+        memset(&instr, 0, sizeof(instr));
+        if (c->is_default)
+        {
+            instr.opcode = VKD3D_SM4_OP_DEFAULT;
+        }
+        else
+        {
+            struct hlsl_constant_value value = { .u[0].u = c->value };
+
+            instr.opcode = VKD3D_SM4_OP_CASE;
+            sm4_src_from_constant_value(&instr.srcs[0], &value, 1, VKD3DSP_WRITEMASK_ALL);
+            instr.src_count = 1;
+        }
+
+        write_sm4_instruction(tpf, &instr);
+        write_sm4_block(tpf, &c->body);
+    }
+
+    memset(&instr, 0, sizeof(instr));
+    instr.opcode = VKD3D_SM4_OP_ENDSWITCH;
+
+    write_sm4_instruction(tpf, &instr);
+}
+
 static void write_sm4_swizzle(const struct tpf_writer *tpf, const struct hlsl_ir_swizzle *swizzle)
 {
+    unsigned int hlsl_swizzle;
     struct sm4_instruction instr;
-    unsigned int writemask;
+    uint32_t writemask;
 
     memset(&instr, 0, sizeof(instr));
     instr.opcode = VKD3D_SM4_OP_MOV;
@@ -5441,9 +5657,10 @@ static void write_sm4_swizzle(const struct tpf_writer *tpf, const struct hlsl_ir
     sm4_dst_from_node(&instr.dsts[0], &swizzle->node);
     instr.dst_count = 1;
 
-    sm4_register_from_node(&instr.srcs[0].reg, &writemask, &instr.srcs[0].swizzle_type, swizzle->val.node);
-    instr.srcs[0].swizzle = hlsl_map_swizzle(hlsl_combine_swizzles(hlsl_swizzle_from_writemask(writemask),
-            swizzle->swizzle, swizzle->node.data_type->dimx), instr.dsts[0].writemask);
+    sm4_register_from_node(&instr.srcs[0].reg, &writemask, swizzle->val.node);
+    hlsl_swizzle = hlsl_map_swizzle(hlsl_combine_swizzles(hlsl_swizzle_from_writemask(writemask),
+            swizzle->swizzle, swizzle->node.data_type->dimx), instr.dsts[0].write_mask);
+    instr.srcs[0].swizzle = swizzle_from_sm4(hlsl_swizzle);
     instr.src_count = 1;
 
     write_sm4_instruction(tpf, &instr);
@@ -5515,6 +5732,10 @@ static void write_sm4_block(const struct tpf_writer *tpf, const struct hlsl_bloc
                 write_sm4_store(tpf, hlsl_ir_store(instr));
                 break;
 
+            case HLSL_IR_SWITCH:
+                write_sm4_switch(tpf, hlsl_ir_switch(instr));
+                break;
+
             case HLSL_IR_SWIZZLE:
                 write_sm4_swizzle(tpf, hlsl_ir_swizzle(instr));
                 break;
@@ -5533,6 +5754,7 @@ static void write_sm4_shdr(struct hlsl_ctx *ctx,
     struct extern_resource *extern_resources;
     unsigned int extern_resources_count, i;
     const struct hlsl_buffer *cbuffer;
+    const struct hlsl_scope *scope;
     const struct hlsl_ir_var *var;
     size_t token_count_position;
     struct tpf_writer tpf;
@@ -5587,6 +5809,25 @@ static void write_sm4_shdr(struct hlsl_ctx *ctx,
     if (ctx->temp_count)
         write_sm4_dcl_temps(&tpf, ctx->temp_count);
 
+    LIST_FOR_EACH_ENTRY(scope, &ctx->scopes, struct hlsl_scope, entry)
+    {
+        LIST_FOR_EACH_ENTRY(var, &scope->vars, struct hlsl_ir_var, scope_entry)
+        {
+            if (var->is_uniform || var->is_input_semantic || var->is_output_semantic)
+                continue;
+            if (!var->regs[HLSL_REGSET_NUMERIC].allocated)
+                continue;
+
+            if (var->indexable)
+            {
+                unsigned int id = var->regs[HLSL_REGSET_NUMERIC].id;
+                unsigned int size = align(var->data_type->reg_size[HLSL_REGSET_NUMERIC], 4) / 4;
+
+                write_sm4_dcl_indexable_temp(&tpf, id, size, 4);
+            }
+        }
+    }
+
     write_sm4_block(&tpf, &entry_func->body);
 
     write_sm4_ret(&tpf);
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index f25dbb04d69..b60dc17e902 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -18,10 +18,13 @@
 
 #include "vkd3d_shader_private.h"
 #include "vkd3d_version.h"
+#include "hlsl.h"
 
 #include <stdio.h>
 #include <math.h>
 
+/* VKD3D_DEBUG_ENV_NAME("VKD3D_SHADER_DEBUG"); */
+
 static inline int char_to_int(char c)
 {
     if ('0' <= c && c <= '9')
@@ -379,7 +382,7 @@ void set_u32(struct vkd3d_bytecode_buffer *buffer, size_t offset, uint32_t value
     memcpy(buffer->data + offset, &value, sizeof(value));
 }
 
-static void vkd3d_shader_dump_blob(const char *path, const char *prefix,
+static void vkd3d_shader_dump_blob(const char *path, const char *profile,
         const char *suffix, const void *data, size_t size)
 {
     static LONG shader_id = 0;
@@ -389,7 +392,10 @@ static void vkd3d_shader_dump_blob(const char *path, const char *prefix,
 
     id = InterlockedIncrement(&shader_id) - 1;
 
-    snprintf(filename, ARRAY_SIZE(filename), "%s/vkd3d-shader-%s-%u.%s", path, prefix, id, suffix);
+    if (profile)
+        snprintf(filename, ARRAY_SIZE(filename), "%s/vkd3d-shader-%u-%s.%s", path, id, profile, suffix);
+    else
+        snprintf(filename, ARRAY_SIZE(filename), "%s/vkd3d-shader-%u.%s", path, id, suffix);
     if ((f = fopen(filename, "wb")))
     {
         if (fwrite(data, 1, size, f) != size)
@@ -421,9 +427,12 @@ static const char *shader_get_source_type_suffix(enum vkd3d_shader_source_type t
     }
 }
 
-void vkd3d_shader_dump_shader(enum vkd3d_shader_source_type source_type,
-        enum vkd3d_shader_type shader_type, const struct vkd3d_shader_code *shader)
+void vkd3d_shader_dump_shader(const struct vkd3d_shader_compile_info *compile_info)
 {
+    const struct vkd3d_shader_code *shader = &compile_info->source;
+    const struct vkd3d_shader_hlsl_source_info *hlsl_source_info;
+    const struct hlsl_profile_info *profile;
+    const char *profile_name = NULL;
     static bool enabled = true;
     const char *path;
 
@@ -436,8 +445,19 @@ void vkd3d_shader_dump_shader(enum vkd3d_shader_source_type source_type,
         return;
     }
 
-    vkd3d_shader_dump_blob(path, shader_get_type_prefix(shader_type),
-            shader_get_source_type_suffix(source_type), shader->code, shader->size);
+    if (compile_info->source_type == VKD3D_SHADER_SOURCE_HLSL)
+    {
+        if (!(hlsl_source_info = vkd3d_find_struct(compile_info->next, HLSL_SOURCE_INFO)))
+            return;
+
+        if (!(profile = hlsl_get_target_info(hlsl_source_info->profile)))
+            return;
+
+        profile_name = profile->name;
+    }
+
+    vkd3d_shader_dump_blob(path, profile_name, shader_get_source_type_suffix(compile_info->source_type),
+            shader->code, shader->size);
 }
 
 static void init_scan_signature_info(const struct vkd3d_shader_compile_info *info)
@@ -452,6 +472,25 @@ static void init_scan_signature_info(const struct vkd3d_shader_compile_info *inf
     }
 }
 
+static const struct vkd3d_debug_option vkd3d_shader_config_options[] =
+{
+    {"force_validation", VKD3D_SHADER_CONFIG_FLAG_FORCE_VALIDATION}, /* force validation of internal shader representations */
+};
+
+static uint64_t vkd3d_shader_init_config_flags(void)
+{
+    uint64_t config_flags;
+    const char *config;
+
+    config = getenv("VKD3D_SHADER_CONFIG");
+    config_flags = vkd3d_parse_debug_options(config, vkd3d_shader_config_options, ARRAY_SIZE(vkd3d_shader_config_options));
+
+    if (config_flags)
+        TRACE("VKD3D_SHADER_CONFIG='%s'.\n", config);
+
+    return config_flags;
+}
+
 bool vkd3d_shader_parser_init(struct vkd3d_shader_parser *parser,
         struct vkd3d_shader_message_context *message_context, const char *source_name,
         const struct vkd3d_shader_version *version, const struct vkd3d_shader_parser_ops *ops,
@@ -463,6 +502,7 @@ bool vkd3d_shader_parser_init(struct vkd3d_shader_parser *parser,
     parser->location.column = 0;
     parser->shader_version = *version;
     parser->ops = ops;
+    parser->config_flags = vkd3d_shader_init_config_flags();
     return shader_instruction_array_init(&parser->instructions, instruction_reserve);
 }
 
@@ -577,6 +617,8 @@ static bool vkd3d_shader_signature_from_shader_signature(struct vkd3d_shader_sig
 
 struct vkd3d_shader_scan_context
 {
+    const struct vkd3d_shader_version *version;
+
     struct vkd3d_shader_scan_descriptor_info1 *scan_descriptor_info;
     size_t descriptors_size;
 
@@ -598,21 +640,48 @@ struct vkd3d_shader_scan_context
     size_t cf_info_count;
 
     enum vkd3d_shader_api_version api_version;
+
+    struct vkd3d_shader_scan_combined_resource_sampler_info *combined_sampler_info;
+    size_t combined_samplers_size;
 };
 
+static VKD3D_PRINTF_FUNC(3, 4) void vkd3d_shader_scan_error(struct vkd3d_shader_scan_context *context,
+        enum vkd3d_shader_error error, const char *format, ...)
+{
+    va_list args;
+
+    va_start(args, format);
+    vkd3d_shader_verror(context->message_context, &context->location, error, format, args);
+    va_end(args);
+}
+
+static void VKD3D_PRINTF_FUNC(3, 4) vkd3d_shader_scan_warning(struct vkd3d_shader_scan_context *context,
+        enum vkd3d_shader_error error, const char *format, ...)
+{
+    va_list args;
+
+    va_start(args, format);
+    vkd3d_shader_vwarning(context->message_context, &context->location, error, format, args);
+    va_end(args);
+}
+
 static void vkd3d_shader_scan_context_init(struct vkd3d_shader_scan_context *context,
+        const struct vkd3d_shader_version *version,
         const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_scan_descriptor_info1 *scan_descriptor_info,
+        struct vkd3d_shader_scan_combined_resource_sampler_info *combined_sampler_info,
         struct vkd3d_shader_message_context *message_context)
 {
     unsigned int i;
 
     memset(context, 0, sizeof(*context));
+    context->version = version;
     context->scan_descriptor_info = scan_descriptor_info;
     context->message_context = message_context;
     context->location.source_name = compile_info->source_name;
     context->location.line = 2; /* Line 1 is the version token. */
     context->api_version = VKD3D_SHADER_API_VERSION_1_2;
+    context->combined_sampler_info = combined_sampler_info;
 
     for (i = 0; i < compile_info->option_count; ++i)
     {
@@ -762,6 +831,9 @@ static struct vkd3d_shader_descriptor_info1 *vkd3d_shader_scan_add_descriptor(st
     struct vkd3d_shader_scan_descriptor_info1 *info = context->scan_descriptor_info;
     struct vkd3d_shader_descriptor_info1 *d;
 
+    if (!info)
+        return NULL;
+
     if (!vkd3d_array_reserve((void **)&info->descriptors, &context->descriptors_size,
             info->descriptor_count + 1, sizeof(*info->descriptors)))
     {
@@ -789,13 +861,10 @@ static void vkd3d_shader_scan_constant_buffer_declaration(struct vkd3d_shader_sc
     const struct vkd3d_shader_constant_buffer *cb = &instruction->declaration.cb;
     struct vkd3d_shader_descriptor_info1 *d;
 
-    if (!context->scan_descriptor_info)
-        return;
-
     if (!(d = vkd3d_shader_scan_add_descriptor(context, VKD3D_SHADER_DESCRIPTOR_TYPE_CBV,
             &cb->src.reg, &cb->range, VKD3D_SHADER_RESOURCE_BUFFER, VKD3D_SHADER_RESOURCE_DATA_UINT)))
         return;
-    d->buffer_size = cb->size * 16;
+    d->buffer_size = cb->size;
 }
 
 static void vkd3d_shader_scan_sampler_declaration(struct vkd3d_shader_scan_context *context,
@@ -804,9 +873,6 @@ static void vkd3d_shader_scan_sampler_declaration(struct vkd3d_shader_scan_conte
     const struct vkd3d_shader_sampler *sampler = &instruction->declaration.sampler;
     struct vkd3d_shader_descriptor_info1 *d;
 
-    if (!context->scan_descriptor_info)
-        return;
-
     if (!(d = vkd3d_shader_scan_add_descriptor(context, VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER,
             &sampler->src.reg, &sampler->range, VKD3D_SHADER_RESOURCE_NONE, VKD3D_SHADER_RESOURCE_DATA_UINT)))
         return;
@@ -815,6 +881,103 @@ static void vkd3d_shader_scan_sampler_declaration(struct vkd3d_shader_scan_conte
         d->flags |= VKD3D_SHADER_DESCRIPTOR_INFO_FLAG_SAMPLER_COMPARISON_MODE;
 }
 
+static void vkd3d_shader_scan_combined_sampler_declaration(
+        struct vkd3d_shader_scan_context *context, const struct vkd3d_shader_semantic *semantic)
+{
+    vkd3d_shader_scan_add_descriptor(context, VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER, &semantic->resource.reg.reg,
+            &semantic->resource.range, VKD3D_SHADER_RESOURCE_NONE, VKD3D_SHADER_RESOURCE_DATA_UINT);
+    vkd3d_shader_scan_add_descriptor(context, VKD3D_SHADER_DESCRIPTOR_TYPE_SRV, &semantic->resource.reg.reg,
+            &semantic->resource.range, semantic->resource_type, VKD3D_SHADER_RESOURCE_DATA_FLOAT);
+}
+
+static void vkd3d_shader_scan_combined_sampler_usage(struct vkd3d_shader_scan_context *context,
+        const struct vkd3d_shader_register *resource, const struct vkd3d_shader_register *sampler)
+{
+    struct vkd3d_shader_scan_combined_resource_sampler_info *info;
+    struct vkd3d_shader_combined_resource_sampler_info *s;
+    unsigned resource_space = 0, sampler_space = 0;
+    unsigned int resource_idx, sampler_idx, i;
+
+    if (!(info = context->combined_sampler_info))
+        return;
+
+    if (resource->type == VKD3DSPR_RESOURCE)
+        resource_idx = resource->idx[1].offset;
+    else
+        resource_idx = resource->idx[0].offset;
+
+    if (!sampler)
+        sampler_idx = VKD3D_SHADER_DUMMY_SAMPLER_INDEX;
+    else if (sampler->type == VKD3DSPR_SAMPLER)
+        sampler_idx = sampler->idx[1].offset;
+    else
+        sampler_idx = sampler->idx[0].offset;
+
+    if (vkd3d_shader_ver_ge(context->version, 5, 1))
+    {
+        const struct vkd3d_shader_scan_descriptor_info1 *info = context->scan_descriptor_info;
+        const struct vkd3d_shader_descriptor_info1 *d;
+        bool dynamic_resource, dynamic_sampler;
+
+        if ((dynamic_resource = resource->idx[1].rel_addr))
+            vkd3d_shader_scan_warning(context, VKD3D_SHADER_WARNING_VSIR_DYNAMIC_DESCRIPTOR_ARRAY,
+                    "Resource descriptor array %u is being dynamically indexed, "
+                    "not recording a combined resource-sampler pair.", resource->idx[0].offset);
+        if ((dynamic_sampler = sampler && sampler->idx[1].rel_addr))
+            vkd3d_shader_scan_warning(context, VKD3D_SHADER_WARNING_VSIR_DYNAMIC_DESCRIPTOR_ARRAY,
+                    "Sampler descriptor array %u is being dynamically indexed, "
+                    "not recording a combined resource-sampler pair.", sampler->idx[0].offset);
+        if (dynamic_resource || dynamic_sampler)
+            return;
+
+        for (i = 0; i < info->descriptor_count; ++i)
+        {
+            d = &info->descriptors[i];
+            if (d->type != VKD3D_SHADER_DESCRIPTOR_TYPE_SRV)
+                continue;
+            if (d->register_id != resource->idx[0].offset)
+                continue;
+            resource_space = d->register_space;
+            break;
+        }
+
+        if (sampler)
+        {
+            for (i = 0; i < info->descriptor_count; ++i)
+            {
+                d = &info->descriptors[i];
+                if (d->type != VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER)
+                    continue;
+                if (d->register_id != sampler->idx[0].offset)
+                    continue;
+                sampler_space = d->register_space;
+                break;
+            }
+        }
+    }
+
+    for (i = 0; i < info->combined_sampler_count; ++i)
+    {
+        s = &info->combined_samplers[i];
+        if (s->resource_space == resource_space && s->resource_index == resource_idx
+                && s->sampler_space == sampler_space && s->sampler_index == sampler_idx)
+            return;
+    }
+
+    if (!vkd3d_array_reserve((void **)&info->combined_samplers, &context->combined_samplers_size,
+            info->combined_sampler_count + 1, sizeof(*info->combined_samplers)))
+    {
+        ERR("Failed to allocate combined sampler info.\n");
+        return;
+    }
+
+    s = &info->combined_samplers[info->combined_sampler_count++];
+    s->resource_space = resource_space;
+    s->resource_index = resource_idx;
+    s->sampler_space = sampler_space;
+    s->sampler_index = sampler_idx;
+}
+
 static void vkd3d_shader_scan_resource_declaration(struct vkd3d_shader_scan_context *context,
         const struct vkd3d_shader_resource *resource, enum vkd3d_shader_resource_type resource_type,
         enum vkd3d_shader_resource_data_type resource_data_type,
@@ -823,9 +986,6 @@ static void vkd3d_shader_scan_resource_declaration(struct vkd3d_shader_scan_cont
     struct vkd3d_shader_descriptor_info1 *d;
     enum vkd3d_shader_descriptor_type type;
 
-    if (!context->scan_descriptor_info)
-        return;
-
     if (resource->reg.reg.type == VKD3DSPR_UAV)
         type = VKD3D_SHADER_DESCRIPTOR_TYPE_UAV;
     else
@@ -898,22 +1058,15 @@ static void vkd3d_shader_scan_typed_resource_declaration(struct vkd3d_shader_sca
             semantic->resource_type, resource_data_type, semantic->sample_count, 0, false);
 }
 
-static void vkd3d_shader_scan_error(struct vkd3d_shader_scan_context *context,
-        enum vkd3d_shader_error error, const char *format, ...)
-{
-    va_list args;
-
-    va_start(args, format);
-    vkd3d_shader_verror(context->message_context, &context->location, error, format, args);
-    va_end(args);
-}
-
 static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *context,
         const struct vkd3d_shader_instruction *instruction)
 {
+    const struct vkd3d_shader_register *sampler_reg;
     struct vkd3d_shader_cf_info *cf_info;
     unsigned int i;
 
+    context->location = instruction->location;
+
     switch (instruction->handler_idx)
     {
         case VKD3DSIH_DCL_CONSTANT_BUFFER:
@@ -923,6 +1076,12 @@ static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *conte
             vkd3d_shader_scan_sampler_declaration(context, instruction);
             break;
         case VKD3DSIH_DCL:
+            if (instruction->declaration.semantic.resource.reg.reg.type == VKD3DSPR_COMBINED_SAMPLER)
+            {
+                vkd3d_shader_scan_combined_sampler_declaration(context, &instruction->declaration.semantic);
+                break;
+            }
+            /* fall through */
         case VKD3DSIH_DCL_UAV_TYPED:
             vkd3d_shader_scan_typed_resource_declaration(context, instruction);
             break;
@@ -1053,6 +1212,58 @@ static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *conte
             if (context->cf_info_count)
                 context->cf_info[context->cf_info_count - 1].inside_block = false;
             break;
+        case VKD3DSIH_TEX:
+            if (context->version->major == 1)
+                sampler_reg = &instruction->dst[0].reg;
+            else
+                sampler_reg = &instruction->src[1].reg;
+            vkd3d_shader_scan_combined_sampler_usage(context, sampler_reg, sampler_reg);
+            break;
+        case VKD3DSIH_TEXBEM:
+        case VKD3DSIH_TEXBEML:
+        case VKD3DSIH_TEXDP3TEX:
+        case VKD3DSIH_TEXM3x2TEX:
+        case VKD3DSIH_TEXM3x3SPEC:
+        case VKD3DSIH_TEXM3x3TEX:
+        case VKD3DSIH_TEXM3x3VSPEC:
+        case VKD3DSIH_TEXREG2AR:
+        case VKD3DSIH_TEXREG2GB:
+        case VKD3DSIH_TEXREG2RGB:
+            sampler_reg = &instruction->dst[0].reg;
+            vkd3d_shader_scan_combined_sampler_usage(context, sampler_reg, sampler_reg);
+            break;
+        case VKD3DSIH_GATHER4:
+        case VKD3DSIH_GATHER4_C:
+        case VKD3DSIH_SAMPLE:
+        case VKD3DSIH_SAMPLE_B:
+        case VKD3DSIH_SAMPLE_C:
+        case VKD3DSIH_SAMPLE_C_LZ:
+        case VKD3DSIH_SAMPLE_GRAD:
+        case VKD3DSIH_SAMPLE_LOD:
+            vkd3d_shader_scan_combined_sampler_usage(context, &instruction->src[1].reg, &instruction->src[2].reg);
+            break;
+        case VKD3DSIH_GATHER4_PO:
+        case VKD3DSIH_GATHER4_PO_C:
+            vkd3d_shader_scan_combined_sampler_usage(context, &instruction->src[2].reg, &instruction->src[3].reg);
+            break;
+        case VKD3DSIH_LD:
+        case VKD3DSIH_LD2DMS:
+            vkd3d_shader_scan_combined_sampler_usage(context, &instruction->src[1].reg, NULL);
+            break;
+        case VKD3DSIH_BUFINFO:
+        case VKD3DSIH_SAMPLE_INFO:
+            if (instruction->src[0].reg.type == VKD3DSPR_RESOURCE)
+                vkd3d_shader_scan_combined_sampler_usage(context, &instruction->src[0].reg, NULL);
+            break;
+        case VKD3DSIH_LD_RAW:
+        case VKD3DSIH_RESINFO:
+            if (instruction->src[1].reg.type == VKD3DSPR_RESOURCE)
+                vkd3d_shader_scan_combined_sampler_usage(context, &instruction->src[1].reg, NULL);
+            break;
+        case VKD3DSIH_LD_STRUCTURED:
+            if (instruction->src[2].reg.type == VKD3DSPR_RESOURCE)
+                vkd3d_shader_scan_combined_sampler_usage(context, &instruction->src[2].reg, NULL);
+            break;
         default:
             break;
     }
@@ -1083,7 +1294,6 @@ static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *conte
         }
     }
 
-    ++context->location.line;
     return VKD3D_OK;
 }
 
@@ -1124,6 +1334,7 @@ static int scan_with_parser(const struct vkd3d_shader_compile_info *compile_info
         struct vkd3d_shader_message_context *message_context,
         struct vkd3d_shader_scan_descriptor_info1 *descriptor_info1, struct vkd3d_shader_parser *parser)
 {
+    struct vkd3d_shader_scan_combined_resource_sampler_info *combined_sampler_info;
     struct vkd3d_shader_scan_descriptor_info1 local_descriptor_info1 = {0};
     struct vkd3d_shader_scan_descriptor_info *descriptor_info;
     struct vkd3d_shader_scan_signature_info *signature_info;
@@ -1144,7 +1355,16 @@ static int scan_with_parser(const struct vkd3d_shader_compile_info *compile_info
     }
     signature_info = vkd3d_find_struct(compile_info->next, SCAN_SIGNATURE_INFO);
 
-    vkd3d_shader_scan_context_init(&context, compile_info, descriptor_info1, message_context);
+    if ((combined_sampler_info = vkd3d_find_struct(compile_info->next, SCAN_COMBINED_RESOURCE_SAMPLER_INFO)))
+    {
+        combined_sampler_info->combined_samplers = NULL;
+        combined_sampler_info->combined_sampler_count = 0;
+        if (!descriptor_info1)
+            descriptor_info1 = &local_descriptor_info1;
+    }
+
+    vkd3d_shader_scan_context_init(&context, &parser->shader_version, compile_info,
+            descriptor_info1, combined_sampler_info, message_context);
 
     if (TRACE_ON())
     {
@@ -1190,6 +1410,8 @@ static int scan_with_parser(const struct vkd3d_shader_compile_info *compile_info
 
     if (ret < 0)
     {
+        if (combined_sampler_info)
+            vkd3d_shader_free_scan_combined_resource_sampler_info(combined_sampler_info);
         if (descriptor_info)
             vkd3d_shader_free_scan_descriptor_info(descriptor_info);
         if (descriptor_info1)
@@ -1276,6 +1498,8 @@ int vkd3d_shader_scan(const struct vkd3d_shader_compile_info *compile_info, char
 
     vkd3d_shader_message_context_init(&message_context, compile_info->log_level);
 
+    vkd3d_shader_dump_shader(compile_info);
+
     switch (compile_info->source_type)
     {
         case VKD3D_SHADER_SOURCE_DXBC_TPF:
@@ -1317,8 +1541,6 @@ static int vkd3d_shader_parser_compile(struct vkd3d_shader_parser *parser,
     struct vkd3d_shader_compile_info scan_info;
     int ret;
 
-    vkd3d_shader_dump_shader(compile_info->source_type, parser->shader_version.type, &compile_info->source);
-
     scan_info = *compile_info;
 
     if ((ret = scan_with_parser(&scan_info, message_context, &scan_descriptor_info, parser)) < 0)
@@ -1402,8 +1624,6 @@ static int compile_d3d_bytecode(const struct vkd3d_shader_compile_info *compile_
         return ret;
     }
 
-    vkd3d_shader_dump_shader(compile_info->source_type, parser->shader_version.type, &compile_info->source);
-
     if (compile_info->target_type == VKD3D_SHADER_TARGET_D3D_ASM)
     {
         ret = vkd3d_dxbc_binary_to_text(&parser->instructions, &parser->shader_version, compile_info, out);
@@ -1450,6 +1670,8 @@ int vkd3d_shader_compile(const struct vkd3d_shader_compile_info *compile_info,
 
     vkd3d_shader_message_context_init(&message_context, compile_info->log_level);
 
+    vkd3d_shader_dump_shader(compile_info);
+
     switch (compile_info->source_type)
     {
         case VKD3D_SHADER_SOURCE_DXBC_TPF:
@@ -1479,6 +1701,14 @@ int vkd3d_shader_compile(const struct vkd3d_shader_compile_info *compile_info,
     return ret;
 }
 
+void vkd3d_shader_free_scan_combined_resource_sampler_info(
+        struct vkd3d_shader_scan_combined_resource_sampler_info *info)
+{
+    TRACE("info %p.\n", info);
+
+    vkd3d_free(info->combined_samplers);
+}
+
 void vkd3d_shader_free_scan_descriptor_info(struct vkd3d_shader_scan_descriptor_info *scan_descriptor_info)
 {
     TRACE("scan_descriptor_info %p.\n", scan_descriptor_info);
@@ -1751,7 +1981,7 @@ static struct vkd3d_shader_param_node *shader_param_allocator_node_create(
 static void shader_param_allocator_init(struct vkd3d_shader_param_allocator *allocator,
         unsigned int count, unsigned int stride)
 {
-    allocator->count = max(count, 4);
+    allocator->count = max(count, MAX_REG_OUTPUT);
     allocator->stride = stride;
     allocator->head = NULL;
     allocator->current = NULL;
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index 9443df6c232..d3989672b89 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -49,7 +49,7 @@
 #include "vkd3d_common.h"
 #include "vkd3d_memory.h"
 #include "vkd3d_shader.h"
-#include "wine/list.h"
+#include "list.h"
 
 #include <assert.h>
 #include <inttypes.h>
@@ -92,6 +92,10 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_SPV_INVALID_DESCRIPTOR_BINDING   = 2002,
     VKD3D_SHADER_ERROR_SPV_DESCRIPTOR_IDX_UNSUPPORTED   = 2003,
     VKD3D_SHADER_ERROR_SPV_STENCIL_EXPORT_UNSUPPORTED   = 2004,
+    VKD3D_SHADER_ERROR_SPV_OUT_OF_MEMORY                = 2005,
+    VKD3D_SHADER_ERROR_SPV_INVALID_TYPE                 = 2006,
+    VKD3D_SHADER_ERROR_SPV_INVALID_HANDLER              = 2007,
+    VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED              = 2008,
 
     VKD3D_SHADER_WARNING_SPV_INVALID_SWIZZLE            = 2300,
 
@@ -141,6 +145,7 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_HLSL_RECURSIVE_CALL              = 5025,
     VKD3D_SHADER_ERROR_HLSL_INCONSISTENT_SAMPLER        = 5026,
     VKD3D_SHADER_ERROR_HLSL_NON_FINITE_RESULT           = 5027,
+    VKD3D_SHADER_ERROR_HLSL_DUPLICATE_SWITCH_CASE       = 5028,
 
     VKD3D_SHADER_WARNING_HLSL_IMPLICIT_TRUNCATION       = 5300,
     VKD3D_SHADER_WARNING_HLSL_DIVISION_BY_ZERO          = 5301,
@@ -174,15 +179,43 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_DXIL_INVALID_TYPE_ID             = 8010,
     VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE              = 8011,
     VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND             = 8012,
+    VKD3D_SHADER_ERROR_DXIL_UNHANDLED_INTRINSIC         = 8013,
+    VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA            = 8014,
+    VKD3D_SHADER_ERROR_DXIL_INVALID_ENTRY_POINT         = 8015,
+    VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE           = 8016,
+    VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES          = 8017,
+    VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES           = 8018,
+    VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCE_HANDLE     = 8019,
 
     VKD3D_SHADER_WARNING_DXIL_UNKNOWN_MAGIC_NUMBER      = 8300,
     VKD3D_SHADER_WARNING_DXIL_UNKNOWN_SHADER_TYPE       = 8301,
     VKD3D_SHADER_WARNING_DXIL_INVALID_BLOCK_LENGTH      = 8302,
     VKD3D_SHADER_WARNING_DXIL_INVALID_MODULE_LENGTH     = 8303,
     VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS         = 8304,
-    VKD3D_SHADER_WARNING_DXIL_UNHANDLED_INTRINSIC       = 8305,
+    VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH             = 8305,
+    VKD3D_SHADER_WARNING_DXIL_ENTRY_POINT_MISMATCH      = 8306,
+    VKD3D_SHADER_WARNING_DXIL_INVALID_MASK              = 8307,
+    VKD3D_SHADER_WARNING_DXIL_INVALID_OPERATION         = 8308,
 
     VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED             = 9000,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_HANDLER             = 9001,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE       = 9002,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK          = 9003,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_MODIFIERS           = 9004,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_SHIFT               = 9005,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_SWIZZLE             = 9006,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_PRECISION           = 9007,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE           = 9008,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION           = 9009,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT         = 9010,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_DEST_COUNT          = 9011,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_SOURCE_COUNT        = 9012,
+    VKD3D_SHADER_ERROR_VSIR_DUPLICATE_DCL_TEMPS         = 9013,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_DCL_TEMPS           = 9014,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX               = 9015,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING = 9016,
+
+    VKD3D_SHADER_WARNING_VSIR_DYNAMIC_DESCRIPTOR_ARRAY  = 9300,
 };
 
 enum vkd3d_shader_opcode
@@ -264,9 +297,9 @@ enum vkd3d_shader_opcode
     VKD3DSIH_DEFAULT,
     VKD3DSIH_DEFB,
     VKD3DSIH_DEFI,
-    VKD3DSIH_DEQ,
+    VKD3DSIH_DEQO,
     VKD3DSIH_DFMA,
-    VKD3DSIH_DGE,
+    VKD3DSIH_DGEO,
     VKD3DSIH_DISCARD,
     VKD3DSIH_DIV,
     VKD3DSIH_DLT,
@@ -298,7 +331,8 @@ enum vkd3d_shader_opcode
     VKD3DSIH_ENDLOOP,
     VKD3DSIH_ENDREP,
     VKD3DSIH_ENDSWITCH,
-    VKD3DSIH_EQ,
+    VKD3DSIH_EQO,
+    VKD3DSIH_EQU,
     VKD3DSIH_EVAL_CENTROID,
     VKD3DSIH_EVAL_SAMPLE_INDEX,
     VKD3DSIH_EXP,
@@ -310,6 +344,7 @@ enum vkd3d_shader_opcode
     VKD3DSIH_FIRSTBIT_LO,
     VKD3DSIH_FIRSTBIT_SHI,
     VKD3DSIH_FRC,
+    VKD3DSIH_FREM,
     VKD3DSIH_FTOD,
     VKD3DSIH_FTOI,
     VKD3DSIH_FTOU,
@@ -321,13 +356,15 @@ enum vkd3d_shader_opcode
     VKD3DSIH_GATHER4_PO_C_S,
     VKD3DSIH_GATHER4_PO_S,
     VKD3DSIH_GATHER4_S,
-    VKD3DSIH_GE,
+    VKD3DSIH_GEO,
+    VKD3DSIH_GEU,
     VKD3DSIH_HS_CONTROL_POINT_PHASE,
     VKD3DSIH_HS_DECLS,
     VKD3DSIH_HS_FORK_PHASE,
     VKD3DSIH_HS_JOIN_PHASE,
     VKD3DSIH_IADD,
     VKD3DSIH_IBFE,
+    VKD3DSIH_IDIV,
     VKD3DSIH_IEQ,
     VKD3DSIH_IF,
     VKD3DSIH_IFC,
@@ -355,6 +392,7 @@ enum vkd3d_shader_opcode
     VKD3DSIH_ISHR,
     VKD3DSIH_ITOD,
     VKD3DSIH_ITOF,
+    VKD3DSIH_ITOI,
     VKD3DSIH_LABEL,
     VKD3DSIH_LD,
     VKD3DSIH_LD2DMS,
@@ -372,7 +410,8 @@ enum vkd3d_shader_opcode
     VKD3DSIH_LOGP,
     VKD3DSIH_LOOP,
     VKD3DSIH_LRP,
-    VKD3DSIH_LT,
+    VKD3DSIH_LTO,
+    VKD3DSIH_LTU,
     VKD3DSIH_M3x2,
     VKD3DSIH_M3x3,
     VKD3DSIH_M3x4,
@@ -386,7 +425,8 @@ enum vkd3d_shader_opcode
     VKD3DSIH_MOVC,
     VKD3DSIH_MSAD,
     VKD3DSIH_MUL,
-    VKD3DSIH_NE,
+    VKD3DSIH_NEO,
+    VKD3DSIH_NEU,
     VKD3DSIH_NOP,
     VKD3DSIH_NOT,
     VKD3DSIH_NRM,
@@ -462,6 +502,7 @@ enum vkd3d_shader_opcode
     VKD3DSIH_USHR,
     VKD3DSIH_UTOD,
     VKD3DSIH_UTOF,
+    VKD3DSIH_UTOU,
     VKD3DSIH_XOR,
 
     VKD3DSIH_INVALID,
@@ -481,7 +522,7 @@ enum vkd3d_shader_register_type
     VKD3DSPR_CONSTINT = 7,
     VKD3DSPR_COLOROUT = 8,
     VKD3DSPR_DEPTHOUT = 9,
-    VKD3DSPR_SAMPLER = 10,
+    VKD3DSPR_COMBINED_SAMPLER = 10,
     VKD3DSPR_CONST2 = 11,
     VKD3DSPR_CONST3 = 12,
     VKD3DSPR_CONST4 = 13,
@@ -497,6 +538,7 @@ enum vkd3d_shader_register_type
     VKD3DSPR_IMMCONSTBUFFER,
     VKD3DSPR_PRIMID,
     VKD3DSPR_NULL,
+    VKD3DSPR_SAMPLER,
     VKD3DSPR_RESOURCE,
     VKD3DSPR_UAV,
     VKD3DSPR_OUTPOINTID,
@@ -523,6 +565,7 @@ enum vkd3d_shader_register_type
     VKD3DSPR_RASTERIZER,
     VKD3DSPR_OUTSTENCILREF,
     VKD3DSPR_UNDEF,
+    VKD3DSPR_SSA,
 
     VKD3DSPR_COUNT,
 
@@ -537,6 +580,8 @@ enum vkd3d_shader_register_precision
     VKD3D_SHADER_REGISTER_PRECISION_MIN_INT_16,
     VKD3D_SHADER_REGISTER_PRECISION_MIN_UINT_16,
 
+    VKD3D_SHADER_REGISTER_PRECISION_COUNT,
+
     VKD3D_SHADER_REGISTER_PRECISION_INVALID = ~0u,
 };
 
@@ -556,17 +601,30 @@ enum vkd3d_data_type
     VKD3D_DATA_CONTINUED,
     VKD3D_DATA_UNUSED,
     VKD3D_DATA_UINT8,
+    VKD3D_DATA_UINT64,
+    VKD3D_DATA_BOOL,
+
+    VKD3D_DATA_COUNT,
 };
 
 static inline bool data_type_is_integer(enum vkd3d_data_type data_type)
 {
-    return data_type == VKD3D_DATA_INT || data_type == VKD3D_DATA_UINT8 || data_type == VKD3D_DATA_UINT;
+    return data_type == VKD3D_DATA_INT || data_type == VKD3D_DATA_UINT8 || data_type == VKD3D_DATA_UINT
+            || data_type == VKD3D_DATA_UINT64;
 }
 
-enum vkd3d_immconst_type
+static inline bool data_type_is_bool(enum vkd3d_data_type data_type)
 {
-    VKD3D_IMMCONST_SCALAR,
-    VKD3D_IMMCONST_VEC4,
+    return data_type == VKD3D_DATA_BOOL;
+}
+
+enum vsir_dimension
+{
+    VSIR_DIMENSION_NONE,
+    VSIR_DIMENSION_SCALAR,
+    VSIR_DIMENSION_VEC4,
+
+    VSIR_DIMENSION_COUNT,
 };
 
 enum vkd3d_shader_src_modifier
@@ -585,6 +643,7 @@ enum vkd3d_shader_src_modifier
     VKD3DSPSM_ABS = 11,
     VKD3DSPSM_ABSNEG = 12,
     VKD3DSPSM_NOT = 13,
+    VKD3DSPSM_COUNT,
 };
 
 #define VKD3DSP_WRITEMASK_0   0x1u /* .x r */
@@ -599,6 +658,7 @@ enum vkd3d_shader_dst_modifier
     VKD3DSPDM_SATURATE = 1,
     VKD3DSPDM_PARTIALPRECISION = 2,
     VKD3DSPDM_MSAMPCENTROID = 4,
+    VKD3DSPDM_MASK = 7,
 };
 
 enum vkd3d_shader_interpolation_mode
@@ -611,6 +671,8 @@ enum vkd3d_shader_interpolation_mode
     VKD3DSIM_LINEAR_NOPERSPECTIVE_CENTROID = 5,
     VKD3DSIM_LINEAR_SAMPLE = 6,
     VKD3DSIM_LINEAR_NOPERSPECTIVE_SAMPLE = 7,
+
+    VKD3DSIM_COUNT = 8,
 };
 
 enum vkd3d_shader_global_flags
@@ -622,6 +684,32 @@ enum vkd3d_shader_global_flags
     VKD3DSGF_SKIP_OPTIMIZATION                 = 0x10,
     VKD3DSGF_ENABLE_MINIMUM_PRECISION          = 0x20,
     VKD3DSGF_ENABLE_11_1_DOUBLE_EXTENSIONS     = 0x40,
+    VKD3DSGF_ENABLE_SHADER_EXTENSIONS          = 0x80, /* never emitted? */
+    VKD3DSGF_BIND_FOR_DURATION                 =     0x100,
+    VKD3DSGF_ENABLE_VP_AND_RT_ARRAY_INDEX      =     0x200,
+    VKD3DSGF_ENABLE_INNER_COVERAGE             =     0x400,
+    VKD3DSGF_ENABLE_STENCIL_REF                =     0x800,
+    VKD3DSGF_ENABLE_TILED_RESOURCE_INTRINSICS  =    0x1000,
+    VKD3DSGF_ENABLE_RELAXED_TYPED_UAV_FORMATS  =    0x2000,
+    VKD3DSGF_ENABLE_LVL_9_COMPARISON_FILTERING =    0x4000,
+    VKD3DSGF_ENABLE_UP_TO_64_UAVS              =    0x8000,
+    VKD3DSGF_ENABLE_UAVS_AT_EVERY_STAGE        =   0x10000,
+    VKD3DSGF_ENABLE_CS4_RAW_STRUCTURED_BUFFERS =   0x20000,
+    VKD3DSGF_ENABLE_RASTERIZER_ORDERED_VIEWS   =   0x40000,
+    VKD3DSGF_ENABLE_WAVE_INTRINSICS            =   0x80000,
+    VKD3DSGF_ENABLE_INT64                      =  0x100000,
+    VKD3DSGF_ENABLE_VIEWID                     =  0x200000,
+    VKD3DSGF_ENABLE_BARYCENTRICS               =  0x400000,
+    VKD3DSGF_FORCE_NATIVE_LOW_PRECISION        =  0x800000,
+    VKD3DSGF_ENABLE_SHADINGRATE                = 0x1000000,
+    VKD3DSGF_ENABLE_RAYTRACING_TIER_1_1        = 0x2000000,
+    VKD3DSGF_ENABLE_SAMPLER_FEEDBACK           = 0x4000000,
+    VKD3DSGF_ENABLE_ATOMIC_INT64_ON_TYPED_RESOURCE                =   0x8000000,
+    VKD3DSGF_ENABLE_ATOMIC_INT64_ON_GROUP_SHARED                  =  0x10000000,
+    VKD3DSGF_ENABLE_DERIVATIVES_IN_MESH_AND_AMPLIFICATION_SHADERS =  0x20000000,
+    VKD3DSGF_ENABLE_RESOURCE_DESCRIPTOR_HEAP_INDEXING             =  0x40000000,
+    VKD3DSGF_ENABLE_SAMPLER_DESCRIPTOR_HEAP_INDEXING              =  0x80000000,
+    VKD3DSGF_ENABLE_ATOMIC_INT64_ON_DESCRIPTOR_HEAP_RESOURCE      = 0x100000000ull,
 };
 
 enum vkd3d_shader_sync_flags
@@ -633,7 +721,8 @@ enum vkd3d_shader_sync_flags
 
 enum vkd3d_shader_uav_flags
 {
-    VKD3DSUF_GLOBALLY_COHERENT = 0x2,
+    VKD3DSUF_GLOBALLY_COHERENT        = 0x002,
+    VKD3DSUF_RASTERISER_ORDERED_VIEW  = 0x004,
     VKD3DSUF_ORDER_PRESERVING_COUNTER = 0x100,
 };
 
@@ -704,22 +793,29 @@ struct vkd3d_shader_version
 
 struct vkd3d_shader_immediate_constant_buffer
 {
-    unsigned int vec4_count;
+    enum vkd3d_data_type data_type;
+    /* total count is element_count * component_count */
+    unsigned int element_count;
+    unsigned int component_count;
     uint32_t data[];
 };
 
 struct vkd3d_shader_indexable_temp
 {
-    struct list entry;
     unsigned int register_idx;
     unsigned int register_size;
+    unsigned int alignment;
+    enum vkd3d_data_type data_type;
     unsigned int component_count;
+    const struct vkd3d_shader_immediate_constant_buffer *initialiser;
 };
 
 struct vkd3d_shader_register_index
 {
     const struct vkd3d_shader_src_param *rel_addr;
     unsigned int offset;
+    /* address is known to fall within the object (for optimisation) */
+    bool is_in_bounds;
 };
 
 struct vkd3d_shader_register
@@ -730,7 +826,9 @@ struct vkd3d_shader_register
     enum vkd3d_data_type data_type;
     struct vkd3d_shader_register_index idx[3];
     unsigned int idx_count;
-    enum vkd3d_immconst_type immconst_type;
+    enum vsir_dimension dimension;
+    /* known address alignment for optimisation, or zero */
+    unsigned int alignment;
     union
     {
         DWORD immconst_uint[VKD3D_VEC4_SIZE];
@@ -741,13 +839,28 @@ struct vkd3d_shader_register
     } u;
 };
 
-void shader_register_init(struct vkd3d_shader_register *reg, enum vkd3d_shader_register_type reg_type,
+void vsir_register_init(struct vkd3d_shader_register *reg, enum vkd3d_shader_register_type reg_type,
         enum vkd3d_data_type data_type, unsigned int idx_count);
 
+static inline bool vsir_register_is_descriptor(const struct vkd3d_shader_register *reg)
+{
+    switch (reg->type)
+    {
+        case VKD3DSPR_SAMPLER:
+        case VKD3DSPR_RESOURCE:
+        case VKD3DSPR_CONSTBUFFER:
+        case VKD3DSPR_UAV:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
 struct vkd3d_shader_dst_param
 {
     struct vkd3d_shader_register reg;
-    DWORD write_mask;
+    uint32_t write_mask;
     DWORD modifiers;
     DWORD shift;
 };
@@ -848,6 +961,7 @@ struct signature_element
     unsigned int mask;
     unsigned int used_mask;
     enum vkd3d_shader_minimum_precision min_precision;
+    enum vkd3d_shader_interpolation_mode interpolation_mode;
     /* Register index / location in the target shader.
      * If SIGNATURE_TARGET_LOCATION_UNUSED, this element should not be written. */
     unsigned int target_location;
@@ -860,6 +974,14 @@ struct shader_signature
     unsigned int element_count;
 };
 
+static inline bool vsir_sysval_semantic_is_tess_factor(enum vkd3d_shader_sysval_semantic sysval_semantic)
+{
+    return sysval_semantic >= VKD3D_SHADER_SV_TESS_FACTOR_QUADEDGE
+        && sysval_semantic <= VKD3D_SHADER_SV_TESS_FACTOR_LINEDEN;
+}
+
+struct signature_element *vsir_signature_find_element_for_reg(const struct shader_signature *signature,
+        unsigned int reg_idx, unsigned int write_mask);
 void shader_signature_cleanup(struct shader_signature *signature);
 
 struct vkd3d_shader_desc
@@ -871,12 +993,17 @@ struct vkd3d_shader_desc
     struct shader_signature output_signature;
     struct shader_signature patch_constant_signature;
 
+    unsigned int input_control_point_count, output_control_point_count;
+
     uint32_t temp_count;
+    unsigned int ssa_count;
 
     struct
     {
         uint32_t used, external;
     } flat_constant_count[3];
+
+    bool use_vocp;
 };
 
 struct vkd3d_shader_register_semantic
@@ -968,8 +1095,15 @@ struct vkd3d_shader_primitive_type
     unsigned int patch_vertex_count;
 };
 
+struct vkd3d_shader_location
+{
+    const char *source_name;
+    unsigned int line, column;
+};
+
 struct vkd3d_shader_instruction
 {
+    struct vkd3d_shader_location location;
     enum vkd3d_shader_opcode handler_idx;
     DWORD flags;
     unsigned int dst_count;
@@ -984,6 +1118,7 @@ struct vkd3d_shader_instruction
     const struct vkd3d_shader_src_param *predicate;
     union
     {
+        enum vkd3d_shader_global_flags global_flags;
         struct vkd3d_shader_semantic semantic;
         struct vkd3d_shader_register_semantic register_semantic;
         struct vkd3d_shader_primitive_type primitive_type;
@@ -1008,26 +1143,22 @@ struct vkd3d_shader_instruction
     } declaration;
 };
 
-void shader_instruction_init(struct vkd3d_shader_instruction *ins, enum vkd3d_shader_opcode handler_idx);
-
-static inline bool vkd3d_shader_instruction_has_texel_offset(const struct vkd3d_shader_instruction *ins)
+static inline bool vkd3d_shader_ver_ge(const struct vkd3d_shader_version *v, unsigned int major, unsigned int minor)
 {
-    return ins->texel_offset.u || ins->texel_offset.v || ins->texel_offset.w;
+    return v->major > major || (v->major == major && v->minor >= minor);
 }
 
-static inline bool vkd3d_shader_register_is_input(const struct vkd3d_shader_register *reg)
+static inline bool vkd3d_shader_ver_le(const struct vkd3d_shader_version *v, unsigned int major, unsigned int minor)
 {
-    return reg->type == VKD3DSPR_INPUT || reg->type == VKD3DSPR_INCONTROLPOINT || reg->type == VKD3DSPR_OUTCONTROLPOINT;
+    return v->major < major || (v->major == major && v->minor <= minor);
 }
 
-static inline bool vkd3d_shader_register_is_output(const struct vkd3d_shader_register *reg)
-{
-    return reg->type == VKD3DSPR_OUTPUT || reg->type == VKD3DSPR_COLOROUT;
-}
+void vsir_instruction_init(struct vkd3d_shader_instruction *ins, const struct vkd3d_shader_location *location,
+        enum vkd3d_shader_opcode handler_idx);
 
-static inline bool vkd3d_shader_register_is_patch_constant(const struct vkd3d_shader_register *reg)
+static inline bool vkd3d_shader_instruction_has_texel_offset(const struct vkd3d_shader_instruction *ins)
 {
-    return reg->type == VKD3DSPR_PATCHCONST;
+    return ins->texel_offset.u || ins->texel_offset.v || ins->texel_offset.w;
 }
 
 static inline bool register_is_constant(const struct vkd3d_shader_register *reg)
@@ -1035,12 +1166,6 @@ static inline bool register_is_constant(const struct vkd3d_shader_register *reg)
     return (reg->type == VKD3DSPR_IMMCONST || reg->type == VKD3DSPR_IMMCONST64);
 }
 
-struct vkd3d_shader_location
-{
-    const char *source_name;
-    unsigned int line, column;
-};
-
 struct vkd3d_shader_param_node
 {
     struct vkd3d_shader_param_node *next;
@@ -1093,6 +1218,11 @@ bool shader_instruction_array_clone_instruction(struct vkd3d_shader_instruction_
         unsigned int dst, unsigned int src);
 void shader_instruction_array_destroy(struct vkd3d_shader_instruction_array *instructions);
 
+enum vkd3d_shader_config_flags
+{
+    VKD3D_SHADER_CONFIG_FLAG_FORCE_VALIDATION = 0x00000001,
+};
+
 struct vkd3d_shader_parser
 {
     struct vkd3d_shader_message_context *message_context;
@@ -1103,6 +1233,8 @@ struct vkd3d_shader_parser
     struct vkd3d_shader_version shader_version;
     const struct vkd3d_shader_parser_ops *ops;
     struct vkd3d_shader_instruction_array instructions;
+
+    uint64_t config_flags;
 };
 
 struct vkd3d_shader_parser_ops
@@ -1248,8 +1380,7 @@ void vkd3d_shader_vnote(struct vkd3d_shader_message_context *context, const stru
 void vkd3d_shader_vwarning(struct vkd3d_shader_message_context *context, const struct vkd3d_shader_location *location,
         enum vkd3d_shader_error error, const char *format, va_list args);
 
-void vkd3d_shader_dump_shader(enum vkd3d_shader_source_type source_type,
-        enum vkd3d_shader_type shader_type, const struct vkd3d_shader_code *shader);
+void vkd3d_shader_dump_shader(const struct vkd3d_shader_compile_info *compile_info);
 void vkd3d_shader_trace_text_(const char *text, size_t size, const char *function);
 #define vkd3d_shader_trace_text(text, size) \
         vkd3d_shader_trace_text_(text, size, __FUNCTION__)
@@ -1291,6 +1422,8 @@ int preproc_lexer_parse(const struct vkd3d_shader_compile_info *compile_info,
 int hlsl_compile_shader(const struct vkd3d_shader_code *hlsl, const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context);
 
+void vsir_validate(struct vkd3d_shader_parser *parser);
+
 static inline enum vkd3d_shader_component_type vkd3d_component_type_from_data_type(
         enum vkd3d_data_type data_type)
 {
@@ -1306,6 +1439,8 @@ static inline enum vkd3d_shader_component_type vkd3d_component_type_from_data_ty
             return VKD3D_SHADER_COMPONENT_INT;
         case VKD3D_DATA_DOUBLE:
             return VKD3D_SHADER_COMPONENT_DOUBLE;
+        case VKD3D_DATA_BOOL:
+            return VKD3D_SHADER_COMPONENT_BOOL;
         default:
             FIXME("Unhandled data type %#x.\n", data_type);
             /* fall-through */
@@ -1458,23 +1593,6 @@ static inline void *vkd3d_find_struct_(const struct vkd3d_struct *chain,
 #define VKD3D_DXBC_HEADER_SIZE (8 * sizeof(uint32_t))
 #define VKD3D_DXBC_CHUNK_ALIGNMENT sizeof(uint32_t)
 
-#define TAG_AON9 VKD3D_MAKE_TAG('A', 'o', 'n', '9')
-#define TAG_DXBC VKD3D_MAKE_TAG('D', 'X', 'B', 'C')
-#define TAG_DXIL VKD3D_MAKE_TAG('D', 'X', 'I', 'L')
-#define TAG_ISG1 VKD3D_MAKE_TAG('I', 'S', 'G', '1')
-#define TAG_ISGN VKD3D_MAKE_TAG('I', 'S', 'G', 'N')
-#define TAG_OSG1 VKD3D_MAKE_TAG('O', 'S', 'G', '1')
-#define TAG_OSG5 VKD3D_MAKE_TAG('O', 'S', 'G', '5')
-#define TAG_OSGN VKD3D_MAKE_TAG('O', 'S', 'G', 'N')
-#define TAG_PCSG VKD3D_MAKE_TAG('P', 'C', 'S', 'G')
-#define TAG_PSG1 VKD3D_MAKE_TAG('P', 'S', 'G', '1')
-#define TAG_RD11 VKD3D_MAKE_TAG('R', 'D', '1', '1')
-#define TAG_RDEF VKD3D_MAKE_TAG('R', 'D', 'E', 'F')
-#define TAG_RTS0 VKD3D_MAKE_TAG('R', 'T', 'S', '0')
-#define TAG_SHDR VKD3D_MAKE_TAG('S', 'H', 'D', 'R')
-#define TAG_SHEX VKD3D_MAKE_TAG('S', 'H', 'E', 'X')
-#define TAG_TEXT VKD3D_MAKE_TAG('T', 'E', 'X', 'T')
-
 #define DXBC_MAX_SECTION_COUNT 5
 
 struct dxbc_writer
diff --git a/libs/vkd3d/libs/vkd3d/command.c b/libs/vkd3d/libs/vkd3d/command.c
index 42a98763438..77d0f2751cf 100644
--- a/libs/vkd3d/libs/vkd3d/command.c
+++ b/libs/vkd3d/libs/vkd3d/command.c
@@ -1942,9 +1942,9 @@ static void d3d12_command_signature_decref(struct d3d12_command_signature *signa
 }
 
 /* ID3D12CommandList */
-static inline struct d3d12_command_list *impl_from_ID3D12GraphicsCommandList3(ID3D12GraphicsCommandList3 *iface)
+static inline struct d3d12_command_list *impl_from_ID3D12GraphicsCommandList5(ID3D12GraphicsCommandList5 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d12_command_list, ID3D12GraphicsCommandList3_iface);
+    return CONTAINING_RECORD(iface, struct d3d12_command_list, ID3D12GraphicsCommandList5_iface);
 }
 
 static void d3d12_command_list_invalidate_current_framebuffer(struct d3d12_command_list *list)
@@ -2290,12 +2290,14 @@ static void d3d12_command_list_track_resource_usage(struct d3d12_command_list *l
     }
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_QueryInterface(ID3D12GraphicsCommandList3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_QueryInterface(ID3D12GraphicsCommandList5 *iface,
         REFIID iid, void **object)
 {
     TRACE("iface %p, iid %s, object %p.\n", iface, debugstr_guid(iid), object);
 
-    if (IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList3)
+    if (IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList5)
+            || IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList4)
+            || IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList3)
             || IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList2)
             || IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList1)
             || IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList)
@@ -2304,7 +2306,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_list_QueryInterface(ID3D12Graphic
             || IsEqualGUID(iid, &IID_ID3D12Object)
             || IsEqualGUID(iid, &IID_IUnknown))
     {
-        ID3D12GraphicsCommandList3_AddRef(iface);
+        ID3D12GraphicsCommandList5_AddRef(iface);
         *object = iface;
         return S_OK;
     }
@@ -2315,9 +2317,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_list_QueryInterface(ID3D12Graphic
     return E_NOINTERFACE;
 }
 
-static ULONG STDMETHODCALLTYPE d3d12_command_list_AddRef(ID3D12GraphicsCommandList3 *iface)
+static ULONG STDMETHODCALLTYPE d3d12_command_list_AddRef(ID3D12GraphicsCommandList5 *iface)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     ULONG refcount = InterlockedIncrement(&list->refcount);
 
     TRACE("%p increasing refcount to %u.\n", list, refcount);
@@ -2330,9 +2332,9 @@ static void vkd3d_pipeline_bindings_cleanup(struct vkd3d_pipeline_bindings *bind
     vkd3d_free(bindings->vk_uav_counter_views);
 }
 
-static ULONG STDMETHODCALLTYPE d3d12_command_list_Release(ID3D12GraphicsCommandList3 *iface)
+static ULONG STDMETHODCALLTYPE d3d12_command_list_Release(ID3D12GraphicsCommandList5 *iface)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     ULONG refcount = InterlockedDecrement(&list->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", list, refcount);
@@ -2358,66 +2360,66 @@ static ULONG STDMETHODCALLTYPE d3d12_command_list_Release(ID3D12GraphicsCommandL
     return refcount;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_GetPrivateData(ID3D12GraphicsCommandList3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_GetPrivateData(ID3D12GraphicsCommandList5 *iface,
         REFGUID guid, UINT *data_size, void *data)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, guid %s, data_size %p, data %p.\n", iface, debugstr_guid(guid), data_size, data);
 
     return vkd3d_get_private_data(&list->private_store, guid, data_size, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetPrivateData(ID3D12GraphicsCommandList3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetPrivateData(ID3D12GraphicsCommandList5 *iface,
         REFGUID guid, UINT data_size, const void *data)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, guid %s, data_size %u, data %p.\n", iface, debugstr_guid(guid), data_size, data);
 
     return vkd3d_set_private_data(&list->private_store, guid, data_size, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetPrivateDataInterface(ID3D12GraphicsCommandList3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetPrivateDataInterface(ID3D12GraphicsCommandList5 *iface,
         REFGUID guid, const IUnknown *data)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, guid %s, data %p.\n", iface, debugstr_guid(guid), data);
 
     return vkd3d_set_private_data_interface(&list->private_store, guid, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetName(ID3D12GraphicsCommandList3 *iface, const WCHAR *name)
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetName(ID3D12GraphicsCommandList5 *iface, const WCHAR *name)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, name %s.\n", iface, debugstr_w(name, list->device->wchar_size));
 
     return name ? S_OK : E_INVALIDARG;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_GetDevice(ID3D12GraphicsCommandList3 *iface, REFIID iid, void **device)
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_GetDevice(ID3D12GraphicsCommandList5 *iface, REFIID iid, void **device)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, iid %s, device %p.\n", iface, debugstr_guid(iid), device);
 
     return d3d12_device_query_interface(list->device, iid, device);
 }
 
-static D3D12_COMMAND_LIST_TYPE STDMETHODCALLTYPE d3d12_command_list_GetType(ID3D12GraphicsCommandList3 *iface)
+static D3D12_COMMAND_LIST_TYPE STDMETHODCALLTYPE d3d12_command_list_GetType(ID3D12GraphicsCommandList5 *iface)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p.\n", iface);
 
     return list->type;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_Close(ID3D12GraphicsCommandList3 *iface)
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_Close(ID3D12GraphicsCommandList5 *iface)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     VkResult vr;
 
@@ -2461,7 +2463,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_list_Close(ID3D12GraphicsCommandL
 static void d3d12_command_list_reset_state(struct d3d12_command_list *list,
         ID3D12PipelineState *initial_pipeline_state)
 {
-    ID3D12GraphicsCommandList3 *iface = &list->ID3D12GraphicsCommandList3_iface;
+    ID3D12GraphicsCommandList5 *iface = &list->ID3D12GraphicsCommandList5_iface;
 
     memset(list->strides, 0, sizeof(list->strides));
     list->primitive_topology = D3D_PRIMITIVE_TOPOLOGY_POINTLIST;
@@ -2497,14 +2499,14 @@ static void d3d12_command_list_reset_state(struct d3d12_command_list *list,
 
     list->descriptor_heap_count = 0;
 
-    ID3D12GraphicsCommandList3_SetPipelineState(iface, initial_pipeline_state);
+    ID3D12GraphicsCommandList5_SetPipelineState(iface, initial_pipeline_state);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_Reset(ID3D12GraphicsCommandList3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_Reset(ID3D12GraphicsCommandList5 *iface,
         ID3D12CommandAllocator *allocator, ID3D12PipelineState *initial_pipeline_state)
 {
     struct d3d12_command_allocator *allocator_impl = unsafe_impl_from_ID3D12CommandAllocator(allocator);
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     HRESULT hr;
 
     TRACE("iface %p, allocator %p, initial_pipeline_state %p.\n",
@@ -2531,10 +2533,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_list_Reset(ID3D12GraphicsCommandL
     return hr;
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ClearState(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ClearState(ID3D12GraphicsCommandList5 *iface,
         ID3D12PipelineState *pipeline_state)
 {
-    FIXME("iface %p, pipline_state %p stub!\n", iface, pipeline_state);
+    FIXME("iface %p, pipeline_state %p stub!\n", iface, pipeline_state);
 }
 
 static bool d3d12_command_list_has_depth_stencil_view(struct d3d12_command_list *list)
@@ -3390,11 +3392,11 @@ static void d3d12_command_list_check_index_buffer_strip_cut_value(struct d3d12_c
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_DrawInstanced(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_DrawInstanced(ID3D12GraphicsCommandList5 *iface,
         UINT vertex_count_per_instance, UINT instance_count, UINT start_vertex_location,
         UINT start_instance_location)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
 
     TRACE("iface %p, vertex_count_per_instance %u, instance_count %u, "
@@ -3414,11 +3416,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_DrawInstanced(ID3D12GraphicsCom
             instance_count, start_vertex_location, start_instance_location));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_DrawIndexedInstanced(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_DrawIndexedInstanced(ID3D12GraphicsCommandList5 *iface,
         UINT index_count_per_instance, UINT instance_count, UINT start_vertex_location,
         INT base_vertex_location, UINT start_instance_location)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
 
     TRACE("iface %p, index_count_per_instance %u, instance_count %u, start_vertex_location %u, "
@@ -3440,10 +3442,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_DrawIndexedInstanced(ID3D12Grap
             instance_count, start_vertex_location, base_vertex_location, start_instance_location));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_Dispatch(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_Dispatch(ID3D12GraphicsCommandList5 *iface,
         UINT x, UINT y, UINT z)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
 
     TRACE("iface %p, x %u, y %u, z %u.\n", iface, x, y, z);
@@ -3459,10 +3461,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_Dispatch(ID3D12GraphicsCommandL
     VK_CALL(vkCmdDispatch(list->vk_command_buffer, x, y, z));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_CopyBufferRegion(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_CopyBufferRegion(ID3D12GraphicsCommandList5 *iface,
         ID3D12Resource *dst, UINT64 dst_offset, ID3D12Resource *src, UINT64 src_offset, UINT64 byte_count)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     struct d3d12_resource *dst_resource, *src_resource;
     const struct vkd3d_vk_device_procs *vk_procs;
     VkBufferCopy buffer_copy;
@@ -3744,11 +3746,11 @@ static bool validate_d3d12_box(const D3D12_BOX *box)
             && box->back > box->front;
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_CopyTextureRegion(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_CopyTextureRegion(ID3D12GraphicsCommandList5 *iface,
         const D3D12_TEXTURE_COPY_LOCATION *dst, UINT dst_x, UINT dst_y, UINT dst_z,
         const D3D12_TEXTURE_COPY_LOCATION *src, const D3D12_BOX *src_box)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     struct d3d12_resource *dst_resource, *src_resource;
     const struct vkd3d_format *src_format, *dst_format;
     const struct vkd3d_vk_device_procs *vk_procs;
@@ -3869,10 +3871,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyTextureRegion(ID3D12Graphic
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_CopyResource(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_CopyResource(ID3D12GraphicsCommandList5 *iface,
         ID3D12Resource *dst, ID3D12Resource *src)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     struct d3d12_resource *dst_resource, *src_resource;
     const struct vkd3d_format *dst_format, *src_format;
     const struct vkd3d_vk_device_procs *vk_procs;
@@ -3939,7 +3941,7 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyResource(ID3D12GraphicsComm
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_CopyTiles(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_CopyTiles(ID3D12GraphicsCommandList5 *iface,
         ID3D12Resource *tiled_resource, const D3D12_TILED_RESOURCE_COORDINATE *tile_region_start_coordinate,
         const D3D12_TILE_REGION_SIZE *tile_region_size, ID3D12Resource *buffer, UINT64 buffer_offset,
         D3D12_TILE_COPY_FLAGS flags)
@@ -3950,11 +3952,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyTiles(ID3D12GraphicsCommand
             buffer, buffer_offset, flags);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresource(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresource(ID3D12GraphicsCommandList5 *iface,
         ID3D12Resource *dst, UINT dst_sub_resource_idx,
         ID3D12Resource *src, UINT src_sub_resource_idx, DXGI_FORMAT format)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct vkd3d_format *src_format, *dst_format, *vk_format;
     struct d3d12_resource *dst_resource, *src_resource;
     const struct vkd3d_vk_device_procs *vk_procs;
@@ -4017,10 +4019,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresource(ID3D12Graphi
             VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &vk_image_resolve));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_IASetPrimitiveTopology(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_IASetPrimitiveTopology(ID3D12GraphicsCommandList5 *iface,
         D3D12_PRIMITIVE_TOPOLOGY topology)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, topology %#x.\n", iface, topology);
 
@@ -4031,11 +4033,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_IASetPrimitiveTopology(ID3D12Gr
     d3d12_command_list_invalidate_current_pipeline(list);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_RSSetViewports(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_RSSetViewports(ID3D12GraphicsCommandList5 *iface,
         UINT viewport_count, const D3D12_VIEWPORT *viewports)
 {
     VkViewport vk_viewports[D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE];
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     unsigned int i;
 
@@ -4069,10 +4071,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_RSSetViewports(ID3D12GraphicsCo
     VK_CALL(vkCmdSetViewport(list->vk_command_buffer, 0, viewport_count, vk_viewports));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_RSSetScissorRects(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_RSSetScissorRects(ID3D12GraphicsCommandList5 *iface,
         UINT rect_count, const D3D12_RECT *rects)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     VkRect2D vk_rects[D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE];
     const struct vkd3d_vk_device_procs *vk_procs;
     unsigned int i;
@@ -4097,10 +4099,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_RSSetScissorRects(ID3D12Graphic
     VK_CALL(vkCmdSetScissor(list->vk_command_buffer, 0, rect_count, vk_rects));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_OMSetBlendFactor(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_OMSetBlendFactor(ID3D12GraphicsCommandList5 *iface,
         const FLOAT blend_factor[4])
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
 
     TRACE("iface %p, blend_factor %p.\n", iface, blend_factor);
@@ -4109,10 +4111,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_OMSetBlendFactor(ID3D12Graphics
     VK_CALL(vkCmdSetBlendConstants(list->vk_command_buffer, blend_factor));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_OMSetStencilRef(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_OMSetStencilRef(ID3D12GraphicsCommandList5 *iface,
         UINT stencil_ref)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
 
     TRACE("iface %p, stencil_ref %u.\n", iface, stencil_ref);
@@ -4121,11 +4123,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_OMSetStencilRef(ID3D12GraphicsC
     VK_CALL(vkCmdSetStencilReference(list->vk_command_buffer, VK_STENCIL_FRONT_AND_BACK, stencil_ref));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetPipelineState(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetPipelineState(ID3D12GraphicsCommandList5 *iface,
         ID3D12PipelineState *pipeline_state)
 {
     struct d3d12_pipeline_state *state = unsafe_impl_from_ID3D12PipelineState(pipeline_state);
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, pipeline_state %p.\n", iface, pipeline_state);
 
@@ -4176,10 +4178,10 @@ static unsigned int d3d12_find_ds_multiplanar_transition(const D3D12_RESOURCE_BA
     return 0;
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ResourceBarrier(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ResourceBarrier(ID3D12GraphicsCommandList5 *iface,
         UINT barrier_count, const D3D12_RESOURCE_BARRIER *barriers)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     bool have_aliasing_barriers = false, have_split_barriers = false;
     const struct vkd3d_vk_device_procs *vk_procs;
     const struct vkd3d_vulkan_info *vk_info;
@@ -4402,13 +4404,13 @@ static void STDMETHODCALLTYPE d3d12_command_list_ResourceBarrier(ID3D12GraphicsC
         WARN("Issuing split barrier(s) on D3D12_RESOURCE_BARRIER_FLAG_END_ONLY.\n");
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ExecuteBundle(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ExecuteBundle(ID3D12GraphicsCommandList5 *iface,
         ID3D12GraphicsCommandList *command_list)
 {
     FIXME("iface %p, command_list %p stub!\n", iface, command_list);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetDescriptorHeaps(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetDescriptorHeaps(ID3D12GraphicsCommandList5 *iface,
         UINT heap_count, ID3D12DescriptorHeap *const *heaps)
 {
     TRACE("iface %p, heap_count %u, heaps %p.\n", iface, heap_count, heaps);
@@ -4434,10 +4436,10 @@ static void d3d12_command_list_set_root_signature(struct d3d12_command_list *lis
     d3d12_command_list_invalidate_root_parameters(list, bind_point);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootSignature(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootSignature(ID3D12GraphicsCommandList5 *iface,
         ID3D12RootSignature *root_signature)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_signature %p.\n", iface, root_signature);
 
@@ -4445,10 +4447,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootSignature(ID3D12G
             unsafe_impl_from_ID3D12RootSignature(root_signature));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootSignature(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootSignature(ID3D12GraphicsCommandList5 *iface,
         ID3D12RootSignature *root_signature)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_signature %p.\n", iface, root_signature);
 
@@ -4487,10 +4489,10 @@ static void d3d12_command_list_set_descriptor_table(struct d3d12_command_list *l
     bindings->descriptor_table_active_mask |= (uint64_t)1 << index;
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootDescriptorTable(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootDescriptorTable(ID3D12GraphicsCommandList5 *iface,
         UINT root_parameter_index, D3D12_GPU_DESCRIPTOR_HANDLE base_descriptor)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, base_descriptor %#"PRIx64".\n",
             iface, root_parameter_index, base_descriptor.ptr);
@@ -4499,10 +4501,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootDescriptorTable(I
             root_parameter_index, base_descriptor);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootDescriptorTable(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootDescriptorTable(ID3D12GraphicsCommandList5 *iface,
         UINT root_parameter_index, D3D12_GPU_DESCRIPTOR_HANDLE base_descriptor)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, base_descriptor %#"PRIx64".\n",
             iface, root_parameter_index, base_descriptor.ptr);
@@ -4524,10 +4526,10 @@ static void d3d12_command_list_set_root_constants(struct d3d12_command_list *lis
             c->stage_flags, c->offset + offset * sizeof(uint32_t), count * sizeof(uint32_t), data));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstant(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstant(ID3D12GraphicsCommandList5 *iface,
         UINT root_parameter_index, UINT data, UINT dst_offset)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, data 0x%08x, dst_offset %u.\n",
             iface, root_parameter_index, data, dst_offset);
@@ -4536,10 +4538,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstant(ID3
             root_parameter_index, dst_offset, 1, &data);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRoot32BitConstant(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRoot32BitConstant(ID3D12GraphicsCommandList5 *iface,
         UINT root_parameter_index, UINT data, UINT dst_offset)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, data 0x%08x, dst_offset %u.\n",
             iface, root_parameter_index, data, dst_offset);
@@ -4548,10 +4550,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRoot32BitConstant(ID
             root_parameter_index, dst_offset, 1, &data);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstants(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstants(ID3D12GraphicsCommandList5 *iface,
         UINT root_parameter_index, UINT constant_count, const void *data, UINT dst_offset)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, constant_count %u, data %p, dst_offset %u.\n",
             iface, root_parameter_index, constant_count, data, dst_offset);
@@ -4560,10 +4562,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstants(ID
             root_parameter_index, dst_offset, constant_count, data);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRoot32BitConstants(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRoot32BitConstants(ID3D12GraphicsCommandList5 *iface,
         UINT root_parameter_index, UINT constant_count, const void *data, UINT dst_offset)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, constant_count %u, data %p, dst_offset %u.\n",
             iface, root_parameter_index, constant_count, data, dst_offset);
@@ -4625,9 +4627,9 @@ static void d3d12_command_list_set_root_cbv(struct d3d12_command_list *list,
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootConstantBufferView(
-        ID3D12GraphicsCommandList3 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4636,9 +4638,9 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootConstantBufferVie
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootConstantBufferView(
-        ID3D12GraphicsCommandList3 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4697,9 +4699,9 @@ static void d3d12_command_list_set_root_descriptor(struct d3d12_command_list *li
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootShaderResourceView(
-        ID3D12GraphicsCommandList3 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4709,9 +4711,9 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootShaderResourceVie
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootShaderResourceView(
-        ID3D12GraphicsCommandList3 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4721,9 +4723,9 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootShaderResourceVi
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootUnorderedAccessView(
-        ID3D12GraphicsCommandList3 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4733,9 +4735,9 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootUnorderedAccessVi
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootUnorderedAccessView(
-        ID3D12GraphicsCommandList3 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4744,10 +4746,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootUnorderedAccessV
             root_parameter_index, address);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_IASetIndexBuffer(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_IASetIndexBuffer(ID3D12GraphicsCommandList5 *iface,
         const D3D12_INDEX_BUFFER_VIEW *view)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     struct d3d12_resource *resource;
     enum VkIndexType index_type;
@@ -4787,10 +4789,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_IASetIndexBuffer(ID3D12Graphics
             view->BufferLocation - resource->gpu_address, index_type));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_IASetVertexBuffers(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_IASetVertexBuffers(ID3D12GraphicsCommandList5 *iface,
         UINT start_slot, UINT view_count, const D3D12_VERTEX_BUFFER_VIEW *views)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct vkd3d_null_resources *null_resources;
     struct vkd3d_gpu_va_allocator *gpu_va_allocator;
     VkDeviceSize offsets[ARRAY_SIZE(list->strides)];
@@ -4845,10 +4847,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_IASetVertexBuffers(ID3D12Graphi
         d3d12_command_list_invalidate_current_pipeline(list);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SOSetTargets(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SOSetTargets(ID3D12GraphicsCommandList5 *iface,
         UINT start_slot, UINT view_count, const D3D12_STREAM_OUTPUT_BUFFER_VIEW *views)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     VkDeviceSize offsets[ARRAY_SIZE(list->so_counter_buffers)];
     VkDeviceSize sizes[ARRAY_SIZE(list->so_counter_buffers)];
     VkBuffer buffers[ARRAY_SIZE(list->so_counter_buffers)];
@@ -4910,11 +4912,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_SOSetTargets(ID3D12GraphicsComm
         VK_CALL(vkCmdBindTransformFeedbackBuffersEXT(list->vk_command_buffer, first, count, buffers, offsets, sizes));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_OMSetRenderTargets(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_OMSetRenderTargets(ID3D12GraphicsCommandList5 *iface,
         UINT render_target_descriptor_count, const D3D12_CPU_DESCRIPTOR_HANDLE *render_target_descriptors,
         BOOL single_descriptor_handle, const D3D12_CPU_DESCRIPTOR_HANDLE *depth_stencil_descriptor)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct d3d12_rtv_desc *rtv_desc;
     const struct d3d12_dsv_desc *dsv_desc;
     VkFormat prev_dsv_format;
@@ -5115,12 +5117,12 @@ static void d3d12_command_list_clear(struct d3d12_command_list *list,
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ClearDepthStencilView(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ClearDepthStencilView(ID3D12GraphicsCommandList5 *iface,
         D3D12_CPU_DESCRIPTOR_HANDLE dsv, D3D12_CLEAR_FLAGS flags, float depth, UINT8 stencil,
         UINT rect_count, const D3D12_RECT *rects)
 {
     const union VkClearValue clear_value = {.depthStencil = {depth, stencil}};
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct d3d12_dsv_desc *dsv_desc = d3d12_dsv_desc_from_cpu_handle(dsv);
     struct VkAttachmentDescription attachment_desc;
     struct VkAttachmentReference ds_reference;
@@ -5164,10 +5166,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_ClearDepthStencilView(ID3D12Gra
             &clear_value, rect_count, rects);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ClearRenderTargetView(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ClearRenderTargetView(ID3D12GraphicsCommandList5 *iface,
         D3D12_CPU_DESCRIPTOR_HANDLE rtv, const FLOAT color[4], UINT rect_count, const D3D12_RECT *rects)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const struct d3d12_rtv_desc *rtv_desc = d3d12_rtv_desc_from_cpu_handle(rtv);
     struct VkAttachmentDescription attachment_desc;
     struct VkAttachmentReference color_reference;
@@ -5412,11 +5414,11 @@ static const struct vkd3d_format *vkd3d_fixup_clear_uav_uint_colour(struct d3d12
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewUint(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewUint(ID3D12GraphicsCommandList5 *iface,
         D3D12_GPU_DESCRIPTOR_HANDLE gpu_handle, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle, ID3D12Resource *resource,
         const UINT values[4], UINT rect_count, const D3D12_RECT *rects)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     struct vkd3d_view *descriptor, *uint_view = NULL;
     struct d3d12_device *device = list->device;
     struct vkd3d_texture_view_desc view_desc;
@@ -5461,6 +5463,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewUint(ID
             view_desc.miplevel_count = 1;
             view_desc.layer_idx = view->info.texture.layer_idx;
             view_desc.layer_count = view->info.texture.layer_count;
+            view_desc.vk_image_aspect = VK_IMAGE_ASPECT_COLOR_BIT;
+            view_desc.usage = VK_IMAGE_USAGE_STORAGE_BIT;
 
             if (!vkd3d_create_texture_view(device, VKD3D_DESCRIPTOR_MAGIC_UAV, resource_impl->u.vk_image, &view_desc,
                     &uint_view))
@@ -5478,11 +5482,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewUint(ID
         vkd3d_view_decref(uint_view, device);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewFloat(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewFloat(ID3D12GraphicsCommandList5 *iface,
         D3D12_GPU_DESCRIPTOR_HANDLE gpu_handle, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle, ID3D12Resource *resource,
         const float values[4], UINT rect_count, const D3D12_RECT *rects)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     struct d3d12_resource *resource_impl;
     VkClearColorValue colour;
     struct vkd3d_view *view;
@@ -5498,16 +5502,16 @@ static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewFloat(I
     d3d12_command_list_clear_uav(list, resource_impl, view, &colour, rect_count, rects);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_DiscardResource(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_DiscardResource(ID3D12GraphicsCommandList5 *iface,
         ID3D12Resource *resource, const D3D12_DISCARD_REGION *region)
 {
     FIXME_ONCE("iface %p, resource %p, region %p stub!\n", iface, resource, region);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_BeginQuery(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_BeginQuery(ID3D12GraphicsCommandList5 *iface,
         ID3D12QueryHeap *heap, D3D12_QUERY_TYPE type, UINT index)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     struct d3d12_query_heap *query_heap = unsafe_impl_from_ID3D12QueryHeap(heap);
     const struct vkd3d_vk_device_procs *vk_procs;
     VkQueryControlFlags flags = 0;
@@ -5534,10 +5538,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_BeginQuery(ID3D12GraphicsComman
     VK_CALL(vkCmdBeginQuery(list->vk_command_buffer, query_heap->vk_query_pool, index, flags));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_EndQuery(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_EndQuery(ID3D12GraphicsCommandList5 *iface,
         ID3D12QueryHeap *heap, D3D12_QUERY_TYPE type, UINT index)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     struct d3d12_query_heap *query_heap = unsafe_impl_from_ID3D12QueryHeap(heap);
     const struct vkd3d_vk_device_procs *vk_procs;
 
@@ -5579,12 +5583,12 @@ static size_t get_query_stride(D3D12_QUERY_TYPE type)
     return sizeof(uint64_t);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ResolveQueryData(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ResolveQueryData(ID3D12GraphicsCommandList5 *iface,
         ID3D12QueryHeap *heap, D3D12_QUERY_TYPE type, UINT start_index, UINT query_count,
         ID3D12Resource *dst_buffer, UINT64 aligned_dst_buffer_offset)
 {
     const struct d3d12_query_heap *query_heap = unsafe_impl_from_ID3D12QueryHeap(heap);
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     struct d3d12_resource *buffer = unsafe_impl_from_ID3D12Resource(dst_buffer);
     const struct vkd3d_vk_device_procs *vk_procs;
     unsigned int i, first, count;
@@ -5660,10 +5664,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_ResolveQueryData(ID3D12Graphics
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetPredication(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetPredication(ID3D12GraphicsCommandList5 *iface,
         ID3D12Resource *buffer, UINT64 aligned_buffer_offset, D3D12_PREDICATION_OP operation)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     struct d3d12_resource *resource = unsafe_impl_from_ID3D12Resource(buffer);
     const struct vkd3d_vulkan_info *vk_info = &list->device->vk_info;
     const struct vkd3d_vk_device_procs *vk_procs;
@@ -5732,19 +5736,19 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetPredication(ID3D12GraphicsCo
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetMarker(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetMarker(ID3D12GraphicsCommandList5 *iface,
         UINT metadata, const void *data, UINT size)
 {
     FIXME("iface %p, metadata %#x, data %p, size %u stub!\n", iface, metadata, data, size);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_BeginEvent(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_BeginEvent(ID3D12GraphicsCommandList5 *iface,
         UINT metadata, const void *data, UINT size)
 {
     FIXME("iface %p, metadata %#x, data %p, size %u stub!\n", iface, metadata, data, size);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_EndEvent(ID3D12GraphicsCommandList3 *iface)
+static void STDMETHODCALLTYPE d3d12_command_list_EndEvent(ID3D12GraphicsCommandList5 *iface)
 {
     FIXME("iface %p stub!\n", iface);
 }
@@ -5753,14 +5757,14 @@ STATIC_ASSERT(sizeof(VkDispatchIndirectCommand) == sizeof(D3D12_DISPATCH_ARGUMEN
 STATIC_ASSERT(sizeof(VkDrawIndexedIndirectCommand) == sizeof(D3D12_DRAW_INDEXED_ARGUMENTS));
 STATIC_ASSERT(sizeof(VkDrawIndirectCommand) == sizeof(D3D12_DRAW_ARGUMENTS));
 
-static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(ID3D12GraphicsCommandList5 *iface,
         ID3D12CommandSignature *command_signature, UINT max_command_count, ID3D12Resource *arg_buffer,
         UINT64 arg_buffer_offset, ID3D12Resource *count_buffer, UINT64 count_buffer_offset)
 {
     struct d3d12_command_signature *sig_impl = unsafe_impl_from_ID3D12CommandSignature(command_signature);
     struct d3d12_resource *count_impl = unsafe_impl_from_ID3D12Resource(count_buffer);
     struct d3d12_resource *arg_impl = unsafe_impl_from_ID3D12Resource(arg_buffer);
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     const D3D12_COMMAND_SIGNATURE_DESC *signature_desc;
     const struct vkd3d_vk_device_procs *vk_procs;
     unsigned int i;
@@ -5859,7 +5863,7 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(ID3D12GraphicsC
     d3d12_command_signature_decref(sig_impl);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT(ID3D12GraphicsCommandList5 *iface,
         ID3D12Resource *dst_buffer, UINT64 dst_offset,
         ID3D12Resource *src_buffer, UINT64 src_offset,
         UINT dependent_resource_count, ID3D12Resource * const *dependent_resources,
@@ -5872,7 +5876,7 @@ static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT(ID3D12Grap
             dependent_resource_count, dependent_resources, dependent_sub_resource_ranges);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT64(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT64(ID3D12GraphicsCommandList5 *iface,
         ID3D12Resource *dst_buffer, UINT64 dst_offset,
         ID3D12Resource *src_buffer, UINT64 src_offset,
         UINT dependent_resource_count, ID3D12Resource * const *dependent_resources,
@@ -5885,20 +5889,20 @@ static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT64(ID3D12Gr
             dependent_resource_count, dependent_resources, dependent_sub_resource_ranges);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_OMSetDepthBounds(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_OMSetDepthBounds(ID3D12GraphicsCommandList5 *iface,
         FLOAT min, FLOAT max)
 {
     FIXME("iface %p, min %.8e, max %.8e stub!\n", iface, min, max);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetSamplePositions(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetSamplePositions(ID3D12GraphicsCommandList5 *iface,
         UINT sample_count, UINT pixel_count, D3D12_SAMPLE_POSITION *sample_positions)
 {
     FIXME("iface %p, sample_count %u, pixel_count %u, sample_positions %p stub!\n",
             iface, sample_count, pixel_count, sample_positions);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresourceRegion(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresourceRegion(ID3D12GraphicsCommandList5 *iface,
         ID3D12Resource *dst_resource, UINT dst_sub_resource_idx, UINT dst_x, UINT dst_y,
         ID3D12Resource *src_resource, UINT src_sub_resource_idx,
         D3D12_RECT *src_rect, DXGI_FORMAT format, D3D12_RESOLVE_MODE mode)
@@ -5910,16 +5914,16 @@ static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresourceRegion(ID3D12
             src_resource, src_sub_resource_idx, src_rect, format, mode);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetViewInstanceMask(ID3D12GraphicsCommandList3 *iface, UINT mask)
+static void STDMETHODCALLTYPE d3d12_command_list_SetViewInstanceMask(ID3D12GraphicsCommandList5 *iface, UINT mask)
 {
     FIXME("iface %p, mask %#x stub!\n", iface, mask);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_WriteBufferImmediate(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_WriteBufferImmediate(ID3D12GraphicsCommandList5 *iface,
         UINT count, const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER *parameters,
         const D3D12_WRITEBUFFERIMMEDIATE_MODE *modes)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList3(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     struct d3d12_resource *resource;
     unsigned int i;
 
@@ -5932,13 +5936,88 @@ static void STDMETHODCALLTYPE d3d12_command_list_WriteBufferImmediate(ID3D12Grap
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetProtectedResourceSession(ID3D12GraphicsCommandList3 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetProtectedResourceSession(ID3D12GraphicsCommandList5 *iface,
         ID3D12ProtectedResourceSession *protected_session)
 {
     FIXME("iface %p, protected_session %p stub!\n", iface, protected_session);
 }
 
-static const struct ID3D12GraphicsCommandList3Vtbl d3d12_command_list_vtbl =
+static void STDMETHODCALLTYPE d3d12_command_list_BeginRenderPass(ID3D12GraphicsCommandList5 *iface,
+        UINT count, const D3D12_RENDER_PASS_RENDER_TARGET_DESC *render_targets,
+        const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC *depth_stencil, D3D12_RENDER_PASS_FLAGS flags)
+{
+    FIXME("iface %p, count %u, render_targets %p, depth_stencil %p, flags %#x stub!\n", iface,
+            count, render_targets, depth_stencil, flags);
+}
+
+static void STDMETHODCALLTYPE d3d12_command_list_EndRenderPass(ID3D12GraphicsCommandList5 *iface)
+{
+    FIXME("iface %p stub!\n", iface);
+}
+
+static void STDMETHODCALLTYPE d3d12_command_list_InitializeMetaCommand(ID3D12GraphicsCommandList5 *iface,
+        ID3D12MetaCommand *meta_command, const void *parameters_data, SIZE_T data_size_in_bytes)
+{
+    FIXME("iface %p, meta_command %p, parameters_data %p, data_size_in_bytes %lu stub!\n", iface,
+            meta_command, parameters_data, data_size_in_bytes);
+}
+
+static void STDMETHODCALLTYPE d3d12_command_list_ExecuteMetaCommand(ID3D12GraphicsCommandList5 *iface,
+        ID3D12MetaCommand *meta_command, const void *parameters_data, SIZE_T data_size_in_bytes)
+{
+    FIXME("iface %p, meta_command %p, parameters_data %p, data_size_in_bytes %lu stub!\n", iface,
+            meta_command, parameters_data, data_size_in_bytes);
+}
+
+static void STDMETHODCALLTYPE d3d12_command_list_BuildRaytracingAccelerationStructure(ID3D12GraphicsCommandList5 *iface,
+        const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC *desc, UINT count,
+        const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *postbuild_info_descs)
+{
+    FIXME("iface %p, desc %p, count %u, postbuild_info_descs %p stub!\n", iface, desc, count, postbuild_info_descs);
+}
+
+static void STDMETHODCALLTYPE d3d12_command_list_EmitRaytracingAccelerationStructurePostbuildInfo(ID3D12GraphicsCommandList5 *iface,
+        const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *desc,
+        UINT structures_count, const D3D12_GPU_VIRTUAL_ADDRESS *src_structure_data)
+{
+    FIXME("iface %p, desc %p, structures_count %u, src_structure_data %p stub!\n",
+            iface, desc, structures_count, src_structure_data);
+}
+
+static void STDMETHODCALLTYPE d3d12_command_list_CopyRaytracingAccelerationStructure(ID3D12GraphicsCommandList5 *iface,
+        D3D12_GPU_VIRTUAL_ADDRESS dst_structure_data,
+        D3D12_GPU_VIRTUAL_ADDRESS src_structure_data,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE mode)
+{
+    FIXME("iface %p, dst_structure_data %#"PRIx64", src_structure_data %#"PRIx64", mode %u stub!\n",
+            iface, dst_structure_data, src_structure_data, mode);
+}
+
+static void STDMETHODCALLTYPE d3d12_command_list_SetPipelineState1(ID3D12GraphicsCommandList5 *iface,
+        ID3D12StateObject *state_object)
+{
+    FIXME("iface %p, state_object %p stub!\n", iface, state_object);
+}
+
+static void STDMETHODCALLTYPE d3d12_command_list_DispatchRays(ID3D12GraphicsCommandList5 *iface,
+        const D3D12_DISPATCH_RAYS_DESC *desc)
+{
+    FIXME("iface %p, desc %p stub!\n", iface, desc);
+}
+
+static void STDMETHODCALLTYPE d3d12_command_list_RSSetShadingRate(ID3D12GraphicsCommandList5 *iface,
+        D3D12_SHADING_RATE rate, const D3D12_SHADING_RATE_COMBINER *combiners)
+{
+    FIXME("iface %p, rate %#x, combiners %p stub!\n", iface, rate, combiners);
+}
+
+static void STDMETHODCALLTYPE d3d12_command_list_RSSetShadingRateImage(ID3D12GraphicsCommandList5 *iface,
+        ID3D12Resource *rate_image)
+{
+    FIXME("iface %p, rate_image %p stub!\n", iface, rate_image);
+}
+
+static const struct ID3D12GraphicsCommandList5Vtbl d3d12_command_list_vtbl =
 {
     /* IUnknown methods */
     d3d12_command_list_QueryInterface,
@@ -6016,6 +6095,19 @@ static const struct ID3D12GraphicsCommandList3Vtbl d3d12_command_list_vtbl =
     d3d12_command_list_WriteBufferImmediate,
     /* ID3D12GraphicsCommandList3 methods */
     d3d12_command_list_SetProtectedResourceSession,
+    /* ID3D12GraphicsCommandList4 methods */
+    d3d12_command_list_BeginRenderPass,
+    d3d12_command_list_EndRenderPass,
+    d3d12_command_list_InitializeMetaCommand,
+    d3d12_command_list_ExecuteMetaCommand,
+    d3d12_command_list_BuildRaytracingAccelerationStructure,
+    d3d12_command_list_EmitRaytracingAccelerationStructurePostbuildInfo,
+    d3d12_command_list_CopyRaytracingAccelerationStructure,
+    d3d12_command_list_SetPipelineState1,
+    d3d12_command_list_DispatchRays,
+    /* ID3D12GraphicsCommandList5 methods */
+    d3d12_command_list_RSSetShadingRate,
+    d3d12_command_list_RSSetShadingRateImage,
 };
 
 static struct d3d12_command_list *unsafe_impl_from_ID3D12CommandList(ID3D12CommandList *iface)
@@ -6023,7 +6115,7 @@ static struct d3d12_command_list *unsafe_impl_from_ID3D12CommandList(ID3D12Comma
     if (!iface)
         return NULL;
     assert(iface->lpVtbl == (struct ID3D12CommandListVtbl *)&d3d12_command_list_vtbl);
-    return CONTAINING_RECORD(iface, struct d3d12_command_list, ID3D12GraphicsCommandList3_iface);
+    return CONTAINING_RECORD(iface, struct d3d12_command_list, ID3D12GraphicsCommandList5_iface);
 }
 
 static HRESULT d3d12_command_list_init(struct d3d12_command_list *list, struct d3d12_device *device,
@@ -6032,7 +6124,7 @@ static HRESULT d3d12_command_list_init(struct d3d12_command_list *list, struct d
 {
     HRESULT hr;
 
-    list->ID3D12GraphicsCommandList3_iface.lpVtbl = &d3d12_command_list_vtbl;
+    list->ID3D12GraphicsCommandList5_iface.lpVtbl = &d3d12_command_list_vtbl;
     list->refcount = 1;
 
     list->type = type;
diff --git a/libs/vkd3d/libs/vkd3d/device.c b/libs/vkd3d/libs/vkd3d/device.c
index c33061073a3..79028fc3dd8 100644
--- a/libs/vkd3d/libs/vkd3d/device.c
+++ b/libs/vkd3d/libs/vkd3d/device.c
@@ -83,6 +83,7 @@ static const struct vkd3d_optional_extension_info optional_device_extensions[] =
     VK_EXTENSION(KHR_DRAW_INDIRECT_COUNT, KHR_draw_indirect_count),
     VK_EXTENSION(KHR_GET_MEMORY_REQUIREMENTS_2, KHR_get_memory_requirements2),
     VK_EXTENSION(KHR_IMAGE_FORMAT_LIST, KHR_image_format_list),
+    VK_EXTENSION(KHR_MAINTENANCE2, KHR_maintenance2),
     VK_EXTENSION(KHR_MAINTENANCE3, KHR_maintenance3),
     VK_EXTENSION(KHR_PUSH_DESCRIPTOR, KHR_push_descriptor),
     VK_EXTENSION(KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE, KHR_sampler_mirror_clamp_to_edge),
@@ -1521,9 +1522,7 @@ static HRESULT vkd3d_init_device_caps(struct d3d12_device *device,
     device->feature_options1.ExpandedComputeResourceStates = TRUE;
     device->feature_options1.Int64ShaderOps = features->shaderInt64;
 
-    /* Depth bounds test is enabled in D3D12_DEPTH_STENCIL_DESC1, which is not
-     * supported. */
-    device->feature_options2.DepthBoundsTestSupported = FALSE;
+    device->feature_options2.DepthBoundsTestSupported = features->depthBounds;
     /* d3d12_command_list_SetSamplePositions() is not implemented. */
     device->feature_options2.ProgrammableSamplePositionsTier = D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER_NOT_SUPPORTED;
 
@@ -2456,17 +2455,21 @@ static void vkd3d_desc_object_cache_cleanup(struct vkd3d_desc_object_cache *cach
 }
 
 /* ID3D12Device */
-static inline struct d3d12_device *impl_from_ID3D12Device1(ID3D12Device1 *iface)
+static inline struct d3d12_device *impl_from_ID3D12Device5(ID3D12Device5 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d12_device, ID3D12Device1_iface);
+    return CONTAINING_RECORD(iface, struct d3d12_device, ID3D12Device5_iface);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_QueryInterface(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_QueryInterface(ID3D12Device5 *iface,
         REFIID riid, void **object)
 {
     TRACE("iface %p, riid %s, object %p.\n", iface, debugstr_guid(riid), object);
 
-    if (IsEqualGUID(riid, &IID_ID3D12Device1)
+    if (IsEqualGUID(riid, &IID_ID3D12Device5)
+            || IsEqualGUID(riid, &IID_ID3D12Device4)
+            || IsEqualGUID(riid, &IID_ID3D12Device3)
+            || IsEqualGUID(riid, &IID_ID3D12Device2)
+            || IsEqualGUID(riid, &IID_ID3D12Device1)
             || IsEqualGUID(riid, &IID_ID3D12Device)
             || IsEqualGUID(riid, &IID_ID3D12Object)
             || IsEqualGUID(riid, &IID_IUnknown))
@@ -2482,9 +2485,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_QueryInterface(ID3D12Device1 *ifac
     return E_NOINTERFACE;
 }
 
-static ULONG STDMETHODCALLTYPE d3d12_device_AddRef(ID3D12Device1 *iface)
+static ULONG STDMETHODCALLTYPE d3d12_device_AddRef(ID3D12Device5 *iface)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     ULONG refcount = InterlockedIncrement(&device->refcount);
 
     TRACE("%p increasing refcount to %u.\n", device, refcount);
@@ -2492,9 +2495,9 @@ static ULONG STDMETHODCALLTYPE d3d12_device_AddRef(ID3D12Device1 *iface)
     return refcount;
 }
 
-static ULONG STDMETHODCALLTYPE d3d12_device_Release(ID3D12Device1 *iface)
+static ULONG STDMETHODCALLTYPE d3d12_device_Release(ID3D12Device5 *iface)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     ULONG refcount = InterlockedDecrement(&device->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", device, refcount);
@@ -2528,10 +2531,10 @@ static ULONG STDMETHODCALLTYPE d3d12_device_Release(ID3D12Device1 *iface)
     return refcount;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_GetPrivateData(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_GetPrivateData(ID3D12Device5 *iface,
         REFGUID guid, UINT *data_size, void *data)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     TRACE("iface %p, guid %s, data_size %p, data %p.\n",
             iface, debugstr_guid(guid), data_size, data);
@@ -2539,10 +2542,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_GetPrivateData(ID3D12Device1 *ifac
     return vkd3d_get_private_data(&device->private_store, guid, data_size, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_SetPrivateData(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_SetPrivateData(ID3D12Device5 *iface,
         REFGUID guid, UINT data_size, const void *data)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     TRACE("iface %p, guid %s, data_size %u, data %p.\n",
             iface, debugstr_guid(guid), data_size, data);
@@ -2550,19 +2553,19 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_SetPrivateData(ID3D12Device1 *ifac
     return vkd3d_set_private_data(&device->private_store, guid, data_size, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_SetPrivateDataInterface(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_SetPrivateDataInterface(ID3D12Device5 *iface,
         REFGUID guid, const IUnknown *data)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     TRACE("iface %p, guid %s, data %p.\n", iface, debugstr_guid(guid), data);
 
     return vkd3d_set_private_data_interface(&device->private_store, guid, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_SetName(ID3D12Device1 *iface, const WCHAR *name)
+static HRESULT STDMETHODCALLTYPE d3d12_device_SetName(ID3D12Device5 *iface, const WCHAR *name)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     TRACE("iface %p, name %s.\n", iface, debugstr_w(name, device->wchar_size));
 
@@ -2570,17 +2573,17 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_SetName(ID3D12Device1 *iface, cons
             VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT, name);
 }
 
-static UINT STDMETHODCALLTYPE d3d12_device_GetNodeCount(ID3D12Device1 *iface)
+static UINT STDMETHODCALLTYPE d3d12_device_GetNodeCount(ID3D12Device5 *iface)
 {
     TRACE("iface %p.\n", iface);
 
     return 1;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandQueue(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandQueue(ID3D12Device5 *iface,
         const D3D12_COMMAND_QUEUE_DESC *desc, REFIID riid, void **command_queue)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_command_queue *object;
     HRESULT hr;
 
@@ -2594,10 +2597,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandQueue(ID3D12Device1 *
             riid, command_queue);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandAllocator(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandAllocator(ID3D12Device5 *iface,
         D3D12_COMMAND_LIST_TYPE type, REFIID riid, void **command_allocator)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_command_allocator *object;
     HRESULT hr;
 
@@ -2611,10 +2614,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandAllocator(ID3D12Devic
             riid, command_allocator);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateGraphicsPipelineState(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateGraphicsPipelineState(ID3D12Device5 *iface,
         const D3D12_GRAPHICS_PIPELINE_STATE_DESC *desc, REFIID riid, void **pipeline_state)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_pipeline_state *object;
     HRESULT hr;
 
@@ -2628,10 +2631,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateGraphicsPipelineState(ID3D12
             &IID_ID3D12PipelineState, riid, pipeline_state);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateComputePipelineState(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateComputePipelineState(ID3D12Device5 *iface,
         const D3D12_COMPUTE_PIPELINE_STATE_DESC *desc, REFIID riid, void **pipeline_state)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_pipeline_state *object;
     HRESULT hr;
 
@@ -2645,11 +2648,11 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateComputePipelineState(ID3D12D
             &IID_ID3D12PipelineState, riid, pipeline_state);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandList(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandList(ID3D12Device5 *iface,
         UINT node_mask, D3D12_COMMAND_LIST_TYPE type, ID3D12CommandAllocator *command_allocator,
         ID3D12PipelineState *initial_pipeline_state, REFIID riid, void **command_list)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_command_list *object;
     HRESULT hr;
 
@@ -2662,8 +2665,8 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandList(ID3D12Device1 *i
             initial_pipeline_state, &object)))
         return hr;
 
-    return return_interface(&object->ID3D12GraphicsCommandList3_iface,
-            &IID_ID3D12GraphicsCommandList3, riid, command_list);
+    return return_interface(&object->ID3D12GraphicsCommandList5_iface,
+            &IID_ID3D12GraphicsCommandList5, riid, command_list);
 }
 
 /* Direct3D feature levels restrict which formats can be optionally supported. */
@@ -2772,10 +2775,10 @@ bool d3d12_device_is_uma(struct d3d12_device *device, bool *coherent)
     return true;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CheckFeatureSupport(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CheckFeatureSupport(ID3D12Device5 *iface,
         D3D12_FEATURE feature, void *feature_data, UINT feature_data_size)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     TRACE("iface %p, feature %#x, feature_data %p, feature_data_size %u.\n",
             iface, feature, feature_data, feature_data_size);
@@ -2925,7 +2928,14 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CheckFeatureSupport(ID3D12Device1
             if (image_features & VK_FORMAT_FEATURE_BLIT_SRC_BIT)
                 data->Support1 |= D3D12_FORMAT_SUPPORT1_MULTISAMPLE_RESOLVE;
             if (image_features & VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT)
+            {
                 data->Support1 |= D3D12_FORMAT_SUPPORT1_TYPED_UNORDERED_ACCESS_VIEW;
+                if (device->vk_info.uav_read_without_format)
+                    data->Support2 |= D3D12_FORMAT_SUPPORT2_UAV_TYPED_LOAD;
+                /* We effectively require shaderStorageImageWriteWithoutFormat,
+                 * so we can just report UAV_TYPED_STORE unconditionally. */
+                data->Support2 |= D3D12_FORMAT_SUPPORT2_UAV_TYPED_STORE;
+            }
 
             if (image_features & VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT)
                 data->Support2 |= D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_ADD
@@ -3274,10 +3284,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CheckFeatureSupport(ID3D12Device1
     }
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateDescriptorHeap(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateDescriptorHeap(ID3D12Device5 *iface,
         const D3D12_DESCRIPTOR_HEAP_DESC *desc, REFIID riid, void **descriptor_heap)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_descriptor_heap *object;
     HRESULT hr;
 
@@ -3291,7 +3301,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateDescriptorHeap(ID3D12Device1
             &IID_ID3D12DescriptorHeap, riid, descriptor_heap);
 }
 
-static UINT STDMETHODCALLTYPE d3d12_device_GetDescriptorHandleIncrementSize(ID3D12Device1 *iface,
+static UINT STDMETHODCALLTYPE d3d12_device_GetDescriptorHandleIncrementSize(ID3D12Device5 *iface,
         D3D12_DESCRIPTOR_HEAP_TYPE descriptor_heap_type)
 {
     TRACE("iface %p, descriptor_heap_type %#x.\n", iface, descriptor_heap_type);
@@ -3314,11 +3324,11 @@ static UINT STDMETHODCALLTYPE d3d12_device_GetDescriptorHandleIncrementSize(ID3D
     }
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateRootSignature(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateRootSignature(ID3D12Device5 *iface,
         UINT node_mask, const void *bytecode, SIZE_T bytecode_length,
         REFIID riid, void **root_signature)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_root_signature *object;
     HRESULT hr;
 
@@ -3334,10 +3344,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateRootSignature(ID3D12Device1
             &IID_ID3D12RootSignature, riid, root_signature);
 }
 
-static void STDMETHODCALLTYPE d3d12_device_CreateConstantBufferView(ID3D12Device1 *iface,
+static void STDMETHODCALLTYPE d3d12_device_CreateConstantBufferView(ID3D12Device5 *iface,
         const D3D12_CONSTANT_BUFFER_VIEW_DESC *desc, D3D12_CPU_DESCRIPTOR_HANDLE descriptor)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_desc tmp = {0};
 
     TRACE("iface %p, desc %p, descriptor %#lx.\n", iface, desc, descriptor.ptr);
@@ -3346,11 +3356,11 @@ static void STDMETHODCALLTYPE d3d12_device_CreateConstantBufferView(ID3D12Device
     d3d12_desc_write_atomic(d3d12_desc_from_cpu_handle(descriptor), &tmp, device);
 }
 
-static void STDMETHODCALLTYPE d3d12_device_CreateShaderResourceView(ID3D12Device1 *iface,
+static void STDMETHODCALLTYPE d3d12_device_CreateShaderResourceView(ID3D12Device5 *iface,
         ID3D12Resource *resource, const D3D12_SHADER_RESOURCE_VIEW_DESC *desc,
         D3D12_CPU_DESCRIPTOR_HANDLE descriptor)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_desc tmp = {0};
 
     TRACE("iface %p, resource %p, desc %p, descriptor %#lx.\n",
@@ -3360,11 +3370,11 @@ static void STDMETHODCALLTYPE d3d12_device_CreateShaderResourceView(ID3D12Device
     d3d12_desc_write_atomic(d3d12_desc_from_cpu_handle(descriptor), &tmp, device);
 }
 
-static void STDMETHODCALLTYPE d3d12_device_CreateUnorderedAccessView(ID3D12Device1 *iface,
+static void STDMETHODCALLTYPE d3d12_device_CreateUnorderedAccessView(ID3D12Device5 *iface,
         ID3D12Resource *resource, ID3D12Resource *counter_resource,
         const D3D12_UNORDERED_ACCESS_VIEW_DESC *desc, D3D12_CPU_DESCRIPTOR_HANDLE descriptor)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_desc tmp = {0};
 
     TRACE("iface %p, resource %p, counter_resource %p, desc %p, descriptor %#lx.\n",
@@ -3375,7 +3385,7 @@ static void STDMETHODCALLTYPE d3d12_device_CreateUnorderedAccessView(ID3D12Devic
     d3d12_desc_write_atomic(d3d12_desc_from_cpu_handle(descriptor), &tmp, device);
 }
 
-static void STDMETHODCALLTYPE d3d12_device_CreateRenderTargetView(ID3D12Device1 *iface,
+static void STDMETHODCALLTYPE d3d12_device_CreateRenderTargetView(ID3D12Device5 *iface,
         ID3D12Resource *resource, const D3D12_RENDER_TARGET_VIEW_DESC *desc,
         D3D12_CPU_DESCRIPTOR_HANDLE descriptor)
 {
@@ -3383,10 +3393,10 @@ static void STDMETHODCALLTYPE d3d12_device_CreateRenderTargetView(ID3D12Device1
             iface, resource, desc, descriptor.ptr);
 
     d3d12_rtv_desc_create_rtv(d3d12_rtv_desc_from_cpu_handle(descriptor),
-            impl_from_ID3D12Device1(iface), unsafe_impl_from_ID3D12Resource(resource), desc);
+            impl_from_ID3D12Device5(iface), unsafe_impl_from_ID3D12Resource(resource), desc);
 }
 
-static void STDMETHODCALLTYPE d3d12_device_CreateDepthStencilView(ID3D12Device1 *iface,
+static void STDMETHODCALLTYPE d3d12_device_CreateDepthStencilView(ID3D12Device5 *iface,
         ID3D12Resource *resource, const D3D12_DEPTH_STENCIL_VIEW_DESC *desc,
         D3D12_CPU_DESCRIPTOR_HANDLE descriptor)
 {
@@ -3394,13 +3404,13 @@ static void STDMETHODCALLTYPE d3d12_device_CreateDepthStencilView(ID3D12Device1
             iface, resource, desc, descriptor.ptr);
 
     d3d12_dsv_desc_create_dsv(d3d12_dsv_desc_from_cpu_handle(descriptor),
-            impl_from_ID3D12Device1(iface), unsafe_impl_from_ID3D12Resource(resource), desc);
+            impl_from_ID3D12Device5(iface), unsafe_impl_from_ID3D12Resource(resource), desc);
 }
 
-static void STDMETHODCALLTYPE d3d12_device_CreateSampler(ID3D12Device1 *iface,
+static void STDMETHODCALLTYPE d3d12_device_CreateSampler(ID3D12Device5 *iface,
         const D3D12_SAMPLER_DESC *desc, D3D12_CPU_DESCRIPTOR_HANDLE descriptor)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_desc tmp = {0};
 
     TRACE("iface %p, desc %p, descriptor %#lx.\n", iface, desc, descriptor.ptr);
@@ -3409,14 +3419,14 @@ static void STDMETHODCALLTYPE d3d12_device_CreateSampler(ID3D12Device1 *iface,
     d3d12_desc_write_atomic(d3d12_desc_from_cpu_handle(descriptor), &tmp, device);
 }
 
-static void STDMETHODCALLTYPE d3d12_device_CopyDescriptors(ID3D12Device1 *iface,
+static void STDMETHODCALLTYPE d3d12_device_CopyDescriptors(ID3D12Device5 *iface,
         UINT dst_descriptor_range_count, const D3D12_CPU_DESCRIPTOR_HANDLE *dst_descriptor_range_offsets,
         const UINT *dst_descriptor_range_sizes,
         UINT src_descriptor_range_count, const D3D12_CPU_DESCRIPTOR_HANDLE *src_descriptor_range_offsets,
         const UINT *src_descriptor_range_sizes,
         D3D12_DESCRIPTOR_HEAP_TYPE descriptor_heap_type)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     unsigned int dst_range_idx, dst_idx, src_range_idx, src_idx;
     unsigned int dst_range_size, src_range_size;
     struct d3d12_descriptor_heap *dst_heap;
@@ -3472,7 +3482,7 @@ static void STDMETHODCALLTYPE d3d12_device_CopyDescriptors(ID3D12Device1 *iface,
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_device_CopyDescriptorsSimple(ID3D12Device1 *iface,
+static void STDMETHODCALLTYPE d3d12_device_CopyDescriptorsSimple(ID3D12Device5 *iface,
         UINT descriptor_count, const D3D12_CPU_DESCRIPTOR_HANDLE dst_descriptor_range_offset,
         const D3D12_CPU_DESCRIPTOR_HANDLE src_descriptor_range_offset,
         D3D12_DESCRIPTOR_HEAP_TYPE descriptor_heap_type)
@@ -3487,10 +3497,10 @@ static void STDMETHODCALLTYPE d3d12_device_CopyDescriptorsSimple(ID3D12Device1 *
 }
 
 static D3D12_RESOURCE_ALLOCATION_INFO * STDMETHODCALLTYPE d3d12_device_GetResourceAllocationInfo(
-        ID3D12Device1 *iface, D3D12_RESOURCE_ALLOCATION_INFO *info, UINT visible_mask,
+        ID3D12Device5 *iface, D3D12_RESOURCE_ALLOCATION_INFO *info, UINT visible_mask,
         UINT count, const D3D12_RESOURCE_DESC *resource_descs)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     const D3D12_RESOURCE_DESC *desc;
     uint64_t requested_alignment;
 
@@ -3563,10 +3573,10 @@ invalid:
     return info;
 }
 
-static D3D12_HEAP_PROPERTIES * STDMETHODCALLTYPE d3d12_device_GetCustomHeapProperties(ID3D12Device1 *iface,
+static D3D12_HEAP_PROPERTIES * STDMETHODCALLTYPE d3d12_device_GetCustomHeapProperties(ID3D12Device5 *iface,
         D3D12_HEAP_PROPERTIES *heap_properties, UINT node_mask, D3D12_HEAP_TYPE heap_type)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     bool coherent;
 
     TRACE("iface %p, heap_properties %p, node_mask 0x%08x, heap_type %#x.\n",
@@ -3606,12 +3616,12 @@ static D3D12_HEAP_PROPERTIES * STDMETHODCALLTYPE d3d12_device_GetCustomHeapPrope
     return heap_properties;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommittedResource(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommittedResource(ID3D12Device5 *iface,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
         const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, REFIID iid, void **resource)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_resource *object;
     HRESULT hr;
 
@@ -3621,26 +3631,26 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommittedResource(ID3D12Devi
             optimized_clear_value, debugstr_guid(iid), resource);
 
     if (FAILED(hr = d3d12_committed_resource_create(device, heap_properties, heap_flags,
-            desc, initial_state, optimized_clear_value, &object)))
+            desc, initial_state, optimized_clear_value, NULL, &object)))
     {
         *resource = NULL;
         return hr;
     }
 
-    return return_interface(&object->ID3D12Resource_iface, &IID_ID3D12Resource, iid, resource);
+    return return_interface(&object->ID3D12Resource1_iface, &IID_ID3D12Resource1, iid, resource);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateHeap(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateHeap(ID3D12Device5 *iface,
         const D3D12_HEAP_DESC *desc, REFIID iid, void **heap)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_heap *object;
     HRESULT hr;
 
     TRACE("iface %p, desc %p, iid %s, heap %p.\n",
             iface, desc, debugstr_guid(iid), heap);
 
-    if (FAILED(hr = d3d12_heap_create(device, desc, NULL, &object)))
+    if (FAILED(hr = d3d12_heap_create(device, desc, NULL, NULL, &object)))
     {
         *heap = NULL;
         return hr;
@@ -3649,12 +3659,12 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateHeap(ID3D12Device1 *iface,
     return return_interface(&object->ID3D12Heap_iface, &IID_ID3D12Heap, iid, heap);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreatePlacedResource(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreatePlacedResource(ID3D12Device5 *iface,
         ID3D12Heap *heap, UINT64 heap_offset,
         const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, REFIID iid, void **resource)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_heap *heap_object;
     struct d3d12_resource *object;
     HRESULT hr;
@@ -3670,14 +3680,14 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreatePlacedResource(ID3D12Device1
             desc, initial_state, optimized_clear_value, &object)))
         return hr;
 
-    return return_interface(&object->ID3D12Resource_iface, &IID_ID3D12Resource, iid, resource);
+    return return_interface(&object->ID3D12Resource1_iface, &IID_ID3D12Resource1, iid, resource);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateReservedResource(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateReservedResource(ID3D12Device5 *iface,
         const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, REFIID iid, void **resource)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_resource *object;
     HRESULT hr;
 
@@ -3688,14 +3698,14 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateReservedResource(ID3D12Devic
             desc, initial_state, optimized_clear_value, &object)))
         return hr;
 
-    return return_interface(&object->ID3D12Resource_iface, &IID_ID3D12Resource, iid, resource);
+    return return_interface(&object->ID3D12Resource1_iface, &IID_ID3D12Resource1, iid, resource);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateSharedHandle(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateSharedHandle(ID3D12Device5 *iface,
         ID3D12DeviceChild *object, const SECURITY_ATTRIBUTES *attributes, DWORD access,
         const WCHAR *name, HANDLE *handle)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     FIXME("iface %p, object %p, attributes %p, access %#x, name %s, handle %p stub!\n",
             iface, object, attributes, access, debugstr_w(name, device->wchar_size), handle);
@@ -3703,7 +3713,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateSharedHandle(ID3D12Device1 *
     return E_NOTIMPL;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_OpenSharedHandle(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_OpenSharedHandle(ID3D12Device5 *iface,
         HANDLE handle, REFIID riid, void **object)
 {
     FIXME("iface %p, handle %p, riid %s, object %p stub!\n",
@@ -3712,10 +3722,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_OpenSharedHandle(ID3D12Device1 *if
     return E_NOTIMPL;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_OpenSharedHandleByName(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_OpenSharedHandleByName(ID3D12Device5 *iface,
         const WCHAR *name, DWORD access, HANDLE *handle)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     FIXME("iface %p, name %s, access %#x, handle %p stub!\n",
             iface, debugstr_w(name, device->wchar_size), access, handle);
@@ -3723,7 +3733,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_OpenSharedHandleByName(ID3D12Devic
     return E_NOTIMPL;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_MakeResident(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_MakeResident(ID3D12Device5 *iface,
         UINT object_count, ID3D12Pageable * const *objects)
 {
     FIXME_ONCE("iface %p, object_count %u, objects %p stub!\n",
@@ -3732,7 +3742,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_MakeResident(ID3D12Device1 *iface,
     return S_OK;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_Evict(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_Evict(ID3D12Device5 *iface,
         UINT object_count, ID3D12Pageable * const *objects)
 {
     FIXME_ONCE("iface %p, object_count %u, objects %p stub!\n",
@@ -3741,10 +3751,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_Evict(ID3D12Device1 *iface,
     return S_OK;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateFence(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateFence(ID3D12Device5 *iface,
         UINT64 initial_value, D3D12_FENCE_FLAGS flags, REFIID riid, void **fence)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_fence *object;
     HRESULT hr;
 
@@ -3757,21 +3767,21 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateFence(ID3D12Device1 *iface,
     return return_interface(&object->ID3D12Fence1_iface, &IID_ID3D12Fence1, riid, fence);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_GetDeviceRemovedReason(ID3D12Device1 *iface)
+static HRESULT STDMETHODCALLTYPE d3d12_device_GetDeviceRemovedReason(ID3D12Device5 *iface)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     TRACE("iface %p.\n", iface);
 
     return device->removed_reason;
 }
 
-static void STDMETHODCALLTYPE d3d12_device_GetCopyableFootprints(ID3D12Device1 *iface,
+static void STDMETHODCALLTYPE d3d12_device_GetCopyableFootprints(ID3D12Device5 *iface,
         const D3D12_RESOURCE_DESC *desc, UINT first_sub_resource, UINT sub_resource_count,
         UINT64 base_offset, D3D12_PLACED_SUBRESOURCE_FOOTPRINT *layouts,
         UINT *row_counts, UINT64 *row_sizes, UINT64 *total_bytes)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     unsigned int i, sub_resource_idx, miplevel_idx, row_count, row_size, row_pitch;
     unsigned int width, height, depth, plane_count, sub_resources_per_plane;
@@ -3851,10 +3861,10 @@ static void STDMETHODCALLTYPE d3d12_device_GetCopyableFootprints(ID3D12Device1 *
         *total_bytes = total;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateQueryHeap(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateQueryHeap(ID3D12Device5 *iface,
         const D3D12_QUERY_HEAP_DESC *desc, REFIID iid, void **heap)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_query_heap *object;
     HRESULT hr;
 
@@ -3867,18 +3877,18 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateQueryHeap(ID3D12Device1 *ifa
     return return_interface(&object->ID3D12QueryHeap_iface, &IID_ID3D12QueryHeap, iid, heap);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_SetStablePowerState(ID3D12Device1 *iface, BOOL enable)
+static HRESULT STDMETHODCALLTYPE d3d12_device_SetStablePowerState(ID3D12Device5 *iface, BOOL enable)
 {
     FIXME("iface %p, enable %#x stub!\n", iface, enable);
 
     return E_NOTIMPL;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandSignature(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandSignature(ID3D12Device5 *iface,
         const D3D12_COMMAND_SIGNATURE_DESC *desc, ID3D12RootSignature *root_signature,
         REFIID iid, void **command_signature)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     struct d3d12_command_signature *object;
     HRESULT hr;
 
@@ -3892,14 +3902,14 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandSignature(ID3D12Devic
             &IID_ID3D12CommandSignature, iid, command_signature);
 }
 
-static void STDMETHODCALLTYPE d3d12_device_GetResourceTiling(ID3D12Device1 *iface,
+static void STDMETHODCALLTYPE d3d12_device_GetResourceTiling(ID3D12Device5 *iface,
         ID3D12Resource *resource, UINT *total_tile_count,
         D3D12_PACKED_MIP_INFO *packed_mip_info, D3D12_TILE_SHAPE *standard_tile_shape,
         UINT *sub_resource_tiling_count, UINT first_sub_resource_tiling,
         D3D12_SUBRESOURCE_TILING *sub_resource_tilings)
 {
     const struct d3d12_resource *resource_impl = impl_from_ID3D12Resource(resource);
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     TRACE("iface %p, resource %p, total_tile_count %p, packed_mip_info %p, "
             "standard_title_shape %p, sub_resource_tiling_count %p, "
@@ -3912,9 +3922,9 @@ static void STDMETHODCALLTYPE d3d12_device_GetResourceTiling(ID3D12Device1 *ifac
             sub_resource_tiling_count, first_sub_resource_tiling, sub_resource_tilings);
 }
 
-static LUID * STDMETHODCALLTYPE d3d12_device_GetAdapterLuid(ID3D12Device1 *iface, LUID *luid)
+static LUID * STDMETHODCALLTYPE d3d12_device_GetAdapterLuid(ID3D12Device5 *iface, LUID *luid)
 {
-    struct d3d12_device *device = impl_from_ID3D12Device1(iface);
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
     TRACE("iface %p, luid %p.\n", iface, luid);
 
@@ -3923,7 +3933,7 @@ static LUID * STDMETHODCALLTYPE d3d12_device_GetAdapterLuid(ID3D12Device1 *iface
     return luid;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_CreatePipelineLibrary(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreatePipelineLibrary(ID3D12Device5 *iface,
         const void *blob, SIZE_T blob_size, REFIID iid, void **lib)
 {
     FIXME("iface %p, blob %p, blob_size %lu, iid %s, lib %p stub!\n", iface, blob, blob_size, debugstr_guid(iid), lib);
@@ -3931,7 +3941,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreatePipelineLibrary(ID3D12Device
     return DXGI_ERROR_UNSUPPORTED;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_SetEventOnMultipleFenceCompletion(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_SetEventOnMultipleFenceCompletion(ID3D12Device5 *iface,
         ID3D12Fence *const *fences, const UINT64 *values, UINT fence_count,
         D3D12_MULTIPLE_FENCE_WAIT_FLAGS flags, HANDLE event)
 {
@@ -3941,7 +3951,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_SetEventOnMultipleFenceCompletion(
     return E_NOTIMPL;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_device_SetResidencyPriority(ID3D12Device1 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_device_SetResidencyPriority(ID3D12Device5 *iface,
         UINT object_count, ID3D12Pageable *const *objects, const D3D12_RESIDENCY_PRIORITY *priorities)
 {
     FIXME_ONCE("iface %p, object_count %u, objects %p, priorities %p stub!\n", iface, object_count, objects, priorities);
@@ -3949,7 +3959,204 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_SetResidencyPriority(ID3D12Device1
     return S_OK;
 }
 
-static const struct ID3D12Device1Vtbl d3d12_device_vtbl =
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreatePipelineState(ID3D12Device5 *iface,
+        const D3D12_PIPELINE_STATE_STREAM_DESC *desc, REFIID iid, void **pipeline_state)
+{
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
+    struct d3d12_pipeline_state *object;
+    HRESULT hr;
+
+    TRACE("iface %p, desc %p, iid %s, pipeline_state %p.\n", iface, desc, debugstr_guid(iid), pipeline_state);
+
+    if (FAILED(hr = d3d12_pipeline_state_create(device, desc, &object)))
+        return hr;
+
+    return return_interface(&object->ID3D12PipelineState_iface, &IID_ID3D12PipelineState, iid, pipeline_state);
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_OpenExistingHeapFromAddress(ID3D12Device5 *iface,
+        const void *address, REFIID iid, void **heap)
+{
+    FIXME("iface %p, address %p, iid %s, heap %p stub!\n", iface, address, debugstr_guid(iid), heap);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_OpenExistingHeapFromFileMapping(ID3D12Device5 *iface,
+        HANDLE file_mapping, REFIID iid, void **heap)
+{
+    FIXME("iface %p, file_mapping %p, iid %s, heap %p stub!\n", iface, file_mapping, debugstr_guid(iid), heap);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_EnqueueMakeResident(ID3D12Device5 *iface,
+        D3D12_RESIDENCY_FLAGS flags, UINT num_objects, ID3D12Pageable *const *objects,
+        ID3D12Fence *fence, UINT64 fence_value)
+{
+    FIXME("iface %p, flags %#x, num_objects %u, objects %p, fence %p, fence_value %#"PRIx64" stub!\n",
+            iface, flags, num_objects, objects, fence, fence_value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandList1(ID3D12Device5 *iface,
+        UINT node_mask, D3D12_COMMAND_LIST_TYPE type, D3D12_COMMAND_LIST_FLAGS flags,
+        REFIID iid, void **command_list)
+{
+    FIXME("iface %p, node_mask 0x%08x, type %#x, flags %#x, iid %s, command_list %p stub!\n",
+            iface, node_mask, type, flags, debugstr_guid(iid), command_list);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateProtectedResourceSession(ID3D12Device5 *iface,
+        const D3D12_PROTECTED_RESOURCE_SESSION_DESC *desc, REFIID iid, void **session)
+{
+    FIXME("iface %p, desc %p, iid %s, session %p stub!\n", iface, desc, debugstr_guid(iid), session);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommittedResource1(ID3D12Device5 *iface,
+        const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
+        const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
+        const D3D12_CLEAR_VALUE *optimized_clear_value,
+        ID3D12ProtectedResourceSession *protected_session, REFIID iid, void **resource)
+{
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
+    struct d3d12_resource *object;
+    HRESULT hr;
+
+    TRACE("iface %p, heap_properties %p, heap_flags %#x, desc %p, initial_state %#x, "
+            "optimized_clear_value %p, protected_session %p, iid %s, resource %p.\n",
+            iface, heap_properties, heap_flags, desc, initial_state,
+            optimized_clear_value, protected_session, debugstr_guid(iid), resource);
+
+    if (FAILED(hr = d3d12_committed_resource_create(device, heap_properties, heap_flags,
+            desc, initial_state, optimized_clear_value, protected_session, &object)))
+    {
+        *resource = NULL;
+        return hr;
+    }
+
+    return return_interface(&object->ID3D12Resource1_iface, &IID_ID3D12Resource1, iid, resource);
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateHeap1(ID3D12Device5 *iface,
+        const D3D12_HEAP_DESC *desc, ID3D12ProtectedResourceSession *protected_session,
+        REFIID iid, void **heap)
+{
+    struct d3d12_device *device = impl_from_ID3D12Device5(iface);
+    struct d3d12_heap *object;
+    HRESULT hr;
+
+    TRACE("iface %p, desc %p, protected_session %p, iid %s, heap %p.\n",
+            iface, desc, protected_session, debugstr_guid(iid), heap);
+
+    if (FAILED(hr = d3d12_heap_create(device, desc, NULL, protected_session, &object)))
+    {
+        *heap = NULL;
+        return hr;
+    }
+
+    return return_interface(&object->ID3D12Heap_iface, &IID_ID3D12Heap, iid, heap);
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateReservedResource1(ID3D12Device5 *iface,
+        const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
+        const D3D12_CLEAR_VALUE *optimized_clear_value,
+        ID3D12ProtectedResourceSession *protected_session, REFIID iid, void **resource)
+{
+    FIXME("iface %p, desc %p, initial_state %#x, optimized_clear_value %p, "
+            "protected_session %p, iid %s, resource %p stub!\n",
+            iface, desc, initial_state, optimized_clear_value, protected_session,
+            debugstr_guid(iid), resource);
+
+    return E_NOTIMPL;
+}
+
+static D3D12_RESOURCE_ALLOCATION_INFO * STDMETHODCALLTYPE d3d12_device_GetResourceAllocationInfo1(
+        ID3D12Device5 *iface, D3D12_RESOURCE_ALLOCATION_INFO *info, UINT visible_mask,
+        UINT count, const D3D12_RESOURCE_DESC *resource_descs,
+        D3D12_RESOURCE_ALLOCATION_INFO1 *info1)
+{
+    FIXME("iface %p, info %p, visible_mask 0x%08x, count %u, resource_descs %p, info1 %p stub!\n",
+            iface, info, visible_mask, count, resource_descs, info1);
+
+    return info;
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateLifetimeTracker(ID3D12Device5 *iface,
+        ID3D12LifetimeOwner *owner, REFIID iid, void **tracker)
+{
+    FIXME("iface %p, owner %p, iid %s, tracker %p stub!\n", iface, owner, debugstr_guid(iid), tracker);
+
+    return E_NOTIMPL;
+}
+
+static void STDMETHODCALLTYPE d3d12_device_RemoveDevice(ID3D12Device5 *iface)
+{
+    FIXME("iface %p stub!\n", iface);
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_EnumerateMetaCommands(ID3D12Device5 *iface,
+        UINT *num_meta_commands, D3D12_META_COMMAND_DESC *command_desc)
+{
+    FIXME("iface %p, num_meta_commands %p, command_desc %p stub!\n", iface,
+            num_meta_commands, command_desc);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_EnumerateMetaCommandParameters(ID3D12Device5 *iface,
+        REFGUID command_id, D3D12_META_COMMAND_PARAMETER_STAGE stage,
+        UINT *size_in_bytes, UINT *parameter_count,
+        D3D12_META_COMMAND_PARAMETER_DESC *parameter_desc)
+{
+    FIXME("iface %p, command_id %s, stage %u, size_in_bytes %p, "
+            "parameter_count %p, parameter_desc %p stub!\n", iface,
+            debugstr_guid(command_id), stage, size_in_bytes, parameter_count, parameter_desc);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateMetaCommand(ID3D12Device5 *iface,
+        REFGUID command_id, UINT node_mask, const void *parameters_data,
+        SIZE_T data_size_in_bytes, REFIID iid, void **meta_command)
+{
+    FIXME("iface %p, command_id %s, node_mask %#x, parameters_data %p, "
+            "data_size_in_bytes %lu, iid %s, meta_command %p stub!\n", iface,
+            debugstr_guid(command_id), node_mask, parameters_data,
+            data_size_in_bytes, debugstr_guid(iid), meta_command);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE d3d12_device_CreateStateObject(ID3D12Device5 *iface,
+        const D3D12_STATE_OBJECT_DESC *desc, REFIID iid, void **state_object)
+{
+    FIXME("iface %p, desc %p, iid %s, state_object %p stub!\n", iface, desc, debugstr_guid(iid), state_object);
+
+    return E_NOTIMPL;
+}
+
+static void STDMETHODCALLTYPE d3d12_device_GetRaytracingAccelerationStructurePrebuildInfo(ID3D12Device5 *iface,
+        const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS *desc,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO *info)
+{
+    FIXME("iface %p, desc %p, info %p stub!\n", iface, desc, info);
+}
+
+static D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS STDMETHODCALLTYPE d3d12_device_CheckDriverMatchingIdentifier(ID3D12Device5 *iface,
+        D3D12_SERIALIZED_DATA_TYPE data_type, const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER *identifier)
+{
+    FIXME("iface %p, data_type %u, identifier %p stub!\n", iface, data_type, identifier);
+
+    return D3D12_DRIVER_MATCHING_IDENTIFIER_UNRECOGNIZED;
+}
+
+static const struct ID3D12Device5Vtbl d3d12_device_vtbl =
 {
     /* IUnknown methods */
     d3d12_device_QueryInterface,
@@ -4002,14 +4209,36 @@ static const struct ID3D12Device1Vtbl d3d12_device_vtbl =
     d3d12_device_CreatePipelineLibrary,
     d3d12_device_SetEventOnMultipleFenceCompletion,
     d3d12_device_SetResidencyPriority,
+    /* ID3D12Device2 methods */
+    d3d12_device_CreatePipelineState,
+    /* ID3D12Device3 methods */
+    d3d12_device_OpenExistingHeapFromAddress,
+    d3d12_device_OpenExistingHeapFromFileMapping,
+    d3d12_device_EnqueueMakeResident,
+    /* ID3D12Device4 methods */
+    d3d12_device_CreateCommandList1,
+    d3d12_device_CreateProtectedResourceSession,
+    d3d12_device_CreateCommittedResource1,
+    d3d12_device_CreateHeap1,
+    d3d12_device_CreateReservedResource1,
+    d3d12_device_GetResourceAllocationInfo1,
+    /* ID3D12Device5 methods */
+    d3d12_device_CreateLifetimeTracker,
+    d3d12_device_RemoveDevice,
+    d3d12_device_EnumerateMetaCommands,
+    d3d12_device_EnumerateMetaCommandParameters,
+    d3d12_device_CreateMetaCommand,
+    d3d12_device_CreateStateObject,
+    d3d12_device_GetRaytracingAccelerationStructurePrebuildInfo,
+    d3d12_device_CheckDriverMatchingIdentifier,
 };
 
-struct d3d12_device *unsafe_impl_from_ID3D12Device1(ID3D12Device1 *iface)
+struct d3d12_device *unsafe_impl_from_ID3D12Device5(ID3D12Device5 *iface)
 {
     if (!iface)
         return NULL;
     assert(iface->lpVtbl == &d3d12_device_vtbl);
-    return impl_from_ID3D12Device1(iface);
+    return impl_from_ID3D12Device5(iface);
 }
 
 static HRESULT d3d12_device_init(struct d3d12_device *device,
@@ -4018,7 +4247,7 @@ static HRESULT d3d12_device_init(struct d3d12_device *device,
     const struct vkd3d_vk_device_procs *vk_procs;
     HRESULT hr;
 
-    device->ID3D12Device1_iface.lpVtbl = &d3d12_device_vtbl;
+    device->ID3D12Device5_iface.lpVtbl = &d3d12_device_vtbl;
     device->refcount = 1;
 
     vkd3d_instance_incref(device->vkd3d_instance = instance);
@@ -4215,28 +4444,28 @@ HRESULT vkd3d_join_thread(struct vkd3d_instance *instance, union vkd3d_thread_ha
 
 IUnknown *vkd3d_get_device_parent(ID3D12Device *device)
 {
-    struct d3d12_device *d3d12_device = impl_from_ID3D12Device1((ID3D12Device1 *)device);
+    struct d3d12_device *d3d12_device = impl_from_ID3D12Device5((ID3D12Device5 *)device);
 
     return d3d12_device->parent;
 }
 
 VkDevice vkd3d_get_vk_device(ID3D12Device *device)
 {
-    struct d3d12_device *d3d12_device = impl_from_ID3D12Device1((ID3D12Device1 *)device);
+    struct d3d12_device *d3d12_device = impl_from_ID3D12Device5((ID3D12Device5 *)device);
 
     return d3d12_device->vk_device;
 }
 
 VkPhysicalDevice vkd3d_get_vk_physical_device(ID3D12Device *device)
 {
-    struct d3d12_device *d3d12_device = impl_from_ID3D12Device1((ID3D12Device1 *)device);
+    struct d3d12_device *d3d12_device = impl_from_ID3D12Device5((ID3D12Device5 *)device);
 
     return d3d12_device->vk_physical_device;
 }
 
 struct vkd3d_instance *vkd3d_instance_from_device(ID3D12Device *device)
 {
-    struct d3d12_device *d3d12_device = impl_from_ID3D12Device1((ID3D12Device1 *)device);
+    struct d3d12_device *d3d12_device = impl_from_ID3D12Device5((ID3D12Device5 *)device);
 
     return d3d12_device->vkd3d_instance;
 }
diff --git a/libs/vkd3d/libs/vkd3d/resource.c b/libs/vkd3d/libs/vkd3d/resource.c
index f3842958d96..abbdfbe2015 100644
--- a/libs/vkd3d/libs/vkd3d/resource.c
+++ b/libs/vkd3d/libs/vkd3d/resource.c
@@ -574,11 +574,15 @@ static HRESULT d3d12_heap_init(struct d3d12_heap *heap,
 }
 
 HRESULT d3d12_heap_create(struct d3d12_device *device, const D3D12_HEAP_DESC *desc,
-        const struct d3d12_resource *resource, struct d3d12_heap **heap)
+        const struct d3d12_resource *resource, ID3D12ProtectedResourceSession *protected_session,
+        struct d3d12_heap **heap)
 {
     struct d3d12_heap *object;
     HRESULT hr;
 
+    if (protected_session)
+        FIXME("Protected session is not supported.\n");
+
     if (!(object = vkd3d_malloc(sizeof(*object))))
         return E_OUTOFMEMORY;
 
@@ -1254,12 +1258,13 @@ static bool d3d12_resource_init_tiles(struct d3d12_resource *resource, struct d3
 }
 
 /* ID3D12Resource */
-static HRESULT STDMETHODCALLTYPE d3d12_resource_QueryInterface(ID3D12Resource *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_QueryInterface(ID3D12Resource1 *iface,
         REFIID riid, void **object)
 {
     TRACE("iface %p, riid %s, object %p.\n", iface, debugstr_guid(riid), object);
 
-    if (IsEqualGUID(riid, &IID_ID3D12Resource)
+    if (IsEqualGUID(riid, &IID_ID3D12Resource1)
+            || IsEqualGUID(riid, &IID_ID3D12Resource)
             || IsEqualGUID(riid, &IID_ID3D12Pageable)
             || IsEqualGUID(riid, &IID_ID3D12DeviceChild)
             || IsEqualGUID(riid, &IID_ID3D12Object)
@@ -1276,9 +1281,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_QueryInterface(ID3D12Resource *i
     return E_NOINTERFACE;
 }
 
-static ULONG STDMETHODCALLTYPE d3d12_resource_AddRef(ID3D12Resource *iface)
+static ULONG STDMETHODCALLTYPE d3d12_resource_AddRef(ID3D12Resource1 *iface)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
     ULONG refcount = InterlockedIncrement(&resource->refcount);
 
     TRACE("%p increasing refcount to %u.\n", resource, refcount);
@@ -1294,9 +1299,9 @@ static ULONG STDMETHODCALLTYPE d3d12_resource_AddRef(ID3D12Resource *iface)
     return refcount;
 }
 
-static ULONG STDMETHODCALLTYPE d3d12_resource_Release(ID3D12Resource *iface)
+static ULONG STDMETHODCALLTYPE d3d12_resource_Release(ID3D12Resource1 *iface)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
     ULONG refcount = InterlockedDecrement(&resource->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", resource, refcount);
@@ -1313,39 +1318,39 @@ static ULONG STDMETHODCALLTYPE d3d12_resource_Release(ID3D12Resource *iface)
     return refcount;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_GetPrivateData(ID3D12Resource *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_GetPrivateData(ID3D12Resource1 *iface,
         REFGUID guid, UINT *data_size, void *data)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
 
     TRACE("iface %p, guid %s, data_size %p, data %p.\n", iface, debugstr_guid(guid), data_size, data);
 
     return vkd3d_get_private_data(&resource->private_store, guid, data_size, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_SetPrivateData(ID3D12Resource *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_SetPrivateData(ID3D12Resource1 *iface,
         REFGUID guid, UINT data_size, const void *data)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
 
     TRACE("iface %p, guid %s, data_size %u, data %p.\n", iface, debugstr_guid(guid), data_size, data);
 
     return vkd3d_set_private_data(&resource->private_store, guid, data_size, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_SetPrivateDataInterface(ID3D12Resource *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_SetPrivateDataInterface(ID3D12Resource1 *iface,
         REFGUID guid, const IUnknown *data)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
 
     TRACE("iface %p, guid %s, data %p.\n", iface, debugstr_guid(guid), data);
 
     return vkd3d_set_private_data_interface(&resource->private_store, guid, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_SetName(ID3D12Resource *iface, const WCHAR *name)
+static HRESULT STDMETHODCALLTYPE d3d12_resource_SetName(ID3D12Resource1 *iface, const WCHAR *name)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
     HRESULT hr;
 
     TRACE("iface %p, name %s.\n", iface, debugstr_w(name, resource->device->wchar_size));
@@ -1364,9 +1369,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_SetName(ID3D12Resource *iface, c
                 VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT, name);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_GetDevice(ID3D12Resource *iface, REFIID iid, void **device)
+static HRESULT STDMETHODCALLTYPE d3d12_resource_GetDevice(ID3D12Resource1 *iface, REFIID iid, void **device)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
 
     TRACE("iface %p, iid %s, device %p.\n", iface, debugstr_guid(iid), device);
 
@@ -1417,10 +1422,10 @@ static void d3d12_resource_flush(struct d3d12_resource *resource, uint64_t offse
         ERR("Failed to flush memory, vr %d.\n", vr);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_Map(ID3D12Resource *iface, UINT sub_resource,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_Map(ID3D12Resource1 *iface, UINT sub_resource,
         const D3D12_RANGE *read_range, void **data)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
     unsigned int sub_resource_count;
 
     TRACE("iface %p, sub_resource %u, read_range %p, data %p.\n",
@@ -1466,10 +1471,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_Map(ID3D12Resource *iface, UINT
     return S_OK;
 }
 
-static void STDMETHODCALLTYPE d3d12_resource_Unmap(ID3D12Resource *iface, UINT sub_resource,
+static void STDMETHODCALLTYPE d3d12_resource_Unmap(ID3D12Resource1 *iface, UINT sub_resource,
         const D3D12_RANGE *written_range)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
     unsigned int sub_resource_count;
 
     TRACE("iface %p, sub_resource %u, written_range %p.\n",
@@ -1488,10 +1493,10 @@ static void STDMETHODCALLTYPE d3d12_resource_Unmap(ID3D12Resource *iface, UINT s
         d3d12_resource_flush(resource, written_range->Begin, written_range->End - written_range->Begin);
 }
 
-static D3D12_RESOURCE_DESC * STDMETHODCALLTYPE d3d12_resource_GetDesc(ID3D12Resource *iface,
+static D3D12_RESOURCE_DESC * STDMETHODCALLTYPE d3d12_resource_GetDesc(ID3D12Resource1 *iface,
         D3D12_RESOURCE_DESC *resource_desc)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
 
     TRACE("iface %p, resource_desc %p.\n", iface, resource_desc);
 
@@ -1499,20 +1504,20 @@ static D3D12_RESOURCE_DESC * STDMETHODCALLTYPE d3d12_resource_GetDesc(ID3D12Reso
     return resource_desc;
 }
 
-static D3D12_GPU_VIRTUAL_ADDRESS STDMETHODCALLTYPE d3d12_resource_GetGPUVirtualAddress(ID3D12Resource *iface)
+static D3D12_GPU_VIRTUAL_ADDRESS STDMETHODCALLTYPE d3d12_resource_GetGPUVirtualAddress(ID3D12Resource1 *iface)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
 
     TRACE("iface %p.\n", iface);
 
     return resource->gpu_address;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_WriteToSubresource(ID3D12Resource *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_WriteToSubresource(ID3D12Resource1 *iface,
         UINT dst_sub_resource, const D3D12_BOX *dst_box, const void *src_data,
         UINT src_row_pitch, UINT src_slice_pitch)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     VkImageSubresource vk_sub_resource;
     const struct vkd3d_format *format;
@@ -1593,11 +1598,11 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_WriteToSubresource(ID3D12Resourc
     return S_OK;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_ReadFromSubresource(ID3D12Resource *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_ReadFromSubresource(ID3D12Resource1 *iface,
         void *dst_data, UINT dst_row_pitch, UINT dst_slice_pitch,
         UINT src_sub_resource, const D3D12_BOX *src_box)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     VkImageSubresource vk_sub_resource;
     const struct vkd3d_format *format;
@@ -1678,10 +1683,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_ReadFromSubresource(ID3D12Resour
     return S_OK;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_resource_GetHeapProperties(ID3D12Resource *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_resource_GetHeapProperties(ID3D12Resource1 *iface,
         D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS *flags)
 {
-    struct d3d12_resource *resource = impl_from_ID3D12Resource(iface);
+    struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
     struct d3d12_heap *heap;
 
     TRACE("iface %p, heap_properties %p, flags %p.\n",
@@ -1715,7 +1720,15 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_GetHeapProperties(ID3D12Resource
     return S_OK;
 }
 
-static const struct ID3D12ResourceVtbl d3d12_resource_vtbl =
+static HRESULT STDMETHODCALLTYPE d3d12_resource_GetProtectedResourceSession(ID3D12Resource1 *iface,
+        REFIID iid, void **session)
+{
+    FIXME("iface %p, iid %s, session %p stub!\n", iface, debugstr_guid(iid), session);
+
+    return E_NOTIMPL;
+}
+
+static const struct ID3D12Resource1Vtbl d3d12_resource_vtbl =
 {
     /* IUnknown methods */
     d3d12_resource_QueryInterface,
@@ -1736,13 +1749,15 @@ static const struct ID3D12ResourceVtbl d3d12_resource_vtbl =
     d3d12_resource_WriteToSubresource,
     d3d12_resource_ReadFromSubresource,
     d3d12_resource_GetHeapProperties,
+    /* ID3D12Resource1 methods */
+    d3d12_resource_GetProtectedResourceSession,
 };
 
 struct d3d12_resource *unsafe_impl_from_ID3D12Resource(ID3D12Resource *iface)
 {
     if (!iface)
         return NULL;
-    assert(iface->lpVtbl == &d3d12_resource_vtbl);
+    assert(iface->lpVtbl == (ID3D12ResourceVtbl *)&d3d12_resource_vtbl);
     return impl_from_ID3D12Resource(iface);
 }
 
@@ -1940,7 +1955,7 @@ static HRESULT d3d12_resource_init(struct d3d12_resource *resource, struct d3d12
 {
     HRESULT hr;
 
-    resource->ID3D12Resource_iface.lpVtbl = &d3d12_resource_vtbl;
+    resource->ID3D12Resource1_iface.lpVtbl = &d3d12_resource_vtbl;
     resource->refcount = 1;
     resource->internal_refcount = 1;
 
@@ -2064,7 +2079,7 @@ static HRESULT vkd3d_allocate_resource_memory(
     heap_desc.Properties = *heap_properties;
     heap_desc.Alignment = 0;
     heap_desc.Flags = heap_flags;
-    if (SUCCEEDED(hr = d3d12_heap_create(device, &heap_desc, resource, &resource->heap)))
+    if (SUCCEEDED(hr = d3d12_heap_create(device, &heap_desc, resource, NULL, &resource->heap)))
         resource->flags |= VKD3D_RESOURCE_DEDICATED_HEAP;
     return hr;
 }
@@ -2072,7 +2087,8 @@ static HRESULT vkd3d_allocate_resource_memory(
 HRESULT d3d12_committed_resource_create(struct d3d12_device *device,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
         const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
-        const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource)
+        const D3D12_CLEAR_VALUE *optimized_clear_value, ID3D12ProtectedResourceSession *protected_session,
+        struct d3d12_resource **resource)
 {
     struct d3d12_resource *object;
     HRESULT hr;
@@ -2083,13 +2099,16 @@ HRESULT d3d12_committed_resource_create(struct d3d12_device *device,
         return E_INVALIDARG;
     }
 
+    if (protected_session)
+        FIXME("Protected session is not supported.\n");
+
     if (FAILED(hr = d3d12_resource_create(device, heap_properties, heap_flags,
             desc, initial_state, optimized_clear_value, &object)))
         return hr;
 
     if (FAILED(hr = vkd3d_allocate_resource_memory(device, object, heap_properties, heap_flags)))
     {
-        d3d12_resource_Release(&object->ID3D12Resource_iface);
+        d3d12_resource_Release(&object->ID3D12Resource1_iface);
         return hr;
     }
 
@@ -2182,7 +2201,7 @@ HRESULT d3d12_placed_resource_create(struct d3d12_device *device, struct d3d12_h
 
     if (FAILED(hr = vkd3d_bind_heap_memory(device, object, heap, heap_offset)))
     {
-        d3d12_resource_Release(&object->ID3D12Resource_iface);
+        d3d12_resource_Release(&object->ID3D12Resource1_iface);
         return hr;
     }
 
@@ -2206,7 +2225,7 @@ HRESULT d3d12_reserved_resource_create(struct d3d12_device *device,
 
     if (!d3d12_resource_init_tiles(object, device))
     {
-        d3d12_resource_Release(&object->ID3D12Resource_iface);
+        d3d12_resource_Release(&object->ID3D12Resource1_iface);
         return E_OUTOFMEMORY;
     }
 
@@ -2220,7 +2239,7 @@ HRESULT d3d12_reserved_resource_create(struct d3d12_device *device,
 HRESULT vkd3d_create_image_resource(ID3D12Device *device,
         const struct vkd3d_image_resource_create_info *create_info, ID3D12Resource **resource)
 {
-    struct d3d12_device *d3d12_device = unsafe_impl_from_ID3D12Device1((ID3D12Device1 *)device);
+    struct d3d12_device *d3d12_device = unsafe_impl_from_ID3D12Device5((ID3D12Device5 *)device);
     struct d3d12_resource *object;
     HRESULT hr;
 
@@ -2241,7 +2260,7 @@ HRESULT vkd3d_create_image_resource(ID3D12Device *device,
 
     memset(object, 0, sizeof(*object));
 
-    object->ID3D12Resource_iface.lpVtbl = &d3d12_resource_vtbl;
+    object->ID3D12Resource1_iface.lpVtbl = &d3d12_resource_vtbl;
     object->refcount = 1;
     object->internal_refcount = 1;
     object->desc = create_info->desc;
@@ -2265,7 +2284,7 @@ HRESULT vkd3d_create_image_resource(ID3D12Device *device,
 
     TRACE("Created resource %p.\n", object);
 
-    *resource = &object->ID3D12Resource_iface;
+    *resource = (ID3D12Resource *)&object->ID3D12Resource1_iface;
 
     return S_OK;
 }
@@ -2998,6 +3017,7 @@ static bool init_default_texture_view_desc(struct vkd3d_texture_view_desc *desc,
     desc->components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
     desc->components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
     desc->allowed_swizzle = false;
+    desc->usage = 0;
     return true;
 }
 
@@ -3039,6 +3059,7 @@ bool vkd3d_create_texture_view(struct d3d12_device *device, uint32_t magic, VkIm
 {
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     const struct vkd3d_format *format = desc->format;
+    VkImageViewUsageCreateInfoKHR usage_desc;
     struct VkImageViewCreateInfo view_desc;
     VkImageView vk_view = VK_NULL_HANDLE;
     struct vkd3d_view *object;
@@ -3060,6 +3081,13 @@ bool vkd3d_create_texture_view(struct d3d12_device *device, uint32_t magic, VkIm
         view_desc.subresourceRange.levelCount = desc->miplevel_count;
         view_desc.subresourceRange.baseArrayLayer = desc->layer_idx;
         view_desc.subresourceRange.layerCount = desc->layer_count;
+        if (device->vk_info.KHR_maintenance2)
+        {
+            usage_desc.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
+            usage_desc.pNext = NULL;
+            usage_desc.usage = desc->usage;
+            view_desc.pNext = &usage_desc;
+        }
         if ((vr = VK_CALL(vkCreateImageView(device->vk_device, &view_desc, NULL, &vk_view))) < 0)
         {
             WARN("Failed to create Vulkan image view, vr %d.\n", vr);
@@ -3196,6 +3224,7 @@ static void vkd3d_create_null_srv(struct d3d12_desc *descriptor,
     vkd3d_desc.components.b = VK_COMPONENT_SWIZZLE_ZERO;
     vkd3d_desc.components.a = VK_COMPONENT_SWIZZLE_ZERO;
     vkd3d_desc.allowed_swizzle = true;
+    vkd3d_desc.usage = VK_IMAGE_USAGE_SAMPLED_BIT;
 
     vkd3d_create_texture_view(device, VKD3D_DESCRIPTOR_MAGIC_SRV, vk_image, &vkd3d_desc, &descriptor->s.u.view);
 }
@@ -3268,6 +3297,7 @@ void d3d12_desc_create_srv(struct d3d12_desc *descriptor,
 
     vkd3d_desc.miplevel_count = VK_REMAINING_MIP_LEVELS;
     vkd3d_desc.allowed_swizzle = true;
+    vkd3d_desc.usage = VK_IMAGE_USAGE_SAMPLED_BIT;
 
     if (desc)
     {
@@ -3421,6 +3451,7 @@ static void vkd3d_create_null_uav(struct d3d12_desc *descriptor,
     vkd3d_desc.components.b = VK_COMPONENT_SWIZZLE_B;
     vkd3d_desc.components.a = VK_COMPONENT_SWIZZLE_A;
     vkd3d_desc.allowed_swizzle = false;
+    vkd3d_desc.usage = VK_IMAGE_USAGE_STORAGE_BIT;
 
     vkd3d_create_texture_view(device, VKD3D_DESCRIPTOR_MAGIC_UAV, vk_image, &vkd3d_desc, &descriptor->s.u.view);
 }
@@ -3480,6 +3511,8 @@ static void vkd3d_create_texture_uav(struct d3d12_desc *descriptor,
     if (!init_default_texture_view_desc(&vkd3d_desc, resource, desc ? desc->Format : 0))
         return;
 
+    vkd3d_desc.usage = VK_IMAGE_USAGE_STORAGE_BIT;
+
     if (vkd3d_format_is_compressed(vkd3d_desc.format))
     {
         WARN("UAVs cannot be created for compressed formats.\n");
@@ -3747,6 +3780,8 @@ void d3d12_rtv_desc_create_rtv(struct d3d12_rtv_desc *rtv_desc, struct d3d12_dev
     if (!init_default_texture_view_desc(&vkd3d_desc, resource, desc ? desc->Format : 0))
         return;
 
+    vkd3d_desc.usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
+
     if (vkd3d_desc.format->vk_aspect_mask != VK_IMAGE_ASPECT_COLOR_BIT)
     {
         WARN("Trying to create RTV for depth/stencil format %#x.\n", vkd3d_desc.format->dxgi_format);
@@ -3847,6 +3882,8 @@ void d3d12_dsv_desc_create_dsv(struct d3d12_dsv_desc *dsv_desc, struct d3d12_dev
     if (!init_default_texture_view_desc(&vkd3d_desc, resource, desc ? desc->Format : 0))
         return;
 
+    vkd3d_desc.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;
+
     if (!(vkd3d_desc.format->vk_aspect_mask & (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT)))
     {
         WARN("Trying to create DSV for format %#x.\n", vkd3d_desc.format->dxgi_format);
diff --git a/libs/vkd3d/libs/vkd3d/state.c b/libs/vkd3d/libs/vkd3d/state.c
index 0b92cffcde3..de0e04ea1e6 100644
--- a/libs/vkd3d/libs/vkd3d/state.c
+++ b/libs/vkd3d/libs/vkd3d/state.c
@@ -836,7 +836,7 @@ static unsigned int vk_heap_binding_count_from_descriptor_range(const struct d3d
     else
     {
         /* Prefer an unsupported binding count vs a zero count, because shader compilation will fail
-         * to match a declaration to a zero binding, resulting in failure of pipline state creation. */
+         * to match a declaration to a zero binding, resulting in failure of pipeline state creation. */
         return max_count + !max_count;
     }
 }
@@ -1736,6 +1736,189 @@ void vkd3d_render_pass_cache_cleanup(struct vkd3d_render_pass_cache *cache,
     cache->render_passes = NULL;
 }
 
+static void d3d12_init_pipeline_state_desc(struct d3d12_pipeline_state_desc *desc)
+{
+    D3D12_DEPTH_STENCIL_DESC1 *ds_state = &desc->depth_stencil_state;
+    D3D12_RASTERIZER_DESC *rs_state = &desc->rasterizer_state;
+    D3D12_BLEND_DESC *blend_state = &desc->blend_state;
+    DXGI_SAMPLE_DESC *sample_desc = &desc->sample_desc;
+
+    memset(desc, 0, sizeof(*desc));
+    ds_state->DepthEnable = TRUE;
+    ds_state->DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
+    ds_state->DepthFunc = D3D12_COMPARISON_FUNC_LESS;
+    ds_state->StencilReadMask = D3D12_DEFAULT_STENCIL_READ_MASK;
+    ds_state->StencilWriteMask = D3D12_DEFAULT_STENCIL_WRITE_MASK;
+    ds_state->FrontFace.StencilFunc = ds_state->BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;
+    ds_state->FrontFace.StencilDepthFailOp = ds_state->BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
+    ds_state->FrontFace.StencilPassOp = ds_state->BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
+    ds_state->FrontFace.StencilFailOp = ds_state->BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
+
+    rs_state->FillMode = D3D12_FILL_MODE_SOLID;
+    rs_state->CullMode = D3D12_CULL_MODE_BACK;
+    rs_state->DepthClipEnable = TRUE;
+    rs_state->ConservativeRaster = D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF;
+
+    blend_state->RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
+
+    sample_desc->Count = 1;
+    sample_desc->Quality = 0;
+
+    desc->sample_mask = D3D12_DEFAULT_SAMPLE_MASK;
+}
+
+static void pipeline_state_desc_from_d3d12_graphics_desc(struct d3d12_pipeline_state_desc *desc,
+        const D3D12_GRAPHICS_PIPELINE_STATE_DESC *d3d12_desc)
+{
+    memset(desc, 0, sizeof(*desc));
+    desc->root_signature = d3d12_desc->pRootSignature;
+    desc->vs = d3d12_desc->VS;
+    desc->ps = d3d12_desc->PS;
+    desc->ds = d3d12_desc->DS;
+    desc->hs = d3d12_desc->HS;
+    desc->gs = d3d12_desc->GS;
+    desc->stream_output = d3d12_desc->StreamOutput;
+    desc->blend_state = d3d12_desc->BlendState;
+    desc->sample_mask = d3d12_desc->SampleMask;
+    desc->rasterizer_state = d3d12_desc->RasterizerState;
+    memcpy(&desc->depth_stencil_state, &d3d12_desc->DepthStencilState, sizeof(d3d12_desc->DepthStencilState));
+    desc->input_layout = d3d12_desc->InputLayout;
+    desc->strip_cut_value = d3d12_desc->IBStripCutValue;
+    desc->primitive_topology_type = d3d12_desc->PrimitiveTopologyType;
+    desc->rtv_formats.NumRenderTargets = d3d12_desc->NumRenderTargets;
+    memcpy(desc->rtv_formats.RTFormats, d3d12_desc->RTVFormats, sizeof(desc->rtv_formats.RTFormats));
+    desc->dsv_format = d3d12_desc->DSVFormat;
+    desc->sample_desc = d3d12_desc->SampleDesc;
+    desc->node_mask = d3d12_desc->NodeMask;
+    desc->cached_pso = d3d12_desc->CachedPSO;
+    desc->flags = d3d12_desc->Flags;
+}
+
+static void pipeline_state_desc_from_d3d12_compute_desc(struct d3d12_pipeline_state_desc *desc,
+        const D3D12_COMPUTE_PIPELINE_STATE_DESC *d3d12_desc)
+{
+    memset(desc, 0, sizeof(*desc));
+    desc->root_signature = d3d12_desc->pRootSignature;
+    desc->cs = d3d12_desc->CS;
+    desc->node_mask = d3d12_desc->NodeMask;
+    desc->cached_pso = d3d12_desc->CachedPSO;
+    desc->flags = d3d12_desc->Flags;
+}
+
+static HRESULT pipeline_state_desc_from_d3d12_stream_desc(struct d3d12_pipeline_state_desc *desc,
+        const D3D12_PIPELINE_STATE_STREAM_DESC *d3d12_desc, VkPipelineBindPoint *vk_bind_point)
+{
+    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE subobject_type;
+    uint64_t defined_subobjects = 0;
+    const uint8_t *stream_ptr;
+    uint64_t subobject_bit;
+    size_t start, size, i;
+    uint8_t *desc_bytes;
+
+    static const struct
+    {
+        size_t alignment;
+        size_t size;
+        size_t dst_offset;
+    }
+    subobject_info[] =
+    {
+#define DCL_SUBOBJECT_INFO(type, field) {__alignof__(type), sizeof(type), offsetof(struct d3d12_pipeline_state_desc, field)}
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE]  = DCL_SUBOBJECT_INFO(ID3D12RootSignature *, root_signature),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VS]              = DCL_SUBOBJECT_INFO(D3D12_SHADER_BYTECODE, vs),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS]              = DCL_SUBOBJECT_INFO(D3D12_SHADER_BYTECODE, ps),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DS]              = DCL_SUBOBJECT_INFO(D3D12_SHADER_BYTECODE, ds),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_HS]              = DCL_SUBOBJECT_INFO(D3D12_SHADER_BYTECODE, hs),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_GS]              = DCL_SUBOBJECT_INFO(D3D12_SHADER_BYTECODE, gs),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CS]              = DCL_SUBOBJECT_INFO(D3D12_SHADER_BYTECODE, cs),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT]   = DCL_SUBOBJECT_INFO(D3D12_STREAM_OUTPUT_DESC, stream_output),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_BLEND]           = DCL_SUBOBJECT_INFO(D3D12_BLEND_DESC, blend_state),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK]     = DCL_SUBOBJECT_INFO(UINT, sample_mask),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER]      = DCL_SUBOBJECT_INFO(D3D12_RASTERIZER_DESC, rasterizer_state),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL]   = DCL_SUBOBJECT_INFO(D3D12_DEPTH_STENCIL_DESC, depth_stencil_state),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT]    = DCL_SUBOBJECT_INFO(D3D12_INPUT_LAYOUT_DESC, input_layout),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE] = DCL_SUBOBJECT_INFO(D3D12_INDEX_BUFFER_STRIP_CUT_VALUE, strip_cut_value),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY] = DCL_SUBOBJECT_INFO(D3D12_PRIMITIVE_TOPOLOGY_TYPE, primitive_topology_type),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS] = DCL_SUBOBJECT_INFO(D3D12_RT_FORMAT_ARRAY, rtv_formats),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT]  = DCL_SUBOBJECT_INFO(DXGI_FORMAT, dsv_format),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC]     = DCL_SUBOBJECT_INFO(DXGI_SAMPLE_DESC, sample_desc),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_NODE_MASK]       = DCL_SUBOBJECT_INFO(UINT, node_mask),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CACHED_PSO]      = DCL_SUBOBJECT_INFO(D3D12_CACHED_PIPELINE_STATE, cached_pso),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_FLAGS]           = DCL_SUBOBJECT_INFO(D3D12_PIPELINE_STATE_FLAGS, flags),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1]  = DCL_SUBOBJECT_INFO(D3D12_DEPTH_STENCIL_DESC1, depth_stencil_state),
+        [D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING] = DCL_SUBOBJECT_INFO(D3D12_VIEW_INSTANCING_DESC, view_instancing_desc),
+#undef DCL_SUBOBJECT_INFO
+    };
+    STATIC_ASSERT(ARRAY_SIZE(subobject_info) <= sizeof(defined_subobjects) * CHAR_BIT);
+
+    /* Initialize defaults for undefined subobjects. */
+    d3d12_init_pipeline_state_desc(desc);
+
+    stream_ptr = d3d12_desc->pPipelineStateSubobjectStream;
+    desc_bytes = (uint8_t *)desc;
+
+    for (i = 0; i < d3d12_desc->SizeInBytes; )
+    {
+        if (!vkd3d_bound_range(0, sizeof(subobject_type), d3d12_desc->SizeInBytes - i))
+        {
+            WARN("Invalid pipeline state stream.\n");
+            return E_INVALIDARG;
+        }
+
+        subobject_type = *(const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE *)&stream_ptr[i];
+        if (subobject_type >= ARRAY_SIZE(subobject_info))
+        {
+            FIXME("Unhandled pipeline subobject type %#x.\n", subobject_type);
+            return E_INVALIDARG;
+        }
+
+        subobject_bit = 1ull << subobject_type;
+        if (defined_subobjects & subobject_bit)
+        {
+            WARN("Duplicate pipeline subobject type %u.\n", subobject_type);
+            return E_INVALIDARG;
+        }
+        defined_subobjects |= subobject_bit;
+
+        start = align(sizeof(subobject_type), subobject_info[subobject_type].alignment);
+        size = subobject_info[subobject_type].size;
+
+        if (!vkd3d_bound_range(start, size, d3d12_desc->SizeInBytes - i))
+        {
+            WARN("Invalid pipeline state stream.\n");
+            return E_INVALIDARG;
+        }
+
+        memcpy(&desc_bytes[subobject_info[subobject_type].dst_offset], &stream_ptr[i + start], size);
+        /* Stream packets are aligned to the size of pointers. */
+        i += align(start + size, sizeof(void *));
+    }
+
+    /* Deduce pipeline type from specified shaders. */
+    if (desc->vs.BytecodeLength && desc->vs.pShaderBytecode)
+    {
+        *vk_bind_point = VK_PIPELINE_BIND_POINT_GRAPHICS;
+    }
+    else if (desc->cs.BytecodeLength && desc->cs.pShaderBytecode)
+    {
+        *vk_bind_point = VK_PIPELINE_BIND_POINT_COMPUTE;
+    }
+    else
+    {
+        WARN("Cannot deduce pipeline type from shader stages.\n");
+        return E_INVALIDARG;
+    }
+
+    if (desc->vs.BytecodeLength && desc->vs.pShaderBytecode
+            && desc->cs.BytecodeLength && desc->cs.pShaderBytecode)
+    {
+        WARN("Invalid combination of shader stages VS and CS.\n");
+        return E_INVALIDARG;
+    }
+
+    return S_OK;
+}
+
 struct vkd3d_pipeline_key
 {
     D3D12_PRIMITIVE_TOPOLOGY topology;
@@ -2193,7 +2376,7 @@ static HRESULT d3d12_pipeline_state_find_and_init_uav_counters(struct d3d12_pipe
 }
 
 static HRESULT d3d12_pipeline_state_init_compute(struct d3d12_pipeline_state *state,
-        struct d3d12_device *device, const D3D12_COMPUTE_PIPELINE_STATE_DESC *desc)
+        struct d3d12_device *device, const struct d3d12_pipeline_state_desc *desc)
 {
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     struct vkd3d_shader_interface_info shader_interface;
@@ -2208,14 +2391,14 @@ static HRESULT d3d12_pipeline_state_init_compute(struct d3d12_pipeline_state *st
 
     memset(&state->uav_counters, 0, sizeof(state->uav_counters));
 
-    if (!(root_signature = unsafe_impl_from_ID3D12RootSignature(desc->pRootSignature)))
+    if (!(root_signature = unsafe_impl_from_ID3D12RootSignature(desc->root_signature)))
     {
         WARN("Root signature is NULL.\n");
         return E_INVALIDARG;
     }
 
     if (FAILED(hr = d3d12_pipeline_state_find_and_init_uav_counters(state, device, root_signature,
-            &desc->CS, VK_SHADER_STAGE_COMPUTE_BIT)))
+            &desc->cs, VK_SHADER_STAGE_COMPUTE_BIT)))
         return hr;
 
     memset(&target_info, 0, sizeof(target_info));
@@ -2256,7 +2439,7 @@ static HRESULT d3d12_pipeline_state_init_compute(struct d3d12_pipeline_state *st
 
     vk_pipeline_layout = state->uav_counters.vk_pipeline_layout
             ? state->uav_counters.vk_pipeline_layout : root_signature->vk_pipeline_layout;
-    if (FAILED(hr = vkd3d_create_compute_pipeline(device, &desc->CS, &shader_interface,
+    if (FAILED(hr = vkd3d_create_compute_pipeline(device, &desc->cs, &shader_interface,
             vk_pipeline_layout, &state->u.compute.vk_pipeline)))
     {
         WARN("Failed to create Vulkan compute pipeline, hr %#x.\n", hr);
@@ -2280,13 +2463,16 @@ static HRESULT d3d12_pipeline_state_init_compute(struct d3d12_pipeline_state *st
 HRESULT d3d12_pipeline_state_create_compute(struct d3d12_device *device,
         const D3D12_COMPUTE_PIPELINE_STATE_DESC *desc, struct d3d12_pipeline_state **state)
 {
+    struct d3d12_pipeline_state_desc pipeline_desc;
     struct d3d12_pipeline_state *object;
     HRESULT hr;
 
+    pipeline_state_desc_from_d3d12_compute_desc(&pipeline_desc, desc);
+
     if (!(object = vkd3d_malloc(sizeof(*object))))
         return E_OUTOFMEMORY;
 
-    if (FAILED(hr = d3d12_pipeline_state_init_compute(object, device, desc)))
+    if (FAILED(hr = d3d12_pipeline_state_init_compute(object, device, &pipeline_desc)))
     {
         vkd3d_free(object);
         return hr;
@@ -2457,7 +2643,7 @@ static void vk_stencil_op_state_from_d3d12(struct VkStencilOpState *vk_desc,
 }
 
 static void ds_desc_from_d3d12(struct VkPipelineDepthStencilStateCreateInfo *vk_desc,
-        const D3D12_DEPTH_STENCIL_DESC *d3d12_desc)
+        const D3D12_DEPTH_STENCIL_DESC1 *d3d12_desc)
 {
     memset(vk_desc, 0, sizeof(*vk_desc));
     vk_desc->sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
@@ -2473,7 +2659,7 @@ static void ds_desc_from_d3d12(struct VkPipelineDepthStencilStateCreateInfo *vk_
         vk_desc->depthWriteEnable = VK_FALSE;
         vk_desc->depthCompareOp = VK_COMPARE_OP_NEVER;
     }
-    vk_desc->depthBoundsTestEnable = VK_FALSE;
+    vk_desc->depthBoundsTestEnable = d3d12_desc->DepthBoundsTestEnable;
     if ((vk_desc->stencilTestEnable = d3d12_desc->StencilEnable))
     {
         vk_stencil_op_state_from_d3d12(&vk_desc->front, &d3d12_desc->FrontFace,
@@ -2738,12 +2924,12 @@ static VkLogicOp vk_logic_op_from_d3d12(D3D12_LOGIC_OP op)
 }
 
 static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *state,
-        struct d3d12_device *device, const D3D12_GRAPHICS_PIPELINE_STATE_DESC *desc)
+        struct d3d12_device *device, const struct d3d12_pipeline_state_desc *desc)
 {
     unsigned int ps_output_swizzle[D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT];
     struct d3d12_graphics_pipeline_state *graphics = &state->u.graphics;
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
-    const D3D12_STREAM_OUTPUT_DESC *so_desc = &desc->StreamOutput;
+    const D3D12_STREAM_OUTPUT_DESC *so_desc = &desc->stream_output;
     VkVertexInputBindingDivisorDescriptionEXT *binding_divisor;
     const struct vkd3d_vulkan_info *vk_info = &device->vk_info;
     uint32_t instance_divisors[D3D12_VS_INPUT_REGISTER_COUNT];
@@ -2787,11 +2973,11 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     }
     shader_stages[] =
     {
-        {VK_SHADER_STAGE_VERTEX_BIT,                  offsetof(D3D12_GRAPHICS_PIPELINE_STATE_DESC, VS)},
-        {VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,    offsetof(D3D12_GRAPHICS_PIPELINE_STATE_DESC, HS)},
-        {VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, offsetof(D3D12_GRAPHICS_PIPELINE_STATE_DESC, DS)},
-        {VK_SHADER_STAGE_GEOMETRY_BIT,                offsetof(D3D12_GRAPHICS_PIPELINE_STATE_DESC, GS)},
-        {VK_SHADER_STAGE_FRAGMENT_BIT,                offsetof(D3D12_GRAPHICS_PIPELINE_STATE_DESC, PS)},
+        {VK_SHADER_STAGE_VERTEX_BIT,                  offsetof(struct d3d12_pipeline_state_desc, vs)},
+        {VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,    offsetof(struct d3d12_pipeline_state_desc, hs)},
+        {VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, offsetof(struct d3d12_pipeline_state_desc, ds)},
+        {VK_SHADER_STAGE_GEOMETRY_BIT,                offsetof(struct d3d12_pipeline_state_desc, gs)},
+        {VK_SHADER_STAGE_FRAGMENT_BIT,                offsetof(struct d3d12_pipeline_state_desc, ps)},
     };
 
     state->ID3D12PipelineState_iface.lpVtbl = &d3d12_pipeline_state_vtbl;
@@ -2802,26 +2988,26 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
 
     memset(&input_signature, 0, sizeof(input_signature));
 
-    for (i = desc->NumRenderTargets; i < ARRAY_SIZE(desc->RTVFormats); ++i)
+    for (i = desc->rtv_formats.NumRenderTargets; i < ARRAY_SIZE(desc->rtv_formats.RTFormats); ++i)
     {
-        if (desc->RTVFormats[i] != DXGI_FORMAT_UNKNOWN)
+        if (desc->rtv_formats.RTFormats[i] != DXGI_FORMAT_UNKNOWN)
         {
             WARN("Format must be set to DXGI_FORMAT_UNKNOWN for inactive render targets.\n");
             return E_INVALIDARG;
         }
     }
 
-    if (!(root_signature = unsafe_impl_from_ID3D12RootSignature(desc->pRootSignature)))
+    if (!(root_signature = unsafe_impl_from_ID3D12RootSignature(desc->root_signature)))
     {
         WARN("Root signature is NULL.\n");
         return E_INVALIDARG;
     }
 
-    sample_count = vk_samples_from_dxgi_sample_desc(&desc->SampleDesc);
-    if (desc->SampleDesc.Count != 1 && desc->SampleDesc.Quality)
-        WARN("Ignoring sample quality %u.\n", desc->SampleDesc.Quality);
+    sample_count = vk_samples_from_dxgi_sample_desc(&desc->sample_desc);
+    if (desc->sample_desc.Count != 1 && desc->sample_desc.Quality)
+        WARN("Ignoring sample quality %u.\n", desc->sample_desc.Quality);
 
-    rt_count = desc->NumRenderTargets;
+    rt_count = desc->rtv_formats.NumRenderTargets;
     if (rt_count > ARRAY_SIZE(graphics->blend_attachments))
     {
         FIXME("NumRenderTargets %zu > %zu, ignoring extra formats.\n",
@@ -2829,40 +3015,40 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
         rt_count = ARRAY_SIZE(graphics->blend_attachments);
     }
 
-    graphics->om_logic_op_enable = desc->BlendState.RenderTarget[0].LogicOpEnable
+    graphics->om_logic_op_enable = desc->blend_state.RenderTarget[0].LogicOpEnable
             && device->feature_options.OutputMergerLogicOp;
     graphics->om_logic_op = graphics->om_logic_op_enable
-            ? vk_logic_op_from_d3d12(desc->BlendState.RenderTarget[0].LogicOp)
+            ? vk_logic_op_from_d3d12(desc->blend_state.RenderTarget[0].LogicOp)
             : VK_LOGIC_OP_COPY;
-    if (desc->BlendState.RenderTarget[0].LogicOpEnable && !graphics->om_logic_op_enable)
+    if (desc->blend_state.RenderTarget[0].LogicOpEnable && !graphics->om_logic_op_enable)
         WARN("The device does not support output merger logic ops. Ignoring logic op %#x.\n",
-                desc->BlendState.RenderTarget[0].LogicOp);
+                desc->blend_state.RenderTarget[0].LogicOp);
 
     graphics->null_attachment_mask = 0;
     for (i = 0; i < rt_count; ++i)
     {
         const D3D12_RENDER_TARGET_BLEND_DESC *rt_desc;
 
-        if (desc->RTVFormats[i] == DXGI_FORMAT_UNKNOWN)
+        if (desc->rtv_formats.RTFormats[i] == DXGI_FORMAT_UNKNOWN)
         {
             graphics->null_attachment_mask |= 1u << i;
             ps_output_swizzle[i] = VKD3D_SHADER_NO_SWIZZLE;
             graphics->rtv_formats[i] = VK_FORMAT_UNDEFINED;
         }
-        else if ((format = vkd3d_get_format(device, desc->RTVFormats[i], false)))
+        else if ((format = vkd3d_get_format(device, desc->rtv_formats.RTFormats[i], false)))
         {
             ps_output_swizzle[i] = vkd3d_get_rt_format_swizzle(format);
             graphics->rtv_formats[i] = format->vk_format;
         }
         else
         {
-            WARN("Invalid RTV format %#x.\n", desc->RTVFormats[i]);
+            WARN("Invalid RTV format %#x.\n", desc->rtv_formats.RTFormats[i]);
             hr = E_INVALIDARG;
             goto fail;
         }
 
-        rt_desc = &desc->BlendState.RenderTarget[desc->BlendState.IndependentBlendEnable ? i : 0];
-        if (desc->BlendState.IndependentBlendEnable && rt_desc->LogicOpEnable)
+        rt_desc = &desc->blend_state.RenderTarget[desc->blend_state.IndependentBlendEnable ? i : 0];
+        if (desc->blend_state.IndependentBlendEnable && rt_desc->LogicOpEnable)
         {
             WARN("IndependentBlendEnable must be FALSE when logic operations are enabled.\n");
             hr = E_INVALIDARG;
@@ -2881,8 +3067,14 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
         graphics->rtv_formats[i] = VK_FORMAT_UNDEFINED;
     graphics->rt_count = rt_count;
 
-    ds_desc_from_d3d12(&graphics->ds_desc, &desc->DepthStencilState);
-    if (desc->DSVFormat == DXGI_FORMAT_UNKNOWN
+    ds_desc_from_d3d12(&graphics->ds_desc, &desc->depth_stencil_state);
+    if (graphics->ds_desc.depthBoundsTestEnable && !device->feature_options2.DepthBoundsTestSupported)
+    {
+        WARN("Depth bounds test not supported by device.\n");
+        hr = E_INVALIDARG;
+        goto fail;
+    }
+    if (desc->dsv_format == DXGI_FORMAT_UNKNOWN
             && graphics->ds_desc.depthTestEnable && !graphics->ds_desc.depthWriteEnable
             && graphics->ds_desc.depthCompareOp == VK_COMPARE_OP_ALWAYS && !graphics->ds_desc.stencilTestEnable)
     {
@@ -2891,15 +3083,16 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     }
 
     graphics->dsv_format = VK_FORMAT_UNDEFINED;
-    if (graphics->ds_desc.depthTestEnable || graphics->ds_desc.stencilTestEnable)
+    if (graphics->ds_desc.depthTestEnable || graphics->ds_desc.stencilTestEnable
+            || graphics->ds_desc.depthBoundsTestEnable)
     {
-        if (desc->DSVFormat == DXGI_FORMAT_UNKNOWN)
+        if (desc->dsv_format == DXGI_FORMAT_UNKNOWN)
         {
             WARN("DSV format is DXGI_FORMAT_UNKNOWN.\n");
             graphics->dsv_format = VK_FORMAT_UNDEFINED;
             graphics->null_attachment_mask |= dsv_attachment_mask(graphics);
         }
-        else if ((format = vkd3d_get_format(device, desc->DSVFormat, true)))
+        else if ((format = vkd3d_get_format(device, desc->dsv_format, true)))
         {
             if (!(format->vk_aspect_mask & (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT)))
                 FIXME("Format %#x is not depth/stencil format.\n", format->dxgi_format);
@@ -2908,12 +3101,12 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
         }
         else
         {
-            WARN("Invalid DSV format %#x.\n", desc->DSVFormat);
+            WARN("Invalid DSV format %#x.\n", desc->dsv_format);
             hr = E_INVALIDARG;
             goto fail;
         }
 
-        if (!desc->PS.pShaderBytecode)
+        if (!desc->ps.pShaderBytecode)
         {
             if (FAILED(hr = create_shader_stage(device, &graphics->stages[graphics->stage_count],
                     VK_SHADER_STAGE_FRAGMENT_BIT, &default_ps, NULL)))
@@ -2936,7 +3129,7 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     ps_target_info.extension_count = vk_info->shader_extension_count;
     ps_target_info.parameters = ps_shader_parameters;
     ps_target_info.parameter_count = ARRAY_SIZE(ps_shader_parameters);
-    ps_target_info.dual_source_blending = is_dual_source_blending(&desc->BlendState.RenderTarget[0]);
+    ps_target_info.dual_source_blending = is_dual_source_blending(&desc->blend_state.RenderTarget[0]);
     ps_target_info.output_swizzles = ps_output_swizzle;
     ps_target_info.output_swizzle_count = rt_count;
 
@@ -2946,11 +3139,11 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
         hr = E_INVALIDARG;
         goto fail;
     }
-    if (ps_target_info.dual_source_blending && desc->BlendState.IndependentBlendEnable)
+    if (ps_target_info.dual_source_blending && desc->blend_state.IndependentBlendEnable)
     {
-        for (i = 1; i < ARRAY_SIZE(desc->BlendState.RenderTarget); ++i)
+        for (i = 1; i < ARRAY_SIZE(desc->blend_state.RenderTarget); ++i)
         {
-            if (desc->BlendState.RenderTarget[i].BlendEnable)
+            if (desc->blend_state.RenderTarget[i].BlendEnable)
             {
                 WARN("Blend enable cannot be set for render target %u when dual source blending is used.\n", i);
                 hr = E_INVALIDARG;
@@ -2992,9 +3185,9 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
         xfb_info.buffer_strides = so_desc->pBufferStrides;
         xfb_info.buffer_stride_count = so_desc->NumStrides;
 
-        if (desc->GS.pShaderBytecode)
+        if (desc->gs.pShaderBytecode)
             xfb_stage = VK_SHADER_STAGE_GEOMETRY_BIT;
-        else if (desc->DS.pShaderBytecode)
+        else if (desc->ds.pShaderBytecode)
             xfb_stage = VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT;
         else
             xfb_stage = VK_SHADER_STAGE_VERTEX_BIT;
@@ -3046,7 +3239,7 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
 
             case VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT:
             case VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT:
-                if (desc->PrimitiveTopologyType != D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH)
+                if (desc->primitive_topology_type != D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH)
                 {
                     WARN("D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH must be used with tessellation shaders.\n");
                     hr = E_INVALIDARG;
@@ -3088,7 +3281,7 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
         ++graphics->stage_count;
     }
 
-    graphics->attribute_count = desc->InputLayout.NumElements;
+    graphics->attribute_count = desc->input_layout.NumElements;
     if (graphics->attribute_count > ARRAY_SIZE(graphics->attributes))
     {
         FIXME("InputLayout.NumElements %zu > %zu, ignoring extra elements.\n",
@@ -3104,13 +3297,13 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
         goto fail;
     }
 
-    if (FAILED(hr = compute_input_layout_offsets(device, &desc->InputLayout, aligned_offsets)))
+    if (FAILED(hr = compute_input_layout_offsets(device, &desc->input_layout, aligned_offsets)))
         goto fail;
 
     graphics->instance_divisor_count = 0;
     for (i = 0, j = 0, mask = 0; i < graphics->attribute_count; ++i)
     {
-        const D3D12_INPUT_ELEMENT_DESC *e = &desc->InputLayout.pInputElementDescs[i];
+        const D3D12_INPUT_ELEMENT_DESC *e = &desc->input_layout.pInputElementDescs[i];
         const struct vkd3d_shader_signature_element *signature_element;
 
         /* TODO: DXGI_FORMAT_UNKNOWN will succeed here, which may not match
@@ -3194,30 +3387,30 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     graphics->attribute_count = j;
     vkd3d_shader_free_shader_signature(&input_signature);
 
-    switch (desc->IBStripCutValue)
+    switch (desc->strip_cut_value)
     {
         case D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_DISABLED:
         case D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFF:
         case D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFFFFFF:
-            graphics->index_buffer_strip_cut_value = desc->IBStripCutValue;
+            graphics->index_buffer_strip_cut_value = desc->strip_cut_value;
             break;
         default:
-            WARN("Invalid index buffer strip cut value %#x.\n", desc->IBStripCutValue);
+            WARN("Invalid index buffer strip cut value %#x.\n", desc->strip_cut_value);
             hr = E_INVALIDARG;
             goto fail;
     }
 
     is_dsv_format_unknown = graphics->null_attachment_mask & dsv_attachment_mask(graphics);
 
-    rs_desc_from_d3d12(&graphics->rs_desc, &desc->RasterizerState);
+    rs_desc_from_d3d12(&graphics->rs_desc, &desc->rasterizer_state);
     have_attachment = graphics->rt_count || graphics->dsv_format || is_dsv_format_unknown;
-    if ((!have_attachment && !(desc->PS.pShaderBytecode && desc->PS.BytecodeLength))
+    if ((!have_attachment && !(desc->ps.pShaderBytecode && desc->ps.BytecodeLength))
             || (graphics->xfb_enabled && so_desc->RasterizedStream == D3D12_SO_NO_RASTERIZED_STREAM))
         graphics->rs_desc.rasterizerDiscardEnable = VK_TRUE;
 
     rs_stream_info_from_d3d12(&graphics->rs_stream_info, &graphics->rs_desc, so_desc, vk_info);
     if (vk_info->EXT_depth_clip_enable)
-        rs_depth_clip_info_from_d3d12(&graphics->rs_depth_clip_info, &graphics->rs_desc, &desc->RasterizerState);
+        rs_depth_clip_info_from_d3d12(&graphics->rs_depth_clip_info, &graphics->rs_desc, &desc->rasterizer_state);
 
     graphics->ms_desc.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
     graphics->ms_desc.pNext = NULL;
@@ -3226,17 +3419,24 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     graphics->ms_desc.sampleShadingEnable = VK_FALSE;
     graphics->ms_desc.minSampleShading = 0.0f;
     graphics->ms_desc.pSampleMask = NULL;
-    if (desc->SampleMask != ~0u)
+    if (desc->sample_mask != ~0u)
     {
         assert(DIV_ROUND_UP(sample_count, 32) <= ARRAY_SIZE(graphics->sample_mask));
-        graphics->sample_mask[0] = desc->SampleMask;
+        graphics->sample_mask[0] = desc->sample_mask;
         graphics->sample_mask[1] = 0xffffffffu;
         graphics->ms_desc.pSampleMask = graphics->sample_mask;
     }
-    graphics->ms_desc.alphaToCoverageEnable = desc->BlendState.AlphaToCoverageEnable;
+    graphics->ms_desc.alphaToCoverageEnable = desc->blend_state.AlphaToCoverageEnable;
     graphics->ms_desc.alphaToOneEnable = VK_FALSE;
 
-    /* We defer creating the render pass for pipelines wth DSVFormat equal to
+    if (desc->view_instancing_desc.ViewInstanceCount)
+    {
+        FIXME("View instancing is not supported yet.\n");
+        hr = E_INVALIDARG;
+        goto fail;
+    }
+
+    /* We defer creating the render pass for pipelines with DSVFormat equal to
      * DXGI_FORMAT_UNKNOWN. We take the actual DSV format from the bound DSV. */
     if (is_dsv_format_unknown)
         graphics->render_pass = VK_NULL_HANDLE;
@@ -3271,13 +3471,16 @@ fail:
 HRESULT d3d12_pipeline_state_create_graphics(struct d3d12_device *device,
         const D3D12_GRAPHICS_PIPELINE_STATE_DESC *desc, struct d3d12_pipeline_state **state)
 {
+    struct d3d12_pipeline_state_desc pipeline_desc;
     struct d3d12_pipeline_state *object;
     HRESULT hr;
 
+    pipeline_state_desc_from_d3d12_graphics_desc(&pipeline_desc, desc);
+
     if (!(object = vkd3d_malloc(sizeof(*object))))
         return E_OUTOFMEMORY;
 
-    if (FAILED(hr = d3d12_pipeline_state_init_graphics(object, device, desc)))
+    if (FAILED(hr = d3d12_pipeline_state_init_graphics(object, device, &pipeline_desc)))
     {
         vkd3d_free(object);
         return hr;
@@ -3290,6 +3493,46 @@ HRESULT d3d12_pipeline_state_create_graphics(struct d3d12_device *device,
     return S_OK;
 }
 
+HRESULT d3d12_pipeline_state_create(struct d3d12_device *device,
+        const D3D12_PIPELINE_STATE_STREAM_DESC *desc, struct d3d12_pipeline_state **state)
+{
+    struct d3d12_pipeline_state_desc pipeline_desc;
+    struct d3d12_pipeline_state *object;
+    VkPipelineBindPoint bind_point;
+    HRESULT hr;
+
+    if (FAILED(hr = pipeline_state_desc_from_d3d12_stream_desc(&pipeline_desc, desc, &bind_point)))
+        return hr;
+
+    if (!(object = vkd3d_calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    switch (bind_point)
+    {
+        case VK_PIPELINE_BIND_POINT_COMPUTE:
+            hr = d3d12_pipeline_state_init_compute(object, device, &pipeline_desc);
+            break;
+
+        case VK_PIPELINE_BIND_POINT_GRAPHICS:
+            hr = d3d12_pipeline_state_init_graphics(object, device, &pipeline_desc);
+            break;
+
+        default:
+            vkd3d_unreachable();
+    }
+
+    if (FAILED(hr))
+    {
+        vkd3d_free(object);
+        return hr;
+    }
+
+    TRACE("Created pipeline state %p.\n", object);
+
+    *state = object;
+    return S_OK;
+}
+
 static enum VkPrimitiveTopology vk_topology_from_d3d12_topology(D3D12_PRIMITIVE_TOPOLOGY topology)
 {
     switch (topology)
@@ -3605,6 +3848,36 @@ VkPipeline d3d12_pipeline_state_get_or_create_pipeline(struct d3d12_pipeline_sta
     return vk_pipeline;
 }
 
+static int compile_hlsl_cs(const struct vkd3d_shader_code *hlsl, struct vkd3d_shader_code *dxbc)
+{
+    struct vkd3d_shader_hlsl_source_info hlsl_info;
+    struct vkd3d_shader_compile_info info;
+
+    static const struct vkd3d_shader_compile_option options[] =
+    {
+        {VKD3D_SHADER_COMPILE_OPTION_API_VERSION, VKD3D_SHADER_API_VERSION_1_9},
+    };
+
+    info.type = VKD3D_SHADER_STRUCTURE_TYPE_COMPILE_INFO;
+    info.next = &hlsl_info;
+    info.source = *hlsl;
+    info.source_type = VKD3D_SHADER_SOURCE_HLSL;
+    info.target_type = VKD3D_SHADER_TARGET_DXBC_TPF;
+    info.options = options;
+    info.option_count = ARRAY_SIZE(options);
+    info.log_level = VKD3D_SHADER_LOG_NONE;
+    info.source_name = NULL;
+
+    hlsl_info.type = VKD3D_SHADER_STRUCTURE_TYPE_HLSL_SOURCE_INFO;
+    hlsl_info.next = NULL;
+    hlsl_info.entry_point = "main";
+    hlsl_info.secondary_code.code = NULL;
+    hlsl_info.secondary_code.size = 0;
+    hlsl_info.profile = "cs_5_0";
+
+    return vkd3d_shader_compile(&info, dxbc, NULL);
+}
+
 static void vkd3d_uav_clear_pipelines_cleanup(struct vkd3d_uav_clear_pipelines *pipelines,
         struct d3d12_device *device)
 {
@@ -3658,7 +3931,7 @@ HRESULT vkd3d_uav_clear_state_init(struct vkd3d_uav_clear_state *state, struct d
     {
         VkPipeline *pipeline;
         VkPipelineLayout *pipeline_layout;
-        D3D12_SHADER_BYTECODE code;
+        struct vkd3d_shader_code code;
     }
     pipelines[] =
     {
@@ -3748,13 +4021,25 @@ HRESULT vkd3d_uav_clear_state_init(struct vkd3d_uav_clear_state *state, struct d
 
     for (i = 0; i < ARRAY_SIZE(pipelines); ++i)
     {
+        struct vkd3d_shader_code dxbc;
+        int ret;
+
+        if ((ret = compile_hlsl_cs(&pipelines[i].code, &dxbc)))
+        {
+            ERR("Failed to compile HLSL compute shader %u, ret %d.\n", i, ret);
+            hr = hresult_from_vk_result(ret);
+            goto fail;
+        }
+
         if (pipelines[i].pipeline_layout == &state->vk_pipeline_layout_buffer)
             binding.flags = VKD3D_SHADER_BINDING_FLAG_BUFFER;
         else
             binding.flags = VKD3D_SHADER_BINDING_FLAG_IMAGE;
 
-        if (FAILED(hr = vkd3d_create_compute_pipeline(device, &pipelines[i].code, &shader_interface,
-                *pipelines[i].pipeline_layout, pipelines[i].pipeline)))
+        hr = vkd3d_create_compute_pipeline(device, &(D3D12_SHADER_BYTECODE){dxbc.code, dxbc.size},
+                &shader_interface, *pipelines[i].pipeline_layout, pipelines[i].pipeline);
+        vkd3d_shader_free_shader_code(&dxbc);
+        if (FAILED(hr))
         {
             ERR("Failed to create compute pipeline %u, hr %#x.\n", i, hr);
             goto fail;
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_main.c b/libs/vkd3d/libs/vkd3d/vkd3d_main.c
index 159560afd8e..245edb5aeac 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_main.c
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_main.c
@@ -71,11 +71,11 @@ HRESULT vkd3d_create_device(const struct vkd3d_device_create_info *create_info,
 
     if (!device)
     {
-        ID3D12Device_Release(&object->ID3D12Device1_iface);
+        ID3D12Device_Release(&object->ID3D12Device5_iface);
         return S_FALSE;
     }
 
-    return return_interface(&object->ID3D12Device1_iface, &IID_ID3D12Device, iid, device);
+    return return_interface(&object->ID3D12Device5_iface, &IID_ID3D12Device, iid, device);
 }
 
 /* ID3D12RootSignatureDeserializer */
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
index 363a7132c3a..231bc615e5c 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
@@ -22,6 +22,9 @@
 #define COBJMACROS
 #define NONAMELESSUNION
 #define VK_NO_PROTOTYPES
+#ifndef CONST_VTABLE
+#define CONST_VTABLE
+#endif
 
 #ifdef _WIN32
 # define _WIN32_WINNT 0x0600  /* for condition variables */
@@ -31,8 +34,8 @@
 #include "vkd3d_blob.h"
 #include "vkd3d_memory.h"
 #include "vkd3d_utf8.h"
-#include "wine/list.h"
-#include "wine/rbtree.h"
+#include "list.h"
+#include "rbtree.h"
 
 #include "vkd3d.h"
 #include "vkd3d_shader.h"
@@ -121,6 +124,7 @@ struct vkd3d_vulkan_info
     bool KHR_draw_indirect_count;
     bool KHR_get_memory_requirements2;
     bool KHR_image_format_list;
+    bool KHR_maintenance2;
     bool KHR_maintenance3;
     bool KHR_push_descriptor;
     bool KHR_sampler_mirror_clamp_to_edge;
@@ -680,7 +684,7 @@ struct d3d12_heap
 };
 
 HRESULT d3d12_heap_create(struct d3d12_device *device, const D3D12_HEAP_DESC *desc,
-        const struct d3d12_resource *resource, struct d3d12_heap **heap);
+        const struct d3d12_resource *resource, ID3D12ProtectedResourceSession *protected_session, struct d3d12_heap **heap);
 struct d3d12_heap *unsafe_impl_from_ID3D12Heap(ID3D12Heap *iface);
 
 #define VKD3D_RESOURCE_PUBLIC_FLAGS \
@@ -716,7 +720,7 @@ struct d3d12_resource_tile_info
 /* ID3D12Resource */
 struct d3d12_resource
 {
-    ID3D12Resource ID3D12Resource_iface;
+    ID3D12Resource1 ID3D12Resource1_iface;
     LONG refcount;
     LONG internal_refcount;
 
@@ -748,7 +752,12 @@ struct d3d12_resource
 
 static inline struct d3d12_resource *impl_from_ID3D12Resource(ID3D12Resource *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d12_resource, ID3D12Resource_iface);
+    return CONTAINING_RECORD(iface, struct d3d12_resource, ID3D12Resource1_iface);
+}
+
+static inline struct d3d12_resource *impl_from_ID3D12Resource1(ID3D12Resource1 *iface)
+{
+    return CONTAINING_RECORD(iface, struct d3d12_resource, ID3D12Resource1_iface);
 }
 
 static inline bool d3d12_resource_is_buffer(const struct d3d12_resource *resource)
@@ -771,7 +780,8 @@ void d3d12_resource_get_tiling(struct d3d12_device *device, const struct d3d12_r
 HRESULT d3d12_committed_resource_create(struct d3d12_device *device,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags,
         const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
-        const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource);
+        const D3D12_CLEAR_VALUE *optimized_clear_value, ID3D12ProtectedResourceSession *protected_session,
+        struct d3d12_resource **resource);
 HRESULT d3d12_placed_resource_create(struct d3d12_device *device, struct d3d12_heap *heap, uint64_t heap_offset,
         const D3D12_RESOURCE_DESC *desc, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource);
@@ -835,6 +845,7 @@ struct vkd3d_texture_view_desc
     VkImageAspectFlags vk_image_aspect;
     VkComponentMapping components;
     bool allowed_swizzle;
+    VkImageUsageFlags usage;
 };
 
 struct vkd3d_desc_header
@@ -1090,7 +1101,7 @@ HRESULT d3d12_query_heap_create(struct d3d12_device *device,
 struct d3d12_query_heap *unsafe_impl_from_ID3D12QueryHeap(ID3D12QueryHeap *iface);
 
 /* A Vulkan query has to be issued at least one time before the result is
- * available. In D3D12 it is legal to get query reults for not issued queries.
+ * available. In D3D12 it is legal to get query results for not issued queries.
  */
 static inline bool d3d12_query_heap_is_result_available(const struct d3d12_query_heap *heap,
         unsigned int query_index)
@@ -1308,10 +1319,38 @@ static inline bool d3d12_pipeline_state_has_unknown_dsv_format(struct d3d12_pipe
     return false;
 }
 
+struct d3d12_pipeline_state_desc
+{
+    ID3D12RootSignature *root_signature;
+    D3D12_SHADER_BYTECODE vs;
+    D3D12_SHADER_BYTECODE ps;
+    D3D12_SHADER_BYTECODE ds;
+    D3D12_SHADER_BYTECODE hs;
+    D3D12_SHADER_BYTECODE gs;
+    D3D12_SHADER_BYTECODE cs;
+    D3D12_STREAM_OUTPUT_DESC stream_output;
+    D3D12_BLEND_DESC blend_state;
+    unsigned int sample_mask;
+    D3D12_RASTERIZER_DESC rasterizer_state;
+    D3D12_DEPTH_STENCIL_DESC1 depth_stencil_state;
+    D3D12_INPUT_LAYOUT_DESC input_layout;
+    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE strip_cut_value;
+    D3D12_PRIMITIVE_TOPOLOGY_TYPE primitive_topology_type;
+    D3D12_RT_FORMAT_ARRAY rtv_formats;
+    DXGI_FORMAT dsv_format;
+    DXGI_SAMPLE_DESC sample_desc;
+    D3D12_VIEW_INSTANCING_DESC view_instancing_desc;
+    unsigned int node_mask;
+    D3D12_CACHED_PIPELINE_STATE cached_pso;
+    D3D12_PIPELINE_STATE_FLAGS flags;
+};
+
 HRESULT d3d12_pipeline_state_create_compute(struct d3d12_device *device,
         const D3D12_COMPUTE_PIPELINE_STATE_DESC *desc, struct d3d12_pipeline_state **state);
 HRESULT d3d12_pipeline_state_create_graphics(struct d3d12_device *device,
         const D3D12_GRAPHICS_PIPELINE_STATE_DESC *desc, struct d3d12_pipeline_state **state);
+HRESULT d3d12_pipeline_state_create(struct d3d12_device *device,
+        const D3D12_PIPELINE_STATE_STREAM_DESC *desc, struct d3d12_pipeline_state **state);
 VkPipeline d3d12_pipeline_state_get_or_create_pipeline(struct d3d12_pipeline_state *state,
         D3D12_PRIMITIVE_TOPOLOGY topology, const uint32_t *strides, VkFormat dsv_format, VkRenderPass *vk_render_pass);
 struct d3d12_pipeline_state *unsafe_impl_from_ID3D12PipelineState(ID3D12PipelineState *iface);
@@ -1426,7 +1465,7 @@ enum vkd3d_pipeline_bind_point
 /* ID3D12CommandList */
 struct d3d12_command_list
 {
-    ID3D12GraphicsCommandList3 ID3D12GraphicsCommandList3_iface;
+    ID3D12GraphicsCommandList5 ID3D12GraphicsCommandList5_iface;
     LONG refcount;
 
     D3D12_COMMAND_LIST_TYPE type;
@@ -1709,7 +1748,7 @@ struct vkd3d_desc_object_cache
 /* ID3D12Device */
 struct d3d12_device
 {
-    ID3D12Device1 ID3D12Device1_iface;
+    ID3D12Device5 ID3D12Device5_iface;
     LONG refcount;
 
     VkDevice vk_device;
@@ -1775,27 +1814,27 @@ struct vkd3d_queue *d3d12_device_get_vkd3d_queue(struct d3d12_device *device, D3
 bool d3d12_device_is_uma(struct d3d12_device *device, bool *coherent);
 void d3d12_device_mark_as_removed(struct d3d12_device *device, HRESULT reason,
         const char *message, ...) VKD3D_PRINTF_FUNC(3, 4);
-struct d3d12_device *unsafe_impl_from_ID3D12Device1(ID3D12Device1 *iface);
+struct d3d12_device *unsafe_impl_from_ID3D12Device5(ID3D12Device5 *iface);
 
 static inline HRESULT d3d12_device_query_interface(struct d3d12_device *device, REFIID iid, void **object)
 {
-    return ID3D12Device1_QueryInterface(&device->ID3D12Device1_iface, iid, object);
+    return ID3D12Device5_QueryInterface(&device->ID3D12Device5_iface, iid, object);
 }
 
 static inline ULONG d3d12_device_add_ref(struct d3d12_device *device)
 {
-    return ID3D12Device1_AddRef(&device->ID3D12Device1_iface);
+    return ID3D12Device5_AddRef(&device->ID3D12Device5_iface);
 }
 
 static inline ULONG d3d12_device_release(struct d3d12_device *device)
 {
-    return ID3D12Device1_Release(&device->ID3D12Device1_iface);
+    return ID3D12Device5_Release(&device->ID3D12Device5_iface);
 }
 
 static inline unsigned int d3d12_device_get_descriptor_handle_increment_size(struct d3d12_device *device,
         D3D12_DESCRIPTOR_HEAP_TYPE descriptor_type)
 {
-    return ID3D12Device1_GetDescriptorHandleIncrementSize(&device->ID3D12Device1_iface, descriptor_type);
+    return ID3D12Device5_GetDescriptorHandleIncrementSize(&device->ID3D12Device5_iface, descriptor_type);
 }
 
 /* utils */
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_shaders.h b/libs/vkd3d/libs/vkd3d/vkd3d_shaders.h
index b2a90cdbf3c..3fefe0da849 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_shaders.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_shaders.h
@@ -19,370 +19,208 @@
 #ifndef __VKD3D_SHADERS_H
 #define __VKD3D_SHADERS_H
 
-static const uint32_t cs_uav_clear_buffer_float_code[] =
-{
-#if 0
-    RWBuffer<float4> dst;
-
-    struct
-    {
-        float4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(128, 1, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (thread_id.x < u_info.dst_extent.x)
-            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0xe114ba61, 0xff6a0d0b, 0x7b25c8f4, 0xfcf7cf22, 0x00000001, 0x0000010c, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400089c, 0x0011e000, 0x00000000, 0x00005555,
-    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000080, 0x00000001, 0x00000001,
-    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
-    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
-    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
-    0x00000000, 0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_buffer_uint_code[] =
-{
-#if 0
-    RWBuffer<uint4> dst;
-
-    struct
-    {
-        uint4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(128, 1, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (thread_id.x < u_info.dst_extent.x)
-            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0x3afd0cfd, 0x5145c166, 0x5b9f76b8, 0xa73775cd, 0x00000001, 0x0000010c, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400089c, 0x0011e000, 0x00000000, 0x00004444,
-    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000080, 0x00000001, 0x00000001,
-    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
-    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
-    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
-    0x00000000, 0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_1d_array_float_code[] =
-{
-#if 0
-    RWTexture1DArray<float4> dst;
-
-    struct
-    {
-        float4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(64, 1, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (thread_id.x < u_info.dst_extent.x)
-            dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0x3d73bc2d, 0x2b635f3d, 0x6bf98e92, 0xbe0aa5d9, 0x00000001, 0x0000011c, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000c8, 0x00050050, 0x00000032, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400389c, 0x0011e000, 0x00000000, 0x00005555,
-    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
-    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
-    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
-    0x00000001, 0x04000036, 0x001000e2, 0x00000000, 0x00020556, 0x080000a4, 0x0011e0f2, 0x00000000,
-    0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_1d_array_uint_code[] =
-{
-#if 0
-    RWTexture1DArray<uint4> dst;
-
-    struct
-    {
-        uint4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(64, 1, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (thread_id.x < u_info.dst_extent.x)
-            dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0x2f0ca457, 0x72068b34, 0xd9dadc2b, 0xd3178c3e, 0x00000001, 0x0000011c, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000c8, 0x00050050, 0x00000032, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400389c, 0x0011e000, 0x00000000, 0x00004444,
-    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
-    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
-    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
-    0x00000001, 0x04000036, 0x001000e2, 0x00000000, 0x00020556, 0x080000a4, 0x0011e0f2, 0x00000000,
-    0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_1d_float_code[] =
-{
-#if 0
-    RWTexture1D<float4> dst;
-
-    struct
-    {
-        float4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(64, 1, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (thread_id.x < u_info.dst_extent.x)
-            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0x05266503, 0x4b97006f, 0x01a5cc63, 0xe617d0a1, 0x00000001, 0x0000010c, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400109c, 0x0011e000, 0x00000000, 0x00005555,
-    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
-    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
-    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
-    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
-    0x00000000, 0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_1d_uint_code[] =
-{
-#if 0
-    RWTexture1D<uint4> dst;
-
-    struct
-    {
-        uint4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(64, 1, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (thread_id.x < u_info.dst_extent.x)
-            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0x19d5c8f2, 0x3ca4ac24, 0x9e258499, 0xf0463fd6, 0x00000001, 0x0000010c, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400109c, 0x0011e000, 0x00000000, 0x00004444,
-    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
-    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
-    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
-    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
-    0x00000000, 0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_2d_array_float_code[] =
-{
-#if 0
-    RWTexture2DArray<float4> dst;
-
-    struct
-    {
-        float4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(8, 8, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (all(thread_id.xy < u_info.dst_extent.xy))
-            dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0x924d2d2c, 0xb9166376, 0x99f83871, 0x8ef65025, 0x00000001, 0x00000138, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400409c, 0x0011e000, 0x00000000, 0x00005555,
-    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
-    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
-    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
-    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
-    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
-    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_2d_array_uint_code[] =
-{
-#if 0
-    RWTexture2DArray<uint4> dst;
-
-    struct
-    {
-        uint4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(8, 8, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (all(thread_id.xy < u_info.dst_extent.xy))
-            dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0xa92219d4, 0xa2c5e47d, 0x0d308500, 0xf32197b4, 0x00000001, 0x00000138, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400409c, 0x0011e000, 0x00000000, 0x00004444,
-    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
-    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
-    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
-    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
-    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
-    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_2d_float_code[] =
-{
-#if 0
-    RWTexture2D<float4> dst;
-
-    struct
-    {
-        float4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(8, 8, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (all(thread_id.xy < u_info.dst_extent.xy))
-            dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0x6e735b3f, 0x7348c4fa, 0xb3634e42, 0x50e2d99b, 0x00000001, 0x00000128, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000d4, 0x00050050, 0x00000035, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400189c, 0x0011e000, 0x00000000, 0x00005555,
-    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
-    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
-    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
-    0x00000000, 0x0700001e, 0x001000f2, 0x00000000, 0x00020546, 0x00208546, 0x00000000, 0x00000001,
-    0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000,
-    0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_2d_uint_code[] =
-{
-#if 0
-    RWTexture2D<uint4> dst;
-
-    struct
-    {
-        uint4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(8, 8, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (all(thread_id.xy < u_info.dst_extent.xy))
-            dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0xf01db5dd, 0xc7dc5e55, 0xb017c1a8, 0x55abd52d, 0x00000001, 0x00000128, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000d4, 0x00050050, 0x00000035, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400189c, 0x0011e000, 0x00000000, 0x00004444,
-    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
-    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
-    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
-    0x00000000, 0x0700001e, 0x001000f2, 0x00000000, 0x00020546, 0x00208546, 0x00000000, 0x00000001,
-    0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000,
-    0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_3d_float_code[] =
-{
-#if 0
-    RWTexture3D<float4> dst;
-
-    struct
-    {
-        float4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(8, 8, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (all(thread_id.xy < u_info.dst_extent.xy))
-            dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0x5d8f36a0, 0x30fa86a5, 0xfec7f2ef, 0xdfd76cbb, 0x00000001, 0x00000138, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400289c, 0x0011e000, 0x00000000, 0x00005555,
-    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
-    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
-    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
-    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
-    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
-    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
-};
-
-static const uint32_t cs_uav_clear_3d_uint_code[] =
-{
-#if 0
-    RWTexture3D<uint4> dst;
-
-    struct
-    {
-        uint4 clear_value;
-        int2 dst_offset;
-        int2 dst_extent;
-    } u_info;
-
-    [numthreads(8, 8, 1)]
-    void main(int3 thread_id : SV_DispatchThreadID)
-    {
-        if (all(thread_id.xy < u_info.dst_extent.xy))
-            dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;
-    }
-#endif
-    0x43425844, 0x5b9c95b1, 0xc9bde4e3, 0x9aaff806, 0x24a1d264, 0x00000001, 0x00000138, 0x00000003,
-    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
-    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
-    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400289c, 0x0011e000, 0x00000000, 0x00004444,
-    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
-    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
-    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
-    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
-    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
-    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
-};
+static const char cs_uav_clear_buffer_float_code[] =
+    "RWBuffer<float4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    float4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(128, 1, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (thread_id.x < u_info.dst_extent.x)\n"
+    "        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_buffer_uint_code[] =
+    "RWBuffer<uint4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    uint4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(128, 1, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (thread_id.x < u_info.dst_extent.x)\n"
+    "        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_1d_array_float_code[] =
+    "RWTexture1DArray<float4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    float4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(64, 1, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (thread_id.x < u_info.dst_extent.x)\n"
+    "        dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_1d_array_uint_code[] =
+    "RWTexture1DArray<uint4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    uint4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(64, 1, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (thread_id.x < u_info.dst_extent.x)\n"
+    "        dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_1d_float_code[] =
+    "RWTexture1D<float4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    float4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(64, 1, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (thread_id.x < u_info.dst_extent.x)\n"
+    "        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_1d_uint_code[] =
+    "RWTexture1D<uint4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    uint4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(64, 1, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (thread_id.x < u_info.dst_extent.x)\n"
+    "        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_2d_array_float_code[] =
+    "RWTexture2DArray<float4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    float4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(8, 8, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (all(thread_id.xy < u_info.dst_extent.xy))\n"
+    "        dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_2d_array_uint_code[] =
+    "RWTexture2DArray<uint4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    uint4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(8, 8, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (all(thread_id.xy < u_info.dst_extent.xy))\n"
+    "        dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_2d_float_code[] =
+    "RWTexture2D<float4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    float4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(8, 8, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (all(thread_id.xy < u_info.dst_extent.xy))\n"
+    "        dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_2d_uint_code[] =
+    "RWTexture2D<uint4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    uint4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(8, 8, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (all(thread_id.xy < u_info.dst_extent.xy))\n"
+    "        dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_3d_float_code[] =
+    "RWTexture3D<float4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    float4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(8, 8, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (all(thread_id.xy < u_info.dst_extent.xy))\n"
+    "        dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;\n"
+    "}\n";
+
+static const char cs_uav_clear_3d_uint_code[] =
+    "RWTexture3D<uint4> dst;\n"
+    "\n"
+    "struct\n"
+    "{\n"
+    "    uint4 clear_value;\n"
+    "    int2 dst_offset;\n"
+    "    int2 dst_extent;\n"
+    "} u_info;\n"
+    "\n"
+    "[numthreads(8, 8, 1)]\n"
+    "void main(int3 thread_id : SV_DispatchThreadID)\n"
+    "{\n"
+    "    if (all(thread_id.xy < u_info.dst_extent.xy))\n"
+    "        dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;\n"
+    "}\n";
 
 #endif /* __VKD3D_SHADERS_H */
-- 
2.42.0

