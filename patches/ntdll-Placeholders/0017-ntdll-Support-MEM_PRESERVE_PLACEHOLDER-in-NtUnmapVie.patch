From af7dcbb2688ca53aa22421b30f02e2b7b08601ca Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 11 Nov 2022 12:54:19 -0600
Subject: [PATCH] ntdll: Support MEM_PRESERVE_PLACEHOLDER in
 NtUnmapViewOfSectionEx().

---
 dlls/kernelbase/tests/process.c | 53 +++++++++++++++++++++++++++++++--
 dlls/ntdll/unix/server.c        |  2 +-
 dlls/ntdll/unix/virtual.c       | 25 +++++++++++++---
 server/protocol.def             |  1 +
 4 files changed, 73 insertions(+), 8 deletions(-)

diff --git a/dlls/kernelbase/tests/process.c b/dlls/kernelbase/tests/process.c
index 03f76a1b73a..448369a3743 100644
--- a/dlls/kernelbase/tests/process.c
+++ b/dlls/kernelbase/tests/process.c
@@ -41,6 +41,7 @@ static PVOID (WINAPI *pVirtualAllocFromApp)(PVOID, SIZE_T, DWORD, DWORD);
 static HANDLE (WINAPI *pOpenFileMappingFromApp)( ULONG, BOOL, LPCWSTR);
 static HANDLE (WINAPI *pCreateFileMappingFromApp)(HANDLE, PSECURITY_ATTRIBUTES, ULONG, ULONG64, PCWSTR);
 static LPVOID (WINAPI *pMapViewOfFileFromApp)(HANDLE, ULONG, ULONG64, SIZE_T);
+static BOOL (WINAPI *pUnmapViewOfFile2)(HANDLE, void *, ULONG);
 
 static void test_CompareObjectHandles(void)
 {
@@ -166,6 +167,13 @@ static void test_VirtualAlloc2(void)
     ret = VirtualFree(addr, 0, MEM_RELEASE);
     ok(ret, "Unexpected return value %d, error %lu.\n", ret, GetLastError());
 
+    placeholder1 = pVirtualAlloc2(NULL, NULL, 2 * size, MEM_RESERVE, PAGE_NOACCESS, NULL, 0);
+    ok(!!placeholder1, "Failed to create a placeholder range.\n");
+    ret = VirtualFree(placeholder1, size, MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER);
+    ok(!ret && GetLastError() == ERROR_INVALID_ADDRESS, "Got ret %d, error %lu.\n", ret, GetLastError());
+    ret = VirtualFree(placeholder1, 0, MEM_RELEASE);
+    ok(ret, "Unexpected return value %d, error %lu.\n", ret, GetLastError());
+
     /* Placeholder splitting functionality */
     placeholder1 = pVirtualAlloc2(NULL, NULL, 2 * size, MEM_RESERVE_PLACEHOLDER | MEM_RESERVE, PAGE_NOACCESS, NULL, 0);
     ok(!!placeholder1, "Failed to create a placeholder range.\n");
@@ -199,11 +207,20 @@ static void test_VirtualAlloc2(void)
     section = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, size, NULL);
     ok(!!section, "Failed to create a section.\n");
 
-    view1 = pMapViewOfFile3(section, NULL, placeholder1, 0, size, MEM_REPLACE_PLACEHOLDER, PAGE_READWRITE, NULL, 0);
+    view1 = pMapViewOfFile3(section, NULL, NULL, 0, size, 0, PAGE_READWRITE, NULL, 0);
     ok(!!view1, "Failed to map a section.\n");
+    ret = VirtualFree( view1, size, MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER );
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "Got ret %d, error %lu.\n", ret, GetLastError());
+    ret = pUnmapViewOfFile2(GetCurrentProcess(), view1, MEM_PRESERVE_PLACEHOLDER);
+    ok(!ret && GetLastError() == ERROR_INVALID_ADDRESS, "Got ret %d, error %lu.\n", ret, GetLastError());
+    ret = pUnmapViewOfFile2(GetCurrentProcess(), view1, 0);
+    ok(ret, "Got error %lu.\n", GetLastError());
+
+    view1 = pMapViewOfFile3(section, NULL, placeholder1, 0, size, MEM_REPLACE_PLACEHOLDER, PAGE_READWRITE, NULL, 0);
+    ok(view1 == placeholder1, "Address does not match.\n");
 
     view2 = pMapViewOfFile3(section, NULL, placeholder2, 0, size, MEM_REPLACE_PLACEHOLDER, PAGE_READWRITE, NULL, 0);
-    ok(!!view2, "Failed to map a section.\n");
+    ok(view2 == placeholder2, "Address does not match.\n");
 
     memset(&info, 0, sizeof(info));
     VirtualQuery(placeholder1, &info, sizeof(info));
@@ -220,7 +237,34 @@ static void test_VirtualAlloc2(void)
     ok(info.RegionSize == size, "Unexpected size.\n");
 
     CloseHandle(section);
-    UnmapViewOfFile(view1);
+    ret = pUnmapViewOfFile2(NULL, view1, MEM_PRESERVE_PLACEHOLDER);
+    ok(!ret && GetLastError() == ERROR_INVALID_HANDLE, "Got error %lu.\n", GetLastError());
+
+    ret = VirtualFree( placeholder1, size, MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER );
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "Got ret %d, error %lu.\n", ret, GetLastError());
+
+    ret = pUnmapViewOfFile2(GetCurrentProcess(), view1, MEM_PRESERVE_PLACEHOLDER);
+    ok(ret, "Got error %lu.\n", GetLastError());
+    memset(&info, 0, sizeof(info));
+    VirtualQuery(placeholder1, &info, sizeof(info));
+    ok(info.AllocationProtect == PAGE_NOACCESS, "Unexpected protection %#lx.\n", info.AllocationProtect);
+    ok(info.State == MEM_RESERVE, "Unexpected state %#lx.\n", info.State);
+    ok(info.Type == MEM_PRIVATE, "Unexpected type %#lx.\n", info.Type);
+    ok(info.RegionSize == size, "Unexpected size.\n");
+
+    ret = pUnmapViewOfFile2(GetCurrentProcess(), view1, MEM_PRESERVE_PLACEHOLDER);
+    ok(!ret && GetLastError() == ERROR_INVALID_ADDRESS, "Got error %lu.\n", GetLastError());
+
+    ret = UnmapViewOfFile(view1);
+    ok(!ret && GetLastError() == ERROR_INVALID_ADDRESS, "Got error %lu.\n", GetLastError());
+
+    ret = VirtualFree( placeholder1, size, MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER );
+    ok(!ret && GetLastError() == ERROR_INVALID_ADDRESS, "Got ret %d, error %lu.\n", ret, GetLastError());
+    ret = VirtualFreeEx(GetCurrentProcess(), placeholder1, size, MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER );
+    ok(!ret && GetLastError() == ERROR_INVALID_ADDRESS, "Got ret %d, error %lu.\n", ret, GetLastError());
+    ret = VirtualFree(placeholder1, 0, MEM_RELEASE);
+    ok(ret, "Got error %lu.\n", GetLastError());
+
     UnmapViewOfFile(view2);
 
     VirtualFree(placeholder1, 0, MEM_RELEASE);
@@ -250,6 +294,8 @@ static void test_VirtualAlloc2(void)
 
     p1 = p;
     p2 = p + size / 2;
+    ret = VirtualFree(p1, 0, MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "Got ret %d, error %lu.\n", ret, GetLastError());
     ret = VirtualFree(p1, size / 2, MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER);
     ok(ret, "Failed to split a placeholder.\n");
     check_region_size(p1, size / 2);
@@ -462,6 +508,7 @@ static void init_funcs(void)
     X(VirtualAlloc2);
     X(VirtualAlloc2FromApp);
     X(VirtualAllocFromApp);
+    X(UnmapViewOfFile2);
 
     hmod = GetModuleHandleA("ntdll.dll");
 
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index c143560e360..40efda551e0 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -618,7 +618,7 @@ static void invoke_system_apc( const apc_call_t *call, apc_result_t *result, BOO
         result->type = call->type;
         addr = wine_server_get_ptr( call->unmap_view.addr );
         if ((ULONG_PTR)addr == call->unmap_view.addr)
-            result->unmap_view.status = NtUnmapViewOfSection( NtCurrentProcess(), addr );
+            result->unmap_view.status = NtUnmapViewOfSectionEx( NtCurrentProcess(), addr, call->unmap_view.flags );
         else
             result->unmap_view.status = STATUS_INVALID_PARAMETER;
         break;
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index 320596c740e..493f6b80419 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -5208,7 +5208,7 @@ NTSTATUS WINAPI NtMapViewOfSectionEx( HANDLE handle, HANDLE process, PVOID *addr
     return virtual_map_section( handle, addr_ptr, limit, 0, offset_ptr, size_ptr, alloc_type, protect );
 }
 
-NTSTATUS unmap_view_of_section( HANDLE process, PVOID addr )
+static NTSTATUS unmap_view_of_section( HANDLE process, PVOID addr, ULONG flags )
 {
     struct file_view *view;
     unsigned int status = STATUS_NOT_MAPPED_VIEW;
@@ -5223,6 +5223,7 @@ NTSTATUS unmap_view_of_section( HANDLE process, PVOID addr )
 
         call.unmap_view.type = APC_UNMAP_VIEW;
         call.unmap_view.addr = wine_server_client_ptr( addr );
+        call.unmap_view.flags = flags;
         status = server_queue_process_apc( process, &call, &result );
         if (status == STATUS_SUCCESS) status = result.unmap_view.status;
         return status;
@@ -5231,6 +5232,11 @@ NTSTATUS unmap_view_of_section( HANDLE process, PVOID addr )
     server_enter_uninterrupted_section( &virtual_mutex, &sigset );
     if ((view = find_view( addr, 0 )) && !is_view_valloc( view ))
     {
+        if (flags & MEM_PRESERVE_PLACEHOLDER && !(view->protect & VPROT_FROMPLACEHOLDER))
+        {
+            status = STATUS_CONFLICTING_ADDRESSES;
+            goto done;
+        }
         if (view->protect & VPROT_SYSTEM)
         {
             struct builtin_module *builtin;
@@ -5257,10 +5263,21 @@ NTSTATUS unmap_view_of_section( HANDLE process, PVOID addr )
         if (!status)
         {
             if (view->protect & SEC_IMAGE) release_builtin_module( view->base );
-            delete_view( view );
+            if (flags & MEM_PRESERVE_PLACEHOLDER)
+            {
+                view->protect = VPROT_PLACEHOLDER;
+                set_page_vprot( view->base, view->size, 0 );
+                if (anon_mmap_fixed(view->base, view->size, 0, 0) != view->base)
+                    ERR("anon_mmap_fixed failed, err %s.\n", strerror(errno));
+            }
+            else
+            {
+                delete_view( view );
+            }
         }
         else FIXME( "failed to unmap %p %x\n", view->base, status );
     }
+done:
     server_leave_uninterrupted_section( &virtual_mutex, &sigset );
     return status;
 }
@@ -5271,7 +5288,7 @@ NTSTATUS unmap_view_of_section( HANDLE process, PVOID addr )
  */
 NTSTATUS WINAPI NtUnmapViewOfSection( HANDLE process, PVOID addr )
 {
-    return unmap_view_of_section( process, addr );
+    return unmap_view_of_section( process, addr, 0 );
 }
 
 /***********************************************************************
@@ -5281,7 +5298,7 @@ NTSTATUS WINAPI NtUnmapViewOfSection( HANDLE process, PVOID addr )
 NTSTATUS WINAPI NtUnmapViewOfSectionEx( HANDLE process, PVOID addr, ULONG flags )
 {
     if (flags) FIXME("Ignoring flags %#x.\n", (int)flags);
-    return unmap_view_of_section( process, addr );
+    return unmap_view_of_section( process, addr, flags );
 }
 
 /******************************************************************************
diff --git a/server/protocol.def b/server/protocol.def
index 8f5202792b4..10729e3ff64 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -615,6 +615,7 @@ typedef union
         enum apc_type    type;      /* APC_UNMAP_VIEW */
         int              __pad;
         client_ptr_t     addr;      /* view address */
+        unsigned int     flags;     /* unmap flags */
     } unmap_view;
     struct
     {
-- 
2.40.1

